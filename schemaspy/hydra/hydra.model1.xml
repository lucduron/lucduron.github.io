<?xml version="1.0" encoding="UTF-8"?><database name="hydra" schema="model1" type="PostgreSQL - 13.3">
   <sequences>
      <sequence increment="1" name="_constrain_id_seq" startValue="1"/>
      <sequence increment="1" name="_link_id_seq" startValue="1"/>
      <sequence increment="1" name="_node_id_seq" startValue="1"/>
      <sequence increment="1" name="_singularity_id_seq" startValue="1"/>
      <sequence increment="1" name="bank_id_seq" startValue="1"/>
      <sequence increment="1" name="catchment_id_seq" startValue="1"/>
      <sequence increment="1" name="closed_parametric_geometry_id_seq" startValue="1"/>
      <sequence increment="1" name="configuration_id_seq" startValue="1"/>
      <sequence increment="1" name="coverage_id_seq" startValue="1"/>
      <sequence increment="1" name="coverage_marker_id_seq" startValue="1"/>
      <sequence increment="1" name="domain_2d_id_seq" startValue="1"/>
      <sequence increment="1" name="domain_2d_marker_id_seq" startValue="1"/>
      <sequence increment="1" name="generation_step_id_seq" startValue="1"/>
      <sequence increment="1" name="open_parametric_geometry_id_seq" startValue="1"/>
      <sequence increment="1" name="reach_id_seq" startValue="1"/>
      <sequence increment="1" name="station_id_seq" startValue="1"/>
      <sequence increment="1" name="street_id_seq" startValue="1"/>
      <sequence increment="1" name="urban_flood_risk_area_id_seq" startValue="1"/>
      <sequence increment="1" name="valley_cross_section_geometry_id_seq" startValue="1"/>
      <sequence increment="1" name="valley_cross_section_topo_geometry_id_seq" startValue="1"/>
   </sequences>
   <tables>
      <table name="_air_duct_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_air_duct_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_air_duct_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="perimeter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="friction_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="custom_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_air_duct_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'air_duct'::hydra_link_type))" name="_air_duct_link_link_type_check"/>
      </table>
      <table name="_air_flow_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_air_flow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_air_flow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="flow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="is_inwards" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_air_flow_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'air_flow_bc'::hydra_singularity_type))" name="_air_flow_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_air_headloss_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_air_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_air_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="up_to_down_headloss_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="down_to_up_headloss_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_air_headloss_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'air_headloss'::hydra_link_type))" name="_air_headloss_link_link_type_check"/>
      </table>
      <table name="_air_pressure_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_air_pressure_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_air_pressure_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="relative_pressure" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_air_pressure_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'air_pressure_bc'::hydra_singularity_type))" name="_air_pressure_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_borda_headloss_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_borda_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_borda_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="law_type" nullable="true" remarks="" size="2147483647" type="hydra_borda_headloss_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <index name="_borda_headloss_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'borda_headloss'::hydra_link_type))" name="_borda_headloss_link_link_type_check"/>
      </table>
      <table name="_borda_headloss_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_borda_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_borda_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="law_type" nullable="true" remarks="" size="2147483647" type="hydra_borda_headloss_singularity_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_borda_headloss_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'borda_headloss'::hydra_singularity_type))" name="_borda_headloss_singularity_singularity_type_check"/>
      </table>
      <table name="_bradley_headloss_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_bradley_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_bradley_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="d_abutment_l" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="d_abutment_r" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="abutment_type" nullable="true" remarks="" size="2147483647" type="hydra_abutment_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="zw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_bradley_headloss_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'bradley_headloss'::hydra_singularity_type))" name="_bradley_headloss_singularity_singularity_type_check"/>
      </table>
      <table name="_bridge_headloss_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_bridge_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_bridge_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="l_road" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_road" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="zw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_bridge_headloss_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'bridge_headloss'::hydra_singularity_type))" name="_bridge_headloss_singularity_singularity_type_check"/>
      </table>
      <table name="_catchment_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_catchment_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_catchment_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area_ha" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="rl" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="c_imp" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="netflow_type" nullable="true" remarks="" size="2147483647" type="hydra_netflow_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="constant_runoff" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="0.6" digits="8" id="8" name="horner_ini_loss_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="0.12" digits="8" id="9" name="horner_recharge_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="2" digits="8" id="10" name="holtan_sat_inf_rate_mmh" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="10" digits="8" id="11" name="holtan_dry_inf_rate_mmh" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="50" digits="8" id="12" name="holtan_soil_storage_cap_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="150" digits="8" id="13" name="scs_j_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="10" digits="8" id="14" name="scs_soil_drainage_time_day" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="50" digits="8" id="15" name="scs_rfu_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="hydra_surface_soil_storage_rfu_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="hydra_inf_rate_f0_mm_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="hydra_int_soil_storage_j_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="hydra_soil_drainage_time_qres_day" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="hydra_split_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="hydra_catchment_connect_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="hydra_aquifer_infiltration_rate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="hydra_soil_infiltration_type" nullable="true" remarks="" size="2147483647" type="hydra_soil_infiltration_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="24" name="gr4_k1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="25" name="gr4_k2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="26" name="gr4_k3" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="27" name="gr4_k4" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="runoff_type" nullable="true" remarks="" size="2147483647" type="hydra_runoff_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="29" name="socose_tc_mn" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="30" name="socose_shape_param_beta" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="31" name="define_k_mn" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="32" name="q_limit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="33" name="q0" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="34" name="contour" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_catchment_node_contour_fkey" implied="false" onDeleteCascade="false" schema="model1" table="catchment"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="35" name="network_type" nullable="true" remarks="" size="2147483647" type="hydra_network_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="36" name="rural_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="37" name="industrial_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="38" name="suburban_housing_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="39" name="dense_housing_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_catchment_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'catchment'::hydra_node_type))" name="_catchment_node_node_type_check"/>
      </table>
      <table name="_connector_hydrology_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_connector_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_connector_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="hydrograph" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_connector_hydrology_link_hydrograph_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrograph_bc_singularity"/>
         </column>
         <index name="_connector_hydrology_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'connector_hydrology'::hydra_link_type))" name="_connector_hydrology_link_link_type_check"/>
      </table>
      <table name="_connector_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_connector_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_connector_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="main_branch" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_connector_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'connector'::hydra_link_type))" name="_connector_link_link_type_check"/>
      </table>
      <table name="_constant_inflow_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_constant_inflow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_constant_inflow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="q0" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_constant_inflow_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'constant_inflow_bc'::hydra_singularity_type))" name="_constant_inflow_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_constrain" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1._constrain_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="transect" foreignKey="valley_cross_section_geometry_transect_fkey" implied="false" onDeleteCascade="false" schema="model1" table="valley_cross_section_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="discretized" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="100" digits="8" id="4" name="elem_length" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="constrain_type" nullable="true" remarks="" size="2147483647" type="hydra_constrain_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="link_attributes" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="points_xyz" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_constrain_points_xyz_fkey" implied="false" onDeleteCascade="false" schema="project" table="points_type"/>
         </column>
         <column autoUpdated="false" defaultValue="1" digits="8" id="8" name="points_xyz_proximity" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="line_xyz" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_constrain_line_xyz_fkey" implied="false" onDeleteCascade="false" schema="project" table="line_xyz"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="_constrain_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_constrain_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_constrain_discretized_geom_idx" unique="false">
            <column ascending="true" name="discretized"/>
         </index>
         <index name="model1_constrain_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="_constrain_geom_check"/>
         <checkConstraint constraint="(st_isvalid(geom))" name="_constrain_geom_check1"/>
      </table>
      <table name="_crossroad_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_crossroad_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_crossroad_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="h" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_crossroad_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'crossroad'::hydra_node_type))" name="_crossroad_node_node_type_check"/>
      </table>
      <table name="_deriv_pump_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_deriv_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_deriv_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="q_pump" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="qz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <index name="_deriv_pump_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'deriv_pump'::hydra_link_type))" name="_deriv_pump_link_link_type_check"/>
      </table>
      <table name="_elem_2d_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_elem_2d_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_elem_2d_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zb" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="domain_2d" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_elem_2d_node_domain_2d_fkey" implied="false" onDeleteCascade="true" schema="model1" table="domain_2d"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="contour" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_elem_2d_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="model1_elem_2d_node_contour_idx" unique="false">
            <column ascending="true" name="contour"/>
         </index>
         <checkConstraint constraint="((st_isvalid(contour) AND (st_npoints(contour) = ANY (ARRAY[4, 5]))))" name="_elem_2d_node_contour_check"/>
         <checkConstraint constraint="((node_type = 'elem_2d'::hydra_node_type))" name="_elem_2d_node_node_type_check"/>
      </table>
      <table name="_froude_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_froude_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_froude_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <index name="_froude_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'froude_bc'::hydra_singularity_type))" name="_froude_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_fuse_spillway_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_fuse_spillway_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_fuse_spillway_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="break_mode" nullable="true" remarks="" size="2147483647" type="hydra_fuse_spillway_break_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="z_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="t_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="grp" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="dt_fracw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <index name="_fuse_spillway_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'fuse_spillway'::hydra_link_type))" name="_fuse_spillway_link_link_type_check"/>
      </table>
      <table name="_gate_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="mode_valve" nullable="true" remarks="" size="2147483647" type="hydra_valve_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_gate_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'gate'::hydra_link_type))" name="_gate_link_link_type_check"/>
      </table>
      <table name="_gate_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="mode_valve" nullable="true" remarks="" size="2147483647" type="hydra_valve_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_gate_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'gate'::hydra_singularity_type))" name="_gate_singularity_singularity_type_check"/>
      </table>
      <table name="_hydraulic_cut_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_hydraulic_cut_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_hydraulic_cut_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="qz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_hydraulic_cut_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'hydraulic_cut'::hydra_singularity_type))" name="_hydraulic_cut_singularity_singularity_type_check"/>
      </table>
      <table name="_hydrograph_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="hydrograph" foreignKey="_connector_hydrology_link_hydrograph_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_connector_hydrology_link"/>
            <child column="hydrograph" foreignKey="_routing_hydrology_link_hydrograph_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_routing_hydrology_link"/>
            <parent column="id" foreignKey="_hydrograph_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_hydrograph_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="storage_area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="constant_dry_flow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="distrib_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="lag_time_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="sector" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_hydrograph_bc_singularity_sector_fkey" implied="false" onDeleteCascade="false" schema="project" table="dry_inflow_sector"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="hourly_modulation" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_hydrograph_bc_singularity_hourly_modulation_fkey" implied="false" onDeleteCascade="false" schema="project" table="dry_inflow_hourly_modulation"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="pollution_dryweather_runoff" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="quality_dryweather_runoff" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="external_file_data" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_hydrograph_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'hydrograph_bc'::hydra_singularity_type))" name="_hydrograph_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_hydrology_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_hydrology_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_hydrology_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <index name="_hydrology_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'hydrology_bc'::hydra_singularity_type))" name="_hydrology_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_jet_fan_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_jet_fan_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_jet_fan_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="unit_thrust_newton" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="number_of_units" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="efficiency" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="flow_velocity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="pipe_area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="is_up_to_down" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_jet_fan_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'jet_fan'::hydra_link_type))" name="_jet_fan_link_link_type_check"/>
      </table>
      <table name="_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1._link_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="id" foreignKey="_air_duct_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_air_duct_link"/>
            <child column="id" foreignKey="_air_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_air_headloss_link"/>
            <child column="id" foreignKey="_borda_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_borda_headloss_link"/>
            <child column="id" foreignKey="_connector_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_connector_hydrology_link"/>
            <child column="id" foreignKey="_connector_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_connector_link"/>
            <child column="id" foreignKey="_deriv_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_deriv_pump_link"/>
            <child column="id" foreignKey="_fuse_spillway_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_fuse_spillway_link"/>
            <child column="id" foreignKey="_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_gate_link"/>
            <child column="id" foreignKey="_jet_fan_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_jet_fan_link"/>
            <child column="id" foreignKey="_mesh_2d_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_mesh_2d_link"/>
            <child column="id" foreignKey="_network_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_network_overflow_link"/>
            <child column="id" foreignKey="_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_overflow_link"/>
            <child column="id" foreignKey="_pipe_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_pipe_link"/>
            <child column="id" foreignKey="_porous_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_porous_link"/>
            <child column="id" foreignKey="_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_pump_link"/>
            <child column="downstream" foreignKey="_qq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="split1" foreignKey="_qq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="split2" foreignKey="_qq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="id" foreignKey="_regul_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_regul_gate_link"/>
            <child column="drainage" foreignKey="_reservoir_rs_hydrology_singularity_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="overflow" foreignKey="_reservoir_rs_hydrology_singularity_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="drainage" foreignKey="_reservoir_rsp_hydrology_singularit_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="overflow" foreignKey="_reservoir_rsp_hydrology_singularit_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="id" foreignKey="_routing_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_routing_hydrology_link"/>
            <child column="id" foreignKey="_strickler_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_strickler_link"/>
            <child column="id" foreignKey="_ventilator_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_ventilator_link"/>
            <child column="id" foreignKey="_weir_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_weir_link"/>
            <child column="downstream" foreignKey="_zq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="split1" foreignKey="_zq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="split2" foreignKey="_zq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <child column="link_type" foreignKey="_air_duct_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_air_duct_link"/>
            <child column="link_type" foreignKey="_air_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_air_headloss_link"/>
            <child column="link_type" foreignKey="_borda_headloss_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_borda_headloss_link"/>
            <child column="link_type" foreignKey="_connector_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_connector_hydrology_link"/>
            <child column="link_type" foreignKey="_connector_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_connector_link"/>
            <child column="link_type" foreignKey="_deriv_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_deriv_pump_link"/>
            <child column="link_type" foreignKey="_fuse_spillway_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_fuse_spillway_link"/>
            <child column="link_type" foreignKey="_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_gate_link"/>
            <child column="link_type" foreignKey="_jet_fan_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_jet_fan_link"/>
            <child column="link_type" foreignKey="_mesh_2d_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_mesh_2d_link"/>
            <child column="link_type" foreignKey="_network_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_network_overflow_link"/>
            <child column="link_type" foreignKey="_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_overflow_link"/>
            <child column="link_type" foreignKey="_pipe_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_pipe_link"/>
            <child column="link_type" foreignKey="_porous_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_porous_link"/>
            <child column="link_type" foreignKey="_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_pump_link"/>
            <child column="downstream_type" foreignKey="_qq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="split1_type" foreignKey="_qq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="split2_type" foreignKey="_qq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="link_type" foreignKey="_regul_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_regul_gate_link"/>
            <child column="drainage_type" foreignKey="_reservoir_rs_hydrology_singularity_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="overflow_type" foreignKey="_reservoir_rs_hydrology_singularity_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="drainage_type" foreignKey="_reservoir_rsp_hydrology_singularit_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="overflow_type" foreignKey="_reservoir_rsp_hydrology_singularit_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="link_type" foreignKey="_routing_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_routing_hydrology_link"/>
            <child column="link_type" foreignKey="_strickler_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_strickler_link"/>
            <child column="link_type" foreignKey="_ventilator_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_ventilator_link"/>
            <child column="link_type" foreignKey="_weir_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_weir_link"/>
            <child column="downstream_type" foreignKey="_zq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="split1_type" foreignKey="_zq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="split2_type" foreignKey="_zq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_link_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="generation_step"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_link_up_up_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_link_up_up_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_link_down_down_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_link_down_down_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="_link_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_link_id_link_type_key" unique="true">
            <column ascending="true" name="id"/>
            <column ascending="true" name="link_type"/>
         </index>
         <index name="_link_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_link_configuration_idx" unique="false"/>
         <index name="model1_link_down_idx" unique="false">
            <column ascending="true" name="down"/>
         </index>
         <index name="model1_link_generated_idx" unique="false">
            <column ascending="true" name="generated"/>
         </index>
         <index name="model1_link_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <index name="model1_link_name_idx" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_link_up_idx" unique="false">
            <column ascending="true" name="up"/>
         </index>
         <index name="model1_link_validity_idx" unique="false">
            <column ascending="true" name="validity"/>
         </index>
         <checkConstraint constraint="(((up IS NOT NULL) OR (up_type = 'elem_2d'::hydra_node_type)))" name="_link_check"/>
         <checkConstraint constraint="(((down IS NOT NULL) OR (down_type = 'elem_2d'::hydra_node_type)))" name="_link_check1"/>
         <checkConstraint constraint="((down_type &lt;&gt; 'catchment'::hydra_node_type))" name="_link_down_type_check"/>
         <checkConstraint constraint="(st_isvalid(geom))" name="_link_geom_check"/>
         <checkConstraint constraint="((((link_type = 'air_duct'::hydra_link_type) AND ((up_type = 'station'::hydra_node_type) AND (down_type = 'station'::hydra_node_type))) OR ((link_type = 'air_headloss'::hydra_link_type) AND ((up_type = 'station'::hydra_node_type) AND (down_type = 'station'::hydra_node_type))) OR ((link_type = 'ventilator'::hydra_link_type) AND ((up_type = 'station'::hydra_node_type) AND (down_type = 'station'::hydra_node_type))) OR ((link_type = 'jet_fan'::hydra_link_type) AND ((up_type = 'station'::hydra_node_type) AND (down_type = 'station'::hydra_node_type))) OR ((link_type = 'regul_gate'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'connector'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'fuse_spillway'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'pipe'::hydra_link_type) AND (((up_type = 'manhole_hydrology'::hydra_node_type) AND (down_type = 'manhole_hydrology'::hydra_node_type)) OR ((up_type = 'manhole'::hydra_node_type) AND (down_type = 'manhole'::hydra_node_type)))) OR ((link_type = 'routing_hydrology'::hydra_link_type) AND ((up_type = 'catchment'::hydra_node_type) AND (down_type = ANY (ARRAY['manhole_hydrology'::hydra_node_type, 'manhole'::hydra_node_type, 'river'::hydra_node_type, 'station'::hydra_node_type, 'storage'::hydra_node_type, 'crossroad'::hydra_node_type, 'elem_2d'::hydra_node_type])))) OR ((link_type = 'deriv_pump'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'porous'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'weir'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'borda_headloss'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'pump'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'mesh_2d'::hydra_link_type) AND ((up_type = 'elem_2d'::hydra_node_type) AND (down_type = 'elem_2d'::hydra_node_type))) OR ((link_type = 'overflow'::hydra_link_type) AND ((up_type = ANY (ARRAY['river'::hydra_node_type, 'storage'::hydra_node_type, 'elem_2d'::hydra_node_type, 'crossroad'::hydra_node_type])) AND (down_type = ANY (ARRAY['river'::hydra_node_type, 'storage'::hydra_node_type, 'elem_2d'::hydra_node_type, 'crossroad'::hydra_node_type])))) OR ((link_type = 'network_overflow'::hydra_link_type) AND ((up_type = 'manhole'::hydra_node_type) AND (down_type = ANY (ARRAY['crossroad'::hydra_node_type, 'elem_2d'::hydra_node_type, 'storage'::hydra_node_type, 'river'::hydra_node_type])))) OR ((link_type = 'gate'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])))) OR ((link_type = 'connector_hydrology'::hydra_link_type) AND ((up_type = 'manhole_hydrology'::hydra_node_type) AND (down_type = ANY (ARRAY['manhole_hydrology'::hydra_node_type, 'manhole'::hydra_node_type, 'river'::hydra_node_type, 'station'::hydra_node_type, 'storage'::hydra_node_type, 'crossroad'::hydra_node_type, 'elem_2d'::hydra_node_type])))) OR ((link_type = 'strickler'::hydra_link_type) AND ((up_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type])) AND (down_type &lt;&gt; ALL (ARRAY['catchment'::hydra_node_type, 'manhole_hydrology'::hydra_node_type]))))))" name="model1_link_connectivity_check_cstr"/>
      </table>
      <table name="_manhole_hydrology_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_manhole_hydrology_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_manhole_hydrology_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_manhole_hydrology_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'manhole_hydrology'::hydra_node_type))" name="_manhole_hydrology_node_node_type_check"/>
      </table>
      <table name="_manhole_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_manhole_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_manhole_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cover_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cover_critical_pressure" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="inlet_width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="inlet_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="connection_law" nullable="true" remarks="" size="2147483647" type="hydra_manhole_connection_type" typeCode="12"/>
         <index name="_manhole_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'manhole'::hydra_node_type))" name="_manhole_node_node_type_check"/>
      </table>
      <table name="_marker_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <index name="_marker_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'marker'::hydra_singularity_type))" name="_marker_singularity_singularity_type_check"/>
      </table>
      <table name="_mesh_2d_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_mesh_2d_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_mesh_2d_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="lateral_contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_mesh_2d_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'mesh_2d'::hydra_link_type))" name="_mesh_2d_link_link_type_check"/>
      </table>
      <table name="_model_connect_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_model_connect_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_model_connect_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="cascade_mode" nullable="true" remarks="" size="2147483647" type="hydra_model_connect_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="quality" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <index name="_model_connect_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'model_connect_bc'::hydra_singularity_type))" name="_model_connect_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_network_overflow_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_network_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_network_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_overflow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_network_overflow_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'network_overflow'::hydra_link_type))" name="_network_overflow_link_link_type_check"/>
      </table>
      <table name="_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1._node_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="id" foreignKey="_catchment_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_catchment_node"/>
            <child column="id" foreignKey="_crossroad_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_crossroad_node"/>
            <child column="id" foreignKey="_elem_2d_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_elem_2d_node"/>
            <child column="down" foreignKey="_link_down_down_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
            <child column="up" foreignKey="_link_up_up_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
            <child column="id" foreignKey="_manhole_hydrology_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_manhole_hydrology_node"/>
            <child column="id" foreignKey="_manhole_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_manhole_node"/>
            <child column="z_control_node" foreignKey="_regul_gate_link_z_control_node_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_regul_gate_link"/>
            <child column="z_control_node" foreignKey="_regul_sluice_gate_singularity_z_control_node_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_regul_sluice_gate_singularity"/>
            <child column="id" foreignKey="_river_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_river_node"/>
            <child column="node" foreignKey="_singularity_node_node_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
            <child column="id" foreignKey="_station_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_station_node"/>
            <child column="id" foreignKey="_storage_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_storage_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <child column="node_type" foreignKey="_catchment_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_catchment_node"/>
            <child column="node_type" foreignKey="_crossroad_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_crossroad_node"/>
            <child column="node_type" foreignKey="_elem_2d_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_elem_2d_node"/>
            <child column="down_type" foreignKey="_link_down_down_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
            <child column="up_type" foreignKey="_link_up_up_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
            <child column="node_type" foreignKey="_manhole_hydrology_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_manhole_hydrology_node"/>
            <child column="node_type" foreignKey="_manhole_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_manhole_node"/>
            <child column="node_type" foreignKey="_river_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_river_node"/>
            <child column="node_type" foreignKey="_singularity_node_node_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
            <child column="node_type" foreignKey="_station_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_station_node"/>
            <child column="node_type" foreignKey="_storage_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_storage_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_node_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="generation_step"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="_node_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_node_geom_key" unique="true">
            <column ascending="true" name="geom"/>
         </index>
         <index name="_node_id_node_type_key" unique="true">
            <column ascending="true" name="id"/>
            <column ascending="true" name="node_type"/>
         </index>
         <index name="_node_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_node_configuration_idx" unique="false"/>
         <index name="model1_node_generated_idx" unique="false">
            <column ascending="true" name="generated"/>
         </index>
         <index name="model1_node_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <index name="model1_node_name_idx" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_node_validity_idx" unique="false">
            <column ascending="true" name="validity"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="_node_geom_check"/>
      </table>
      <table name="_overflow_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_overflow_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_crest1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_crest2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="lateral_contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="break_mode" nullable="true" remarks="" size="2147483647" type="hydra_fuse_spillway_break_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="z_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="t_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="width_breach" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="grp" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="dt_fracw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_overflow_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'overflow'::hydra_link_type))" name="_overflow_link_link_type_check"/>
      </table>
      <table name="_param_headloss_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_param_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_param_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="q_dz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_param_headloss_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'param_headloss'::hydra_singularity_type))" name="_param_headloss_singularity_singularity_type_check"/>
      </table>
      <table name="_pipe_branch_marker_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pipe_branch_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_pipe_branch_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="pk0_km" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="dx" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_pipe_branch_marker_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'pipe_branch_marker'::hydra_singularity_type))" name="_pipe_branch_marker_singularity_singularity_type_check"/>
      </table>
      <table name="_pipe_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pipe_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_pipe_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="cross_section_type" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="h_sable" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="branch" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pipe_link_branch_fkey" implied="false" onDeleteCascade="false" schema="model1" table="branch"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="exclude_from_branch" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="custom_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pipe_link_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="closed_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pipe_link_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="open_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_pipe_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'pipe'::hydra_link_type))" name="_pipe_link_link_type_check"/>
      </table>
      <table name="_porous_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_porous_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_porous_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="transmitivity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_porous_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'porous'::hydra_link_type))" name="_porous_link_link_type_check"/>
      </table>
      <table name="_pump_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_pump_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="npump" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zregul_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="response_time_sec" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_pump_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'pump'::hydra_link_type))" name="_pump_link_link_type_check"/>
      </table>
      <table name="_qq_split_hydrology_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_qq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_qq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="qq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="downstream" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_qq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="downstream_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_qq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="split1" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_qq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="split1_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_qq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="split2" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_qq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="split2_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_qq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <index name="_qq_split_hydrology_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="(((split2 IS NULL) OR (split2_type = 'pipe'::hydra_link_type) OR (split2_type = 'connector_hydrology'::hydra_link_type)))" name="_qq_split_hydrology_singularity_check"/>
         <checkConstraint constraint="(((downstream_type = 'pipe'::hydra_link_type) OR (downstream_type = 'connector_hydrology'::hydra_link_type)))" name="_qq_split_hydrology_singularity_downstream_type_check"/>
         <checkConstraint constraint="((singularity_type = 'qq_split_hydrology'::hydra_singularity_type))" name="_qq_split_hydrology_singularity_singularity_type_check"/>
         <checkConstraint constraint="(((split1_type = 'pipe'::hydra_link_type) OR (split1_type = 'connector_hydrology'::hydra_link_type)))" name="_qq_split_hydrology_singularity_split1_type_check"/>
      </table>
      <table name="_regul_gate_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_regul_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_regul_gate_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_invert_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_ceiling_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="dt_regul_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_gate_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="z_control_node" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_regul_gate_link_z_control_node_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="z_pid_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="z_tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="q_z_crit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="q_tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="nr_z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="h_open" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="h_close" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_regul_gate_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'regul_gate'::hydra_link_type))" name="_regul_gate_link_link_type_check"/>
      </table>
      <table name="_regul_sluice_gate_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_regul_sluice_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_regul_sluice_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_invert_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_ceiling_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="dt_regul_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_gate_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="z_control_node" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_regul_sluice_gate_singularity_z_control_node_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="z_pid_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="z_tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="q_z_crit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="q_tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="nr_z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="h_open" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="h_close" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_regul_sluice_gate_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'regul_sluice_gate'::hydra_singularity_type))" name="_regul_sluice_gate_singularity_singularity_type_check"/>
      </table>
      <table name="_reservoir_rs_hydrology_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rs_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_reservoir_rs_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="drainage" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rs_hydrology_singularity_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="drainage_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_reservoir_rs_hydrology_singularity_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="overflow" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rs_hydrology_singularity_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="overflow_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_reservoir_rs_hydrology_singularity_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="q_drainage" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_ini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="treatment_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <index name="_reservoir_rs_hydrology_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="(((drainage_type = 'pipe'::hydra_link_type) OR (drainage_type = 'connector_hydrology'::hydra_link_type)))" name="_reservoir_rs_hydrology_singularity_drainage_type_check"/>
         <checkConstraint constraint="(((overflow_type = 'pipe'::hydra_link_type) OR (overflow_type = 'connector_hydrology'::hydra_link_type)))" name="_reservoir_rs_hydrology_singularity_overflow_type_check"/>
         <checkConstraint constraint="((singularity_type = 'reservoir_rs_hydrology'::hydra_singularity_type))" name="_reservoir_rs_hydrology_singularity_singularity_type_check"/>
      </table>
      <table name="_reservoir_rsp_hydrology_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rsp_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_reservoir_rsp_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="drainage" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rsp_hydrology_singularit_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="drainage_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_reservoir_rsp_hydrology_singularit_drainage_drainage_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="overflow" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_reservoir_rsp_hydrology_singularit_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="overflow_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_reservoir_rsp_hydrology_singularit_overflow_overflow_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="z_ini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="zr_sr_qf_qs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="treatment_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <index name="_reservoir_rsp_hydrology_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="(((drainage_type = 'pipe'::hydra_link_type) OR (drainage_type = 'connector_hydrology'::hydra_link_type)))" name="_reservoir_rsp_hydrology_singularity_drainage_type_check"/>
         <checkConstraint constraint="(((overflow_type = 'pipe'::hydra_link_type) OR (overflow_type = 'connector_hydrology'::hydra_link_type)))" name="_reservoir_rsp_hydrology_singularity_overflow_type_check"/>
         <checkConstraint constraint="((singularity_type = 'reservoir_rsp_hydrology'::hydra_singularity_type))" name="_reservoir_rsp_hydrology_singularity_singularity_type_check"/>
      </table>
      <table name="_river_cross_section_pl1d" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_pl1d_id_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="profile" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_pl1d_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="generation_step"/>
         </column>
         <index name="_river_cross_section_pl1d_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_river_cross_section_pl1d_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((st_npoints(profile) = 4) AND st_isvalid(profile)))" name="_river_cross_section_pl1d_profile_check"/>
      </table>
      <table name="_river_cross_section_profile" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_id_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'valley'::hydra_cross_section_type" digits="0" id="4" name="type_cross_section_up" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="'valley'::hydra_cross_section_type" digits="0" id="5" name="type_cross_section_down" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="up_rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="up_rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="up_sinuosity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="up_circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="up_ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="up_ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="up_ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="up_cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_up_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="closed_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="up_op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_up_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="open_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="up_vcs_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_up_vcs_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="valley_cross_section_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="up_vcs_topo_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_up_vcs_topo_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="valley_cross_section_topo_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="down_rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="down_rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="down_sinuosity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="down_circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="down_ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="down_ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="23" name="down_ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="down_cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_down_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="closed_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="down_op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_down_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="open_parametric_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="26" name="down_vcs_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_down_vcs_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="valley_cross_section_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="27" name="down_vcs_topo_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_cross_section_profile_down_vcs_topo_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="valley_cross_section_topo_geometry"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="29" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="30" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <index name="_river_cross_section_profile_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_river_cross_section_profile_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="_river_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="id" foreignKey="_river_cross_section_pl1d_id_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_pl1d"/>
            <child column="id" foreignKey="_river_cross_section_profile_id_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
            <parent column="id" foreignKey="_river_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_river_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="reach" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_river_node_reach_fkey" implied="false" onDeleteCascade="false" schema="model1" table="reach"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_river_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'river'::hydra_node_type))" name="_river_node_node_type_check"/>
      </table>
      <table name="_routing_hydrology_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_routing_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_routing_hydrology_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="cross_section" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="hydrograph" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_routing_hydrology_link_hydrograph_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrograph_bc_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="split_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_routing_hydrology_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'routing_hydrology'::hydra_link_type))" name="_routing_hydrology_link_link_type_check"/>
      </table>
      <table name="_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1._singularity_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="id" foreignKey="_air_flow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_air_flow_bc_singularity"/>
            <child column="id" foreignKey="_air_pressure_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_air_pressure_bc_singularity"/>
            <child column="id" foreignKey="_borda_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_borda_headloss_singularity"/>
            <child column="id" foreignKey="_bradley_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_bradley_headloss_singularity"/>
            <child column="id" foreignKey="_bridge_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_bridge_headloss_singularity"/>
            <child column="id" foreignKey="_constant_inflow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_constant_inflow_bc_singularity"/>
            <child column="id" foreignKey="_froude_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_froude_bc_singularity"/>
            <child column="id" foreignKey="_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_gate_singularity"/>
            <child column="id" foreignKey="_hydraulic_cut_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydraulic_cut_singularity"/>
            <child column="id" foreignKey="_hydrograph_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrograph_bc_singularity"/>
            <child column="id" foreignKey="_hydrology_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrology_bc_singularity"/>
            <child column="id" foreignKey="_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_marker_singularity"/>
            <child column="id" foreignKey="_model_connect_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_model_connect_bc_singularity"/>
            <child column="id" foreignKey="_param_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_param_headloss_singularity"/>
            <child column="id" foreignKey="_pipe_branch_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_pipe_branch_marker_singularity"/>
            <child column="id" foreignKey="_qq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="id" foreignKey="_regul_sluice_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_regul_sluice_gate_singularity"/>
            <child column="id" foreignKey="_reservoir_rs_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="id" foreignKey="_reservoir_rsp_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="id" foreignKey="_strickler_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_strickler_bc_singularity"/>
            <child column="id" foreignKey="_tank_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_tank_bc_singularity"/>
            <child column="id" foreignKey="_tz_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_tz_bc_singularity"/>
            <child column="id" foreignKey="_weir_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_weir_bc_singularity"/>
            <child column="id" foreignKey="_zq_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_bc_singularity"/>
            <child column="id" foreignKey="_zq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="id" foreignKey="_zregul_weir_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zregul_weir_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <child column="singularity_type" foreignKey="_air_flow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_air_flow_bc_singularity"/>
            <child column="singularity_type" foreignKey="_air_pressure_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_air_pressure_bc_singularity"/>
            <child column="singularity_type" foreignKey="_borda_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_borda_headloss_singularity"/>
            <child column="singularity_type" foreignKey="_bradley_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_bradley_headloss_singularity"/>
            <child column="singularity_type" foreignKey="_bridge_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_bridge_headloss_singularity"/>
            <child column="singularity_type" foreignKey="_constant_inflow_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_constant_inflow_bc_singularity"/>
            <child column="singularity_type" foreignKey="_froude_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_froude_bc_singularity"/>
            <child column="singularity_type" foreignKey="_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_gate_singularity"/>
            <child column="singularity_type" foreignKey="_hydraulic_cut_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydraulic_cut_singularity"/>
            <child column="singularity_type" foreignKey="_hydrograph_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrograph_bc_singularity"/>
            <child column="singularity_type" foreignKey="_hydrology_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_hydrology_bc_singularity"/>
            <child column="singularity_type" foreignKey="_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_marker_singularity"/>
            <child column="singularity_type" foreignKey="_model_connect_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_model_connect_bc_singularity"/>
            <child column="singularity_type" foreignKey="_param_headloss_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_param_headloss_singularity"/>
            <child column="singularity_type" foreignKey="_pipe_branch_marker_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_pipe_branch_marker_singularity"/>
            <child column="singularity_type" foreignKey="_qq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_qq_split_hydrology_singularity"/>
            <child column="singularity_type" foreignKey="_regul_sluice_gate_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_regul_sluice_gate_singularity"/>
            <child column="singularity_type" foreignKey="_reservoir_rs_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rs_hydrology_singularity"/>
            <child column="singularity_type" foreignKey="_reservoir_rsp_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_reservoir_rsp_hydrology_singularity"/>
            <child column="singularity_type" foreignKey="_strickler_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_strickler_bc_singularity"/>
            <child column="singularity_type" foreignKey="_tank_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_tank_bc_singularity"/>
            <child column="singularity_type" foreignKey="_tz_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_tz_bc_singularity"/>
            <child column="singularity_type" foreignKey="_weir_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_weir_bc_singularity"/>
            <child column="singularity_type" foreignKey="_zq_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_bc_singularity"/>
            <child column="singularity_type" foreignKey="_zq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zq_split_hydrology_singularity"/>
            <child column="singularity_type" foreignKey="_zregul_weir_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_zregul_weir_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="node" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_singularity_node_node_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_singularity_node_node_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="_singularity_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="_singularity_id_singularity_type_key" unique="true">
            <column ascending="true" name="id"/>
            <column ascending="true" name="singularity_type"/>
         </index>
         <index name="_singularity_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <index name="_singularity_node_key" unique="true">
            <column ascending="true" name="node"/>
         </index>
         <index name="model1_singularity_configuration_idx" unique="false"/>
         <index name="model1_singularity_name_idx" unique="false">
            <column ascending="true" name="name"/>
         </index>
         <index name="model1_singularity_validity_idx" unique="false">
            <column ascending="true" name="validity"/>
         </index>
         <checkConstraint constraint="((((singularity_type = 'air_flow_bc'::hydra_singularity_type) AND (node_type = 'station'::hydra_node_type)) OR ((singularity_type = 'air_pressure_bc'::hydra_singularity_type) AND (node_type = 'station'::hydra_node_type)) OR ((singularity_type = 'zq_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'zq_split_hydrology'::hydra_singularity_type) AND (node_type = 'manhole_hydrology'::hydra_node_type)) OR ((singularity_type = 'pipe_branch_marker'::hydra_singularity_type) AND (node_type = 'manhole'::hydra_node_type)) OR ((singularity_type = 'strickler_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'marker'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'model_connect_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'bradley_headloss'::hydra_singularity_type) AND (node_type = 'river'::hydra_node_type)) OR ((singularity_type = 'bridge_headloss'::hydra_singularity_type) AND (node_type = 'river'::hydra_node_type)) OR ((singularity_type = 'hydraulic_cut'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'reservoir_rsp_hydrology'::hydra_singularity_type) AND (node_type = 'manhole_hydrology'::hydra_node_type)) OR ((singularity_type = 'hydrograph_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'zregul_weir'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'qq_split_hydrology'::hydra_singularity_type) AND (node_type = 'manhole_hydrology'::hydra_node_type)) OR ((singularity_type = 'tank_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'reservoir_rs_hydrology'::hydra_singularity_type) AND (node_type = 'manhole_hydrology'::hydra_node_type)) OR ((singularity_type = 'param_headloss'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'froude_bc'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'tz_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'hydrology_bc'::hydra_singularity_type) AND (node_type = 'manhole_hydrology'::hydra_node_type)) OR ((singularity_type = 'regul_sluice_gate'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'gate'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'borda_headloss'::hydra_singularity_type) AND (node_type = ANY (ARRAY['river'::hydra_node_type, 'manhole'::hydra_node_type]))) OR ((singularity_type = 'constant_inflow_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type))) OR ((singularity_type = 'weir_bc'::hydra_singularity_type) AND ((node_type &lt;&gt; 'catchment'::hydra_node_type) AND (node_type &lt;&gt; 'manhole_hydrology'::hydra_node_type)))))" name="model1_singularity_connectivity_check_cstr"/>
      </table>
      <table name="_station_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_station_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_station_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="station" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_station_node_station_fkey" implied="false" onDeleteCascade="false" schema="model1" table="station"/>
         </column>
         <index name="_station_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'station'::hydra_node_type))" name="_station_node_node_type_check"/>
      </table>
      <table name="_storage_node" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_storage_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="node_type" nullable="false" remarks="" size="2147483647" type="hydra_node_type" typeCode="12">
            <parent column="node_type" foreignKey="_storage_node_id_node_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="contour" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_storage_node_contour_fkey" implied="false" onDeleteCascade="false" schema="model1" table="coverage"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_storage_node_contour_key" unique="true">
            <column ascending="true" name="contour"/>
         </index>
         <index name="_storage_node_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((node_type = 'storage'::hydra_node_type))" name="_storage_node_node_type_check"/>
      </table>
      <table name="_strickler_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_strickler_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_strickler_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="k" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_strickler_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'strickler_bc'::hydra_singularity_type))" name="_strickler_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_strickler_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_strickler_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_strickler_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_crest1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="z_crest2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="width2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <index name="_strickler_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'strickler'::hydra_link_type))" name="_strickler_link_link_type_check"/>
      </table>
      <table name="_tank_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_tank_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_tank_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="treatment_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <index name="_tank_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'tank_bc'::hydra_singularity_type))" name="_tank_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_tz_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_tz_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_tz_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="cyclic" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="external_file_data" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_tz_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'tz_bc'::hydra_singularity_type))" name="_tz_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_ventilator_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_ventilator_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_ventilator_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="q_dp_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="is_up_to_down" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_ventilator_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'ventilator'::hydra_link_type))" name="_ventilator_link_link_type_check"/>
      </table>
      <table name="_weir_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_weir_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_weir_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_weir" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_weir_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'weir_bc'::hydra_singularity_type))" name="_weir_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_weir_link" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_weir_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="link_type" nullable="false" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_weir_link_id_link_type_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="z_weir" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="v_max_cms" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <index name="_weir_link_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((link_type = 'weir'::hydra_link_type))" name="_weir_link_link_type_check"/>
      </table>
      <table name="_zq_bc_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zq_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_zq_bc_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <index name="_zq_bc_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'zq_bc'::hydra_singularity_type))" name="_zq_bc_singularity_singularity_type_check"/>
      </table>
      <table name="_zq_split_hydrology_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_zq_split_hydrology_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="downstream" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="downstream_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_zq_split_hydrology_singularity_downstream_downstream_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="split1" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="split1_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_zq_split_hydrology_singularity_split1_split1_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="split2" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="split2_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12">
            <parent column="link_type" foreignKey="_zq_split_hydrology_singularity_split2_split2_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="downstream_law" nullable="false" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="downstream_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="split1_law" nullable="true" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="split1_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="split2_law" nullable="true" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="split2_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <index name="_zq_split_hydrology_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="(((split2 IS NULL) OR (split2_type = 'pipe'::hydra_link_type) OR (split2_type = 'connector_hydrology'::hydra_link_type)))" name="_zq_split_hydrology_singularity_check"/>
         <checkConstraint constraint="(((downstream_type = 'pipe'::hydra_link_type) OR (downstream_type = 'connector_hydrology'::hydra_link_type)))" name="_zq_split_hydrology_singularity_downstream_type_check"/>
         <checkConstraint constraint="((singularity_type = 'zq_split_hydrology'::hydra_singularity_type))" name="_zq_split_hydrology_singularity_singularity_type_check"/>
         <checkConstraint constraint="(((split1_type = 'pipe'::hydra_link_type) OR (split1_type = 'connector_hydrology'::hydra_link_type)))" name="_zq_split_hydrology_singularity_split1_type_check"/>
      </table>
      <table name="_zregul_weir_singularity" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="_zregul_weir_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="singularity_type" nullable="false" remarks="" size="2147483647" type="hydra_singularity_type" typeCode="12">
            <parent column="singularity_type" foreignKey="_zregul_weir_singularity_id_singularity_type_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_singularity"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_regul" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_weir_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="reoxy_law" nullable="true" remarks="" size="2147483647" type="hydra_weir_mode_reoxy" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="reoxy_param" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="_zregul_weir_singularity_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((singularity_type = 'zregul_weir'::hydra_singularity_type))" name="_zregul_weir_singularity_singularity_type_check"/>
      </table>
      <table name="air_duct_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert_up,&#10;    c.z_invert_down,&#10;    c.area,&#10;    c.perimeter,&#10;    c.friction_coefficient,&#10;    c.custom_length,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._air_duct_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="perimeter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="friction_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="custom_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="air_flow_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.flow,&#10;    c.is_inwards,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._air_flow_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="flow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="is_inwards" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="air_headloss_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.area,&#10;    c.up_to_down_headloss_coefficient,&#10;    c.down_to_up_headloss_coefficient,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._air_headloss_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="up_to_down_headloss_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="down_to_up_headloss_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="air_pressure_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.relative_pressure,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._air_pressure_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="relative_pressure" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="bank" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.bank_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="project.unique_name('BANK_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="bank_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="bank_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="borda_headloss_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.law_type,&#10;    (c.param)::character varying AS param,&#10;    c.param AS param_json,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._borda_headloss_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="law_type" nullable="true" remarks="" size="2147483647" type="hydra_borda_headloss_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="borda_headloss_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.law_type,&#10;    (c.param)::character varying AS param,&#10;    c.full_section_discharge_for_headloss,&#10;    c.param AS param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._borda_headloss_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="law_type" nullable="true" remarks="" size="2147483647" type="hydra_borda_headloss_singularity_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="bradley_headloss_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.d_abutment_l,&#10;    c.d_abutment_r,&#10;    c.abutment_type,&#10;    c.zw_array,&#10;    c.z_ceiling,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._bradley_headloss_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="d_abutment_l" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="d_abutment_r" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="abutment_type" nullable="true" remarks="" size="2147483647" type="hydra_abutment_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="zw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="branch" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <child column="branch" foreignKey="_pipe_link_branch_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_pipe_link"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="8" id="2" name="pk0_km" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="50" digits="8" id="3" name="dx" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="branch_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="branch_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="branch_geom_check"/>
      </table>
      <table name="bridge_headloss_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.l_road,&#10;    c.z_road,&#10;    c.zw_array,&#10;    c.full_section_discharge_for_headloss,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._bridge_headloss_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="l_road" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_road" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="zw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="catchment" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.catchment_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="contour" foreignKey="_catchment_node_contour_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_catchment_node"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('CATCHMENT_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="catchment_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="catchment_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="catchment_geom_check"/>
      </table>
      <table name="catchment_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area_ha,&#10;    c.rl,&#10;    c.slope,&#10;    c.c_imp,&#10;    c.netflow_type,&#10;    c.constant_runoff,&#10;    c.horner_ini_loss_coef,&#10;    c.horner_recharge_coef,&#10;    c.holtan_sat_inf_rate_mmh,&#10;    c.holtan_dry_inf_rate_mmh,&#10;    c.holtan_soil_storage_cap_mm,&#10;    c.scs_j_mm,&#10;    c.scs_soil_drainage_time_day,&#10;    c.scs_rfu_mm,&#10;    c.hydra_surface_soil_storage_rfu_mm,&#10;    c.hydra_inf_rate_f0_mm_hr,&#10;    c.hydra_int_soil_storage_j_mm,&#10;    c.hydra_soil_drainage_time_qres_day,&#10;    c.hydra_split_coefficient,&#10;    c.hydra_catchment_connect_coef,&#10;    c.hydra_aquifer_infiltration_rate,&#10;    c.hydra_soil_infiltration_type,&#10;    c.gr4_k1,&#10;    c.gr4_k2,&#10;    c.gr4_k3,&#10;    c.gr4_k4,&#10;    c.runoff_type,&#10;    c.socose_tc_mn,&#10;    c.socose_shape_param_beta,&#10;    c.define_k_mn,&#10;    c.q_limit,&#10;    c.q0,&#10;    c.contour,&#10;    c.network_type,&#10;    c.rural_land_use,&#10;    c.industrial_land_use,&#10;    c.suburban_housing_land_use,&#10;    c.dense_housing_land_use,&#10;        CASE&#10;            WHEN (c.runoff_type = 'Define K'::hydra_runoff_type) THEN (c.define_k_mn)::double precision&#10;            WHEN (c.runoff_type = ANY (ARRAY['Desbordes 1 Cr'::hydra_runoff_type, 'Desbordes 1 Cimp'::hydra_runoff_type, 'Desbordes 2 Cimp'::hydra_runoff_type, 'Krajewski'::hydra_runoff_type])) THEN project.define_k_mn(c.runoff_type, c.area_ha, c.rl, c.slope, c.c_imp, c.constant_runoff)&#10;            ELSE NULL::double precision&#10;        END AS _k_mn,&#10;        CASE&#10;            WHEN (c.runoff_type = 'Define Tc'::hydra_runoff_type) THEN (c.socose_tc_mn)::double precision&#10;            WHEN (c.runoff_type = ANY (ARRAY['Passini'::hydra_runoff_type, 'Giandotti'::hydra_runoff_type, 'Turraza'::hydra_runoff_type, 'Ventura'::hydra_runoff_type, 'Kirpich'::hydra_runoff_type, 'Cemagref'::hydra_runoff_type, 'Mockus'::hydra_runoff_type])) THEN project.socose_tc_mn(c.runoff_type, c.area_ha, c.rl, c.slope, c.c_imp,&#10;            CASE&#10;                WHEN (c.netflow_type = 'hydra'::hydra_netflow_type) THEN c.hydra_surface_soil_storage_rfu_mm&#10;                WHEN (c.netflow_type = 'scs'::hydra_netflow_type) THEN c.scs_rfu_mm&#10;                ELSE NULL::real&#10;            END)&#10;            ELSE NULL::double precision&#10;        END AS _tc_mn,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._catchment_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area_ha" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="rl" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="c_imp" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="netflow_type" nullable="true" remarks="" size="2147483647" type="hydra_netflow_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="constant_runoff" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="horner_ini_loss_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="horner_recharge_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="holtan_sat_inf_rate_mmh" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="holtan_dry_inf_rate_mmh" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="holtan_soil_storage_cap_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="scs_j_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="scs_soil_drainage_time_day" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="scs_rfu_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="hydra_surface_soil_storage_rfu_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="hydra_inf_rate_f0_mm_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="hydra_int_soil_storage_j_mm" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="hydra_soil_drainage_time_qres_day" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="hydra_split_coefficient" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="hydra_catchment_connect_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="hydra_aquifer_infiltration_rate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="hydra_soil_infiltration_type" nullable="true" remarks="" size="2147483647" type="hydra_soil_infiltration_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="24" name="gr4_k1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="25" name="gr4_k2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="26" name="gr4_k3" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="27" name="gr4_k4" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="runoff_type" nullable="true" remarks="" size="2147483647" type="hydra_runoff_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="29" name="socose_tc_mn" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="30" name="socose_shape_param_beta" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="31" name="define_k_mn" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="32" name="q_limit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="33" name="q0" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="34" name="contour" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="35" name="network_type" nullable="true" remarks="" size="2147483647" type="hydra_network_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="36" name="rural_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="37" name="industrial_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="38" name="suburban_housing_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="39" name="dense_housing_land_use" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="40" name="_k_mn" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="41" name="_tc_mn" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="42" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="43" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="44" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="45" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="46" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="47" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="channel_reach" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH ends AS (&#10;         SELECT p.id,&#10;            p.geom,&#10;            'down'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up = 'channel'::hydra_cross_section_type) AND (p.type_cross_section_down &lt;&gt; 'channel'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'up'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up &lt;&gt; 'channel'::hydra_cross_section_type) AND (p.type_cross_section_down = 'channel'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'down'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up = 'channel'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision) AND st_dwithin(p.geom, st_endpoint(r_1.geom), (1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'up'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_down = 'channel'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision) AND st_dwithin(p.geom, st_startpoint(r_1.geom), (1)::double precision))&#10;        ), bounds AS (&#10;         SELECT first_value(ends.reach) OVER (PARTITION BY ends.reach ORDER BY ends.alpha) AS first_value,&#10;            ends.typ,&#10;            lag(ends.alpha) OVER (PARTITION BY ends.reach ORDER BY ends.alpha) AS start,&#10;            ends.alpha AS &quot;end&quot;,&#10;            ends.id,&#10;            ends.reach&#10;           FROM ends&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    st_linesubstring(r.geom, b.start, b.&quot;end&quot;) AS geom,&#10;    r.id AS reach&#10;   FROM (bounds b&#10;     JOIN model1.reach r ON ((r.id = b.reach)))&#10;  WHERE (b.typ = 'down'::text);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="reach" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
      </table>
      <table name="close_point" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH allpoints AS (&#10;         SELECT constrain.id,&#10;            (st_dumppoints(constrain.geom)).geom AS geom&#10;           FROM model1.constrain&#10;          WHERE (constrain.constrain_type IS DISTINCT FROM 'ignored_for_coverages'::hydra_constrain_type)&#10;        ), ends AS (&#10;         SELECT constrain.id,&#10;            st_startpoint(constrain.geom) AS geom&#10;           FROM model1.constrain&#10;          WHERE (constrain.constrain_type IS DISTINCT FROM 'ignored_for_coverages'::hydra_constrain_type)&#10;        UNION&#10;         SELECT constrain.id,&#10;            st_endpoint(constrain.geom) AS geom&#10;           FROM model1.constrain&#10;          WHERE (constrain.constrain_type IS DISTINCT FROM 'ignored_for_coverages'::hydra_constrain_type)&#10;        ), cpoints AS (&#10;         SELECT allpoints.id,&#10;            st_collect(allpoints.geom) AS geom&#10;           FROM allpoints&#10;          GROUP BY allpoints.id&#10;        ), clust AS (&#10;         SELECT sqrt((st_area(st_minimumboundingcircle(f.gc)) / pi())) AS radius,&#10;            st_numgeometries(f.gc) AS nb,&#10;            st_centroid(f.gc) AS geom&#10;           FROM ( SELECT unnest(st_clusterwithin(allpoints.geom, (5)::double precision)) AS gc&#10;                   FROM allpoints) f&#10;        UNION&#10;         SELECT 1 AS radius,&#10;            0 AS nb,&#10;            st_force2d(e.geom) AS geom&#10;           FROM model1.constrain c,&#10;            cpoints cp,&#10;            ends e&#10;          WHERE (st_dwithin(c.geom, e.geom, (1)::double precision) AND (NOT st_intersects(cp.geom, e.geom)) AND (e.id &lt;&gt; c.id) AND (c.id = cp.id) AND (c.constrain_type IS DISTINCT FROM 'ignored_for_coverages'::hydra_constrain_type))&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    clust.radius,&#10;    clust.nb,&#10;    (clust.geom)::geometry(Point,2154) AS geom&#10;   FROM clust&#10;  WHERE (clust.radius &gt; (0)::double precision);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="1" name="radius" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="nb" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="closed_parametric_geometry" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.closed_parametric_geometry_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="cp_geom" foreignKey="_pipe_link_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_pipe_link"/>
            <child column="down_cp_geom" foreignKey="_river_cross_section_profile_down_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
            <child column="up_cp_geom" foreignKey="_river_cross_section_profile_up_cp_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('CP_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zbmin_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="closed_parametric_geometry_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="closed_parametric_geometry_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((array_length(zbmin_array, 1) &lt;= 20) AND (array_length(zbmin_array, 1) &gt;= 1) AND (array_length(zbmin_array, 2) = 2)))" name="closed_parametric_geometry_zbmin_array_check"/>
      </table>
      <table name="config_switch" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="1" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="1" name="is_switching" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="config_switch_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((id = 1))" name="config_switch_id_check"/>
      </table>
      <table name="configuration" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.configuration_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="configuration" foreignKey="metadata_configuration_fkey" implied="false" onDeleteCascade="false" schema="model1" table="metadata"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('CFG_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="description" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="configuration_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="configuration_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="configured" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT concat('node:', n.id) AS id,&#10;    n.configuration,&#10;    n.name,&#10;    'node'::character varying AS type,&#10;    (n.node_type)::character varying AS subtype,&#10;    n.geom&#10;   FROM model1._node n&#10;  WHERE (n.configuration IS NOT NULL)&#10;UNION ALL&#10; SELECT concat('link:', l.id) AS id,&#10;    l.configuration,&#10;    l.name,&#10;    'link'::character varying AS type,&#10;    (l.link_type)::character varying AS subtype,&#10;    (st_force3d(st_centroid(l.geom)))::geometry(PointZ,2154) AS geom&#10;   FROM model1._link l&#10;  WHERE (l.configuration IS NOT NULL)&#10;UNION ALL&#10; SELECT concat('singularity:', s.id) AS id,&#10;    s.configuration,&#10;    s.name,&#10;    'singularity'::character varying AS type,&#10;    (s.singularity_type)::character varying AS subtype,&#10;    n.geom&#10;   FROM (model1._singularity s&#10;     JOIN model1._node n ON ((s.node = n.id)))&#10;  WHERE (s.configuration IS NOT NULL)&#10;UNION ALL&#10; SELECT concat('river_cross_section_profile:', p.id) AS id,&#10;    p.configuration,&#10;    p.name,&#10;    'profile'::character varying AS type,&#10;    'river_cross_section'::character varying AS subtype,&#10;    n.geom&#10;   FROM (model1._river_cross_section_profile p&#10;     JOIN model1._node n ON ((p.id = n.id)))&#10;  WHERE (p.configuration IS NOT NULL);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="subtype" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="configured_current" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH config AS (&#10;         SELECT c.name&#10;           FROM model1.configuration c,&#10;            model1.metadata m&#10;          WHERE (m.configuration = c.id)&#10;        )&#10; SELECT concat('node:', n.id) AS id,&#10;    n.configuration,&#10;    n.name,&#10;    'node'::character varying AS type,&#10;    (n.node_type)::character varying AS subtype,&#10;    n.geom&#10;   FROM model1._node n,&#10;    config c&#10;  WHERE ((EXISTS ( SELECT 1&#10;           FROM json_object_keys(n.configuration) json_object_keys(json_object_keys)&#10;          WHERE (json_object_keys.json_object_keys = (c.name)::text)&#10;         LIMIT 1)) AND ((c.name)::text &lt;&gt; 'default'::text))&#10;UNION ALL&#10; SELECT concat('link:', l.id) AS id,&#10;    l.configuration,&#10;    l.name,&#10;    'link'::character varying AS type,&#10;    (l.link_type)::character varying AS subtype,&#10;    (st_force3d(st_centroid(l.geom)))::geometry(PointZ,2154) AS geom&#10;   FROM model1._link l,&#10;    config c&#10;  WHERE ((EXISTS ( SELECT 1&#10;           FROM json_object_keys(l.configuration) json_object_keys(json_object_keys)&#10;          WHERE (json_object_keys.json_object_keys = (c.name)::text)&#10;         LIMIT 1)) AND ((c.name)::text &lt;&gt; 'default'::text))&#10;UNION ALL&#10; SELECT concat('singularity:', s.id) AS id,&#10;    s.configuration,&#10;    s.name,&#10;    'singularity'::character varying AS type,&#10;    (s.singularity_type)::character varying AS subtype,&#10;    n.geom&#10;   FROM config c,&#10;    (model1._singularity s&#10;     JOIN model1._node n ON ((s.node = n.id)))&#10;  WHERE ((EXISTS ( SELECT 1&#10;           FROM json_object_keys(s.configuration) json_object_keys(json_object_keys)&#10;          WHERE (json_object_keys.json_object_keys = (c.name)::text)&#10;         LIMIT 1)) AND ((c.name)::text &lt;&gt; 'default'::text))&#10;UNION ALL&#10; SELECT concat('river_cross_section_profile:', p.id) AS id,&#10;    p.configuration,&#10;    p.name,&#10;    'profile'::character varying AS type,&#10;    'river_cross_section'::character varying AS subtype,&#10;    n.geom&#10;   FROM config c,&#10;    (model1._river_cross_section_profile p&#10;     JOIN model1._node n ON ((p.id = n.id)))&#10;  WHERE ((EXISTS ( SELECT 1&#10;           FROM json_object_keys(p.configuration) json_object_keys(json_object_keys)&#10;          WHERE (json_object_keys.json_object_keys = (c.name)::text)&#10;         LIMIT 1)) AND ((c.name)::text &lt;&gt; 'default'::text));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="subtype" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="connector_hydrology_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.hydrograph,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._connector_hydrology_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="hydrograph" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="connector_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.main_branch,&#10;    c.border,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._connector_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="main_branch" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="constant_inflow_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.q0,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._constant_inflow_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="q0" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="constrain" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT c.id,&#10;    c.name,&#10;    c.geom,&#10;    c.discretized,&#10;    c.elem_length,&#10;    c.constrain_type,&#10;    c.link_attributes,&#10;    c.points_xyz,&#10;    c.points_xyz_proximity,&#10;    (EXISTS ( SELECT 1&#10;           FROM project.points_xyz points&#10;          WHERE ((c.points_xyz = points.points_id) AND st_dwithin(points.geom, c.geom, (c.points_xyz_proximity)::double precision)))) AS _is_3d,&#10;    c.line_xyz,&#10;    l.geom AS topo,&#10;    c.comment&#10;   FROM (model1._constrain c&#10;     LEFT JOIN project.line_xyz l ON ((l.id = c.line_xyz)));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="discretized" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="elem_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="constrain_type" nullable="true" remarks="" size="2147483647" type="hydra_constrain_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="link_attributes" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="points_xyz" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="points_xyz_proximity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="_is_3d" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="line_xyz" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="topo" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="constrain_3d" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH projected AS (&#10;         SELECT c.id,&#10;            st_linelocatepoint(c.geom, p.geom) AS loc,&#10;            c.geom,&#10;            st_distance(c.geom, p.geom) AS dist,&#10;            p.z_ground AS z&#10;           FROM (model1._constrain c&#10;             JOIN project.points_xyz p ON ((st_dwithin(p.geom, c.geom, (c.points_xyz_proximity)::double precision) AND (c.points_xyz = p.points_id))))&#10;        ), distinct_projected AS (&#10;         SELECT DISTINCT ON (projected.loc) projected.id,&#10;            st_lineinterpolatepoint(projected.geom, projected.loc) AS geom,&#10;            projected.loc,&#10;            projected.z&#10;           FROM projected&#10;          ORDER BY projected.loc, projected.dist&#10;        ), all_points AS (&#10;         SELECT c.id,&#10;            d.geom,&#10;            st_linelocatepoint(c.geom, d.geom) AS loc,&#10;            NULL::real AS z&#10;           FROM (model1._constrain c&#10;             CROSS JOIN LATERAL st_dumppoints(c.geom) d(path, geom))&#10;          WHERE (c.id IN ( SELECT DISTINCT projected.id&#10;                   FROM projected))&#10;        UNION ALL&#10;         SELECT distinct_projected.id,&#10;            distinct_projected.geom,&#10;            distinct_projected.loc,&#10;            distinct_projected.z&#10;           FROM distinct_projected&#10;        ), lz AS (&#10;         SELECT distinct_projected.id,&#10;            array_agg(ARRAY[distinct_projected.loc, (distinct_projected.z)::double precision]) AS a&#10;           FROM distinct_projected&#10;          WHERE (distinct_projected.z IS NOT NULL)&#10;          GROUP BY distinct_projected.id&#10;        )&#10; SELECT i.id,&#10;    st_setsrid(st_makeline(st_makepoint(st_x(i.geom), st_y(i.geom), (COALESCE(i.z, project.interpolate_z(i.loc, lz.a)))::double precision) ORDER BY i.loc), 2154) AS geom&#10;   FROM (all_points i&#10;     JOIN lz ON ((lz.id = i.id)))&#10;  GROUP BY i.id;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="coted_point" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH transect_start AS (&#10;         SELECT model1.section_interpolate_point(t.geom, t.section, (0)::real, (t.side)::character varying) AS geom&#10;           FROM model1.flood_plain_bluff_point_transect t&#10;        ), contour_point AS (&#10;         SELECT (st_dumppoints(st_exteriorring(flood_plain.geom))).geom AS geom&#10;           FROM model1.flood_plain&#10;        ), missing_tr AS (&#10;         SELECT (st_dumppoints(st_difference(ct.geom, trc.geom))).geom AS geom&#10;           FROM ( SELECT st_collect(contour_point.geom) AS geom&#10;                   FROM contour_point) ct,&#10;            ( SELECT st_collect(transect_start.geom) AS geom&#10;                   FROM transect_start) trc&#10;        ), pt AS (&#10;         SELECT (st_dumppoints(flood_plain_flow_line.geom)).geom AS geom&#10;           FROM model1.flood_plain_flow_line&#10;        UNION ALL&#10;         SELECT (st_dumppoints(reach_flow_line.geom)).geom AS geom&#10;           FROM model1.reach_flow_line&#10;        UNION ALL&#10;         SELECT transect_start.geom&#10;           FROM transect_start&#10;        UNION ALL&#10;         SELECT model1.set_reach_point_altitude(missing_tr.geom) AS set_reach_point_altitude&#10;           FROM missing_tr&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    pt.geom&#10;   FROM pt;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="coted_point_with_interp" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH easy AS (&#10;         SELECT DISTINCT ON (cp.id) cp.id,&#10;            cp.geom,&#10;            ft.reach,&#10;            ft.reach_rel_abs&#10;           FROM (model1.coted_point cp&#10;             JOIN model1.flood_plain_bluff_point_transect ft ON (st_dwithin(cp.geom, ft.geom, (0.1)::double precision)))&#10;        ), hard AS (&#10;         SELECT coted_point.id,&#10;            coted_point.geom&#10;           FROM model1.coted_point&#10;        EXCEPT&#10;         SELECT easy.id,&#10;            easy.geom&#10;           FROM easy&#10;        ), hard_section AS (&#10;         SELECT hard.id,&#10;            hard.geom,&#10;            model1.interpolate_transect_at(hard.geom) AS transect&#10;           FROM hard&#10;        ), interp AS (&#10;         SELECT easy.id,&#10;            easy.geom,&#10;            easy.reach,&#10;            easy.reach_rel_abs&#10;           FROM easy&#10;        UNION ALL&#10;         SELECT DISTINCT ON (h.id) h.id,&#10;            h.geom,&#10;            r.id AS reach,&#10;            st_linelocatepoint(r.geom, st_closestpoint(r.geom, h.transect)) AS reach_rel_abs&#10;           FROM (hard_section h&#10;             JOIN model1.reach r ON (st_intersects(r.geom, st_buffer(h.transect, (0.01)::double precision))))&#10;        ), reach_segment AS (&#10;         SELECT n.reach,&#10;            n.id AS nd,&#10;            st_linelocatepoint(r.geom, n.geom) AS reach_rel_abs_nd,&#10;            lag(n.id) OVER (w) AS strt,&#10;            lag(st_linelocatepoint(r.geom, n.geom)) OVER (w) AS reach_rel_abs_strt,&#10;            n.geom AS nd_geom,&#10;            lag(n.geom) OVER (w) AS strt_geom&#10;           FROM (model1.river_node n&#10;             JOIN model1.reach r ON ((r.id = n.reach)))&#10;          WINDOW w AS (PARTITION BY n.reach ORDER BY (st_linelocatepoint(r.geom, n.geom)))&#10;        )&#10; SELECT DISTINCT ON (i.id) i.id,&#10;    i.geom,&#10;    s.strt,&#10;    s.nd,&#10;    s.reach_rel_abs_strt,&#10;    i.reach_rel_abs,&#10;    s.reach_rel_abs_nd,&#10;    st_makeline(ARRAY[s.strt_geom, i.geom, s.nd_geom]) AS lnk,&#10;    (('1'::numeric)::double precision - ((i.reach_rel_abs - s.reach_rel_abs_strt) / (s.reach_rel_abs_nd - s.reach_rel_abs_strt))) AS weight_strt,&#10;    ((i.reach_rel_abs - s.reach_rel_abs_strt) / (s.reach_rel_abs_nd - s.reach_rel_abs_strt)) AS weight_nd&#10;   FROM (interp i&#10;     JOIN reach_segment s ON (((s.reach = i.reach) AND (s.reach_rel_abs_strt &lt;= i.reach_rel_abs) AND (s.reach_rel_abs_nd &gt;= i.reach_rel_abs))));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="strt" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="nd" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="4" name="reach_rel_abs_strt" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="reach_rel_abs" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="6" name="reach_rel_abs_nd" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="lnk" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="8" name="weight_strt" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="9" name="weight_nd" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
      </table>
      <table name="coverage" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.coverage_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="contour" foreignKey="_storage_node_contour_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_storage_node"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="domain_type" nullable="true" remarks="" size="2147483647" type="hydra_coverage_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="coverage_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="model1_coverage_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="coverage_geom_check"/>
      </table>
      <table name="coverage_marker" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.coverage_marker_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="project.unique_name('COV_NULL_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="3" name="protected" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="coverage_marker_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="coverage_marker_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="crossroad_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area,&#10;    c.z_ground,&#10;    c.h,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._crossroad_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="h" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="deriv_pump_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.q_pump,&#10;    c.qz_array,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._deriv_pump_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="q_pump" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="qz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="domain_2d" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.domain_2d_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="domain_2d" foreignKey="_elem_2d_node_domain_2d_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_elem_2d_node"/>
            <child column="domain_2d" foreignKey="domain_2d_marker_domain_2d_fkey" implied="false" onDeleteCascade="false" schema="model1" table="domain_2d_marker"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('DOMAIN_2D_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="domain_2d_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="domain_2d_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((name)::text &lt;&gt; 'default_domain'::text))" name="domain_2d_name_check"/>
      </table>
      <table name="domain_2d_marker" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.domain_2d_marker_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="project.unique_name('DOMAIN_MARKER_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="domain_2d" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="domain_2d_marker_domain_2d_fkey" implied="false" onDeleteCascade="false" schema="model1" table="domain_2d"/>
         </column>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="domain_2d_marker_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="domain_2d_marker_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="elem_2d_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area,&#10;    c.zb,&#10;    c.rk,&#10;    c.domain_2d,&#10;    c.contour,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._elem_2d_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zb" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="domain_2d" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="contour" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="flood_plain" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT row_number() OVER () AS id,&#10;    t.geom&#10;   FROM ( SELECT (st_dump(st_union(coverage.geom))).geom AS geom&#10;           FROM model1.coverage&#10;          WHERE (coverage.domain_type = 'reach'::hydra_coverage_type)) t;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="flood_plain_bluff" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH bluff AS (&#10;         SELECT st_linemerge(st_difference(st_exteriorring(c.geom), st_collect(t_1.discretized))) AS geom&#10;           FROM (model1.flood_plain c&#10;             JOIN model1.constrain t_1 ON (st_intersects(c.geom, t_1.discretized)))&#10;          WHERE (t_1.constrain_type = 'flood_plain_transect'::hydra_constrain_type)&#10;          GROUP BY c.id, c.geom&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    t.geom&#10;   FROM ( SELECT (st_dump(bluff.geom)).geom AS geom&#10;           FROM bluff) t;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="flood_plain_bluff_point" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT row_number() OVER () AS id,&#10;    (t.d).geom AS geom,&#10;    (t.d).path AS path,&#10;    t.id AS bluff&#10;   FROM ( SELECT flood_plain_bluff.id,&#10;            st_dumppoints(flood_plain_bluff.geom) AS d,&#10;            st_numpoints(flood_plain_bluff.geom) AS n&#10;           FROM model1.flood_plain_bluff) t&#10;  WHERE (((t.d).path[1] &lt;&gt; 1) AND ((t.d).path[1] &lt;&gt; t.n));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="path" nullable="true" remarks="" size="10" type="_int4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="bluff" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
      </table>
      <table name="flood_plain_bluff_point_transect" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH fp AS (&#10;         SELECT flood_plain_bluff_point.id,&#10;            flood_plain_bluff_point.bluff,&#10;            model1.interpolate_transect_at(flood_plain_bluff_point.geom) AS geom,&#10;            flood_plain_bluff_point.geom AS pt&#10;           FROM model1.flood_plain_bluff_point&#10;        ), valley_section AS (&#10;         SELECT model1.valley_section_at(st_pointn(fp_1.geom, 2)) AS section,&#10;            fp_1.id&#10;           FROM fp fp_1&#10;        )&#10; SELECT fp.id,&#10;    fp.bluff,&#10;    fp.geom,&#10;    (valley_section.section).section AS section,&#10;    (valley_section.section).frac_maj_l AS frac_maj_l,&#10;    (valley_section.section).frac_min AS frac_min,&#10;    (valley_section.section).frac_maj_r AS frac_maj_r,&#10;        CASE&#10;            WHEN st_intersects(fp.pt, st_startpoint(fp.geom)) THEN 'left'::text&#10;            ELSE 'right'::text&#10;        END AS side,&#10;    r.id AS reach,&#10;    st_linelocatepoint(r.geom, st_pointn(fp.geom, 2)) AS reach_rel_abs&#10;   FROM ((fp&#10;     JOIN model1.reach r ON (st_dwithin(r.geom, st_pointn(fp.geom, 2), (0.1)::double precision)))&#10;     JOIN valley_section ON ((fp.id = valley_section.id)))&#10;  WHERE (st_numpoints(fp.geom) = 3);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="bluff" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="section" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="frac_maj_l" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="frac_min" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="frac_maj_r" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="side" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="reach" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="9" name="reach_rel_abs" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
      </table>
      <table name="flood_plain_flow_line" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH line AS (&#10;         SELECT b.id,&#10;            1 AS ord,&#10;            st_makeline(ARRAY( SELECT model1.section_interpolate_point(t_1.geom, t_1.section,&#10;                        CASE&#10;                            WHEN (t_1.side = 'right'::text) THEN (((0.2)::double precision * (t_1.frac_maj_r / (t_1.frac_maj_r + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                            ELSE (((0.2)::double precision * (t_1.frac_maj_l / (t_1.frac_maj_l + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                        END, (t_1.side)::character varying) AS section_interpolate_point&#10;                   FROM model1.flood_plain_bluff_point_transect t_1&#10;                  WHERE (t_1.bluff = b.id)&#10;                  ORDER BY (st_linelocatepoint(b.geom,&#10;                        CASE&#10;                            WHEN (t_1.side = 'left'::text) THEN st_startpoint(t_1.geom)&#10;                            ELSE st_endpoint(t_1.geom)&#10;                        END)))) AS geom&#10;           FROM model1.flood_plain_bluff b&#10;        UNION ALL&#10;         SELECT b.id,&#10;            2 AS ord,&#10;            st_makeline(ARRAY( SELECT model1.section_interpolate_point(t_1.geom, t_1.section,&#10;                        CASE&#10;                            WHEN (t_1.side = 'right'::text) THEN (((0.4)::double precision * (t_1.frac_maj_r / (t_1.frac_maj_r + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                            ELSE (((0.4)::double precision * (t_1.frac_maj_l / (t_1.frac_maj_l + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                        END, (t_1.side)::character varying) AS section_interpolate_point&#10;                   FROM model1.flood_plain_bluff_point_transect t_1&#10;                  WHERE (t_1.bluff = b.id)&#10;                  ORDER BY (st_linelocatepoint(b.geom,&#10;                        CASE&#10;                            WHEN (t_1.side = 'left'::text) THEN st_startpoint(t_1.geom)&#10;                            ELSE st_endpoint(t_1.geom)&#10;                        END)))) AS geom&#10;           FROM model1.flood_plain_bluff b&#10;        UNION ALL&#10;         SELECT b.id,&#10;            3 AS ord,&#10;            st_makeline(ARRAY( SELECT model1.section_interpolate_point(t_1.geom, t_1.section,&#10;                        CASE&#10;                            WHEN (t_1.side = 'right'::text) THEN (((0.6)::double precision * (t_1.frac_maj_r / (t_1.frac_maj_r + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                            ELSE (((0.6)::double precision * (t_1.frac_maj_l / (t_1.frac_maj_l + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                        END, (t_1.side)::character varying) AS section_interpolate_point&#10;                   FROM model1.flood_plain_bluff_point_transect t_1&#10;                  WHERE (t_1.bluff = b.id)&#10;                  ORDER BY (st_linelocatepoint(b.geom,&#10;                        CASE&#10;                            WHEN (t_1.side = 'left'::text) THEN st_startpoint(t_1.geom)&#10;                            ELSE st_endpoint(t_1.geom)&#10;                        END)))) AS geom&#10;           FROM model1.flood_plain_bluff b&#10;        UNION ALL&#10;         SELECT b.id,&#10;            4 AS ord,&#10;            st_makeline(ARRAY( SELECT model1.section_interpolate_point(t_1.geom, t_1.section,&#10;                        CASE&#10;                            WHEN (t_1.side = 'right'::text) THEN (((0.8)::double precision * (t_1.frac_maj_r / (t_1.frac_maj_r + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                            ELSE (((0.8)::double precision * (t_1.frac_maj_l / (t_1.frac_maj_l + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                        END, (t_1.side)::character varying) AS section_interpolate_point&#10;                   FROM model1.flood_plain_bluff_point_transect t_1&#10;                  WHERE (t_1.bluff = b.id)&#10;                  ORDER BY (st_linelocatepoint(b.geom,&#10;                        CASE&#10;                            WHEN (t_1.side = 'left'::text) THEN st_startpoint(t_1.geom)&#10;                            ELSE st_endpoint(t_1.geom)&#10;                        END)))) AS geom&#10;           FROM model1.flood_plain_bluff b&#10;        UNION ALL&#10;         SELECT b.id,&#10;            5 AS ord,&#10;            st_makeline(ARRAY( SELECT model1.section_interpolate_point(t_1.geom, t_1.section,&#10;                        CASE&#10;                            WHEN (t_1.side = 'right'::text) THEN (((1.0)::double precision * (t_1.frac_maj_r / (t_1.frac_maj_r + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                            ELSE (((1.0)::double precision * (t_1.frac_maj_l / (t_1.frac_maj_l + ((0.5)::double precision * t_1.frac_min)))))::real&#10;                        END, (t_1.side)::character varying) AS section_interpolate_point&#10;                   FROM model1.flood_plain_bluff_point_transect t_1&#10;                  WHERE (t_1.bluff = b.id)&#10;                  ORDER BY (st_linelocatepoint(b.geom,&#10;                        CASE&#10;                            WHEN (t_1.side = 'left'::text) THEN st_startpoint(t_1.geom)&#10;                            ELSE st_endpoint(t_1.geom)&#10;                        END)))) AS geom&#10;           FROM model1.flood_plain_bluff b&#10;        ), segment AS (&#10;         SELECT st_makeline(lag((dumps.pt).geom, 1, NULL::geometry) OVER (PARTITION BY dumps.id, dumps.ord ORDER BY dumps.id, (dumps.pt).path), (dumps.pt).geom) AS geom&#10;           FROM ( SELECT line.id,&#10;                    line.ord,&#10;                    st_dumppoints(line.geom) AS pt&#10;                   FROM line) dumps&#10;        ), merged AS (&#10;         SELECT st_linemerge(st_collect(s.geom)) AS geom&#10;           FROM (segment s&#10;             JOIN model1.flood_plain p ON (st_covers(p.geom, s.geom)))&#10;          WHERE (NOT (EXISTS ( SELECT 1&#10;                   FROM model1.reach r&#10;                  WHERE st_intersects(r.geom, s.geom))))&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    t.geom&#10;   FROM ( SELECT (st_dump(merged.geom)).geom AS geom&#10;           FROM merged) t;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="flood_plain_transect_candidate" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT l.id,&#10;    l.name,&#10;    l.id AS line_xyz,&#10;    project.orient_transect(r.geom, st_makeline(st_startpoint(l.geom), st_endpoint(l.geom))) AS geom,&#10;    'ignored_for_coverages'::hydra_constrain_type AS constrain_type,&#10;    st_intersection(r.geom, st_makeline(st_startpoint(l.geom), st_endpoint(l.geom))) AS reach_intersection,&#10;    project.orient_transect(r.geom, l.geom) AS topo&#10;   FROM (project.line_xyz l&#10;     JOIN model1.reach r ON (st_intersects(r.geom, l.geom)))&#10;  WHERE (NOT (EXISTS ( SELECT 1&#10;           FROM model1._river_cross_section_profile p&#10;          WHERE ((p.name)::text = (l.name)::text))));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="line_xyz" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="constrain_type" nullable="true" remarks="" size="2147483647" type="hydra_constrain_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="reach_intersection" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="topo" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="flowline" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH transects AS (&#10;         SELECT row_number() OVER (ORDER BY g.alpha) AS id,&#10;            g.geom,&#10;            g.elem_length,&#10;            g.bank,&#10;            g.domain,&#10;            max(st_length(g.geom)) OVER (PARTITION BY g.bank) AS maxlength&#10;           FROM ( SELECT&#10;                        CASE&#10;                            WHEN (st_distance(st_startpoint(i.geom), b.bank) &gt; st_distance(st_endpoint(i.geom), b.bank)) THEN st_reverse(i.geom)&#10;                            ELSE i.geom&#10;                        END AS geom,&#10;                    b.elem_length,&#10;                    b.id AS bank,&#10;                    st_linelocatepoint(b.bank, st_closestpoint(b.bank, i.geom)) AS alpha,&#10;                    b.major AS domain&#10;                   FROM (((model1.riverbank b&#10;                     LEFT JOIN LATERAL st_dumppoints(b.bank) p(path, geom) ON (((p.path[1] &lt;&gt; 1) AND (p.path[1] &lt;&gt; st_numpoints(b.bank)))))&#10;                     CROSS JOIN LATERAL interpolate_direction(b.start_half_transect, b.end_half_transect, p.geom) d_1(x, y))&#10;                     CROSS JOIN LATERAL st_dump(st_intersection(st_makeline(st_translate(p.geom, (('-10000'::integer)::double precision * d_1.x), (('-10000'::integer)::double precision * d_1.y)), st_translate(p.geom, ((10000)::double precision * d_1.x), ((10000)::double precision * d_1.y))), b.major)) i(path, geom))&#10;                  WHERE (st_intersects(i.geom, b.bank) AND ((st_distance(st_startpoint(i.geom), b.bank) &gt; (0.1)::double precision) OR (st_distance(st_endpoint(i.geom), b.bank) &gt; (0.1)::double precision)))&#10;                UNION ALL&#10;                 SELECT&#10;                        CASE&#10;                            WHEN (st_distance(st_startpoint(i.geom), b.bank) &gt; st_distance(st_endpoint(i.geom), b.bank)) THEN st_reverse(i.geom)&#10;                            ELSE i.geom&#10;                        END AS geom,&#10;                    b.elem_length,&#10;                    b.id AS bank,&#10;                    l.alpha,&#10;                    b.major AS domain&#10;                   FROM ((model1.riverbank b&#10;                     CROSS JOIN LATERAL st_dump(st_difference(st_exteriorring(b.major), st_collect(st_intersection(b.geom, b.major), st_intersection(b.bank, b.major)))) i(path, geom))&#10;                     CROSS JOIN LATERAL ( SELECT st_linelocatepoint(b.bank, st_closestpoint(b.bank, i.geom)) AS alpha) l)) g&#10;          WHERE (st_geometrytype(g.geom) = 'ST_LineString'::text)&#10;        ), fl AS (&#10;         SELECT st_intersection(b.geom, st_makeline(st_lineinterpolatepoint(t.geom, LEAST((((i.i)::double precision * t.elem_length) / t.maxlength), (0.99)::double precision)) ORDER BY t.id)) AS geom,&#10;            t.bank&#10;           FROM ((transects t&#10;             CROSS JOIN LATERAL generate_series(1, ((t.maxlength / t.elem_length))::integer) i(i))&#10;             CROSS JOIN LATERAL ( SELECT st_buffer(t.domain, ((- t.elem_length) / (2)::double precision)) AS geom) b)&#10;          GROUP BY i.i, t.bank, b.geom&#10;         HAVING (count(1) &gt; 1)&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    d.geom,&#10;    fl.bank&#10;   FROM (fl&#10;     CROSS JOIN LATERAL st_dump(fl.geom) d(path, geom));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="bank" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
      </table>
      <table name="froude_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._froude_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="fuse_spillway_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.width,&#10;    c.cc,&#10;    c.break_mode,&#10;    c.z_break,&#10;    c.t_break,&#10;    c.grp,&#10;    c.dt_fracw_array,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._fuse_spillway_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="break_mode" nullable="true" remarks="" size="2147483647" type="hydra_fuse_spillway_break_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="t_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="grp" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="dt_fracw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="gate_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.z_ceiling,&#10;    c.width,&#10;    c.cc,&#10;    c.action_gate_type,&#10;    c.mode_valve,&#10;    c.z_gate,&#10;    c.v_max_cms,&#10;    c.cc_submerged,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._gate_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="mode_valve" nullable="true" remarks="" size="2147483647" type="hydra_valve_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="gate_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.z_invert,&#10;    c.z_ceiling,&#10;    c.width,&#10;    c.cc,&#10;    c.action_gate_type,&#10;    c.mode_valve,&#10;    c.z_gate,&#10;    c.v_max_cms,&#10;    c.full_section_discharge_for_headloss,&#10;    c.cc_submerged,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._gate_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="mode_valve" nullable="true" remarks="" size="2147483647" type="hydra_valve_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="generation_step" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.generation_step_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="generated" foreignKey="_link_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_link"/>
            <child column="generated" foreignKey="_node_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_node"/>
            <child column="generated" foreignKey="_river_cross_section_pl1d_generated_fkey" implied="false" onDeleteCascade="true" schema="model1" table="_river_cross_section_pl1d"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('GEN_STEP_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="description" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="generation_step_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="generation_step_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="hydraulic_cut_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.qz_array,&#10;    c.full_section_discharge_for_headloss,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._hydraulic_cut_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="qz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="hydrograph_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.storage_area,&#10;    c.tq_array,&#10;    c.constant_dry_flow,&#10;    c.distrib_coef,&#10;    c.lag_time_hr,&#10;    c.sector,&#10;    c.hourly_modulation,&#10;    c.pollution_dryweather_runoff,&#10;    c.quality_dryweather_runoff,&#10;    c.external_file_data,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._hydrograph_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="storage_area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="constant_dry_flow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="distrib_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="lag_time_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="sector" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="hourly_modulation" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="pollution_dryweather_runoff" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="quality_dryweather_runoff" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="external_file_data" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="hydrology_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._hydrology_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="invalid" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT concat('node:', n.id) AS id,&#10;    n.validity,&#10;    n.name,&#10;    'node'::character varying AS type,&#10;    (n.node_type)::character varying AS subtype,&#10;    n.geom,&#10;    (model1.node_invalidity_reason(n.id))::text AS reason&#10;   FROM model1._node n&#10;  WHERE (n.validity = false)&#10;UNION ALL&#10; SELECT concat('link:', l.id) AS id,&#10;    l.validity,&#10;    l.name,&#10;    'link'::character varying AS type,&#10;    (l.link_type)::character varying AS subtype,&#10;    (st_force3d(st_centroid(l.geom)))::geometry(PointZ,2154) AS geom,&#10;    (model1.link_invalidity_reason(l.id))::text AS reason&#10;   FROM model1._link l&#10;  WHERE (l.validity = false)&#10;UNION ALL&#10; SELECT concat('singularity:', s.id) AS id,&#10;    s.validity,&#10;    s.name,&#10;    'singularity'::character varying AS type,&#10;    (s.singularity_type)::character varying AS subtype,&#10;    n.geom,&#10;    (model1.singularity_invalidity_reason(s.id))::text AS reason&#10;   FROM (model1._singularity s&#10;     JOIN model1._node n ON ((s.node = n.id)))&#10;  WHERE (s.validity = false)&#10;UNION ALL&#10; SELECT concat('profile:', p.id) AS id,&#10;    p.validity,&#10;    p.name,&#10;    'profile'::character varying AS type,&#10;    ''::character varying AS subtype,&#10;    n.geom,&#10;    ''::character varying AS reason&#10;   FROM (model1._river_cross_section_profile p&#10;     JOIN model1._node n ON ((p.id = n.id)))&#10;  WHERE (p.validity = false)&#10;UNION ALL&#10; SELECT concat('duplicate:', row_number() OVER ()) AS id,&#10;    false AS validity,&#10;    a.name,&#10;    'duplicate'::character varying AS type,&#10;    ''::character varying AS subtype,&#10;    a.geom,&#10;    ((('node '::text || (a.name)::text) || ' is duplicated with node '::text) || (b.name)::text) AS reason&#10;   FROM ((metadata m&#10;     JOIN model1._node a ON (true))&#10;     JOIN model1._node b ON (st_dwithin(a.geom, b.geom, (m.&quot;precision&quot;)::double precision)))&#10;  WHERE (a.id &lt; b.id)&#10;UNION ALL&#10; SELECT concat('manhole:', b.id) AS id,&#10;    false AS validity,&#10;    b.name,&#10;    'node'::character varying AS type,&#10;    'manhole'::character varying AS subtype,&#10;    b.geom,&#10;    'at least one connected pipe vault is above z_ground'::text AS reason&#10;   FROM ( SELECT DISTINCT a.id,&#10;            a.name,&#10;            a.geom&#10;           FROM ( SELECT m.id,&#10;                    m.name,&#10;                    m.geom&#10;                   FROM (model1.manhole_node m&#10;                     JOIN model1.pipe_link u ON ((u.up = m.id)))&#10;                  WHERE (m.z_ground &lt; u.z_vault_up)&#10;                UNION ALL&#10;                 SELECT m.id,&#10;                    m.name,&#10;                    m.geom&#10;                   FROM (model1.manhole_node m&#10;                     JOIN model1.pipe_link d ON ((d.down = m.id)))&#10;                  WHERE (m.z_ground &lt; d.z_vault_down)) a) b;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="type" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="subtype" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="reason" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
      </table>
      <table name="jet_fan_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.unit_thrust_newton,&#10;    c.number_of_units,&#10;    c.efficiency,&#10;    c.flow_velocity,&#10;    c.pipe_area,&#10;    c.is_up_to_down,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._jet_fan_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="unit_thrust_newton" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="number_of_units" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="efficiency" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="flow_velocity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="pipe_area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="is_up_to_down" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="l2d" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH link AS (&#10;         SELECT l.name,&#10;            project.crossed_border(l.geom, n.contour) AS geom&#10;           FROM model1._link l,&#10;            model1.elem_2d_node n&#10;          WHERE (((n.id = l.up) OR (n.id = l.down)) AND (l.link_type &lt;&gt; 'mesh_2d'::hydra_link_type) AND (l.link_type &lt;&gt; 'network_overflow'::hydra_link_type) AND st_intersects(l.geom, st_exteriorring(n.contour)))&#10;        )&#10; SELECT link.name,&#10;    st_x(st_startpoint(link.geom)) AS xb,&#10;    st_y(st_startpoint(link.geom)) AS yb,&#10;    st_x(st_endpoint(link.geom)) AS xa,&#10;    st_y(st_endpoint(link.geom)) AS ya&#10;   FROM link;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="1" name="xb" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="2" name="yb" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="3" name="xa" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="4" name="ya" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
      </table>
      <table name="manhole_hydrology_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area,&#10;    c.z_ground,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._manhole_hydrology_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="manhole_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area,&#10;    c.z_ground,&#10;    c.cover_diameter,&#10;    c.cover_critical_pressure,&#10;    c.inlet_width,&#10;    c.inlet_height,&#10;    c.connection_law,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._manhole_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cover_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cover_critical_pressure" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="inlet_width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="inlet_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="connection_law" nullable="true" remarks="" size="2147483647" type="hydra_manhole_connection_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="marker_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._marker_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="mesh_1d" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH lines AS (&#10;         SELECT flood_plain_flow_line.geom&#10;           FROM model1.flood_plain_flow_line&#10;        UNION&#10;         SELECT reach_flow_line.geom&#10;           FROM model1.reach_flow_line&#10;        ), blade AS (&#10;         SELECT st_union(st_buffer(lines.geom, (0.001)::double precision, 'endcap=square'::text)) AS geom&#10;           FROM lines&#10;        ), polyg AS (&#10;         SELECT st_force2d(st_difference(p.geom, b.geom)) AS geom&#10;           FROM model1.flood_plain p,&#10;            blade b&#10;        ), triang AS (&#10;         SELECT (st_dump(st_tesselate(polyg.geom))).geom AS geom&#10;           FROM polyg&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    triang.geom&#10;   FROM triang;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="mesh_1d_coted" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT row_number() OVER () AS id,&#10;    a.id AS a,&#10;    a.strt AS a_strt,&#10;    a.weight_strt AS a_strt_w,&#10;    a.nd AS a_nd,&#10;    a.weight_nd AS a_nd_w,&#10;    b.id AS b,&#10;    b.strt AS b_strt,&#10;    b.weight_strt AS b_strt_w,&#10;    b.nd AS b_nd,&#10;    b.weight_nd AS b_nd_w,&#10;    c.id AS c,&#10;    c.strt AS c_strt,&#10;    c.weight_strt AS c_strt_w,&#10;    c.nd AS c_nd,&#10;    c.weight_nd AS c_nd_w,&#10;    (((st_z(a.geom) + st_z(b.geom)) + st_z(c.geom)) / ('3'::numeric)::double precision) AS z_mean,&#10;    st_z(a.geom) AS z_a,&#10;    st_z(b.geom) AS z_b,&#10;    st_z(c.geom) AS z_c,&#10;    st_makepolygon(st_makeline(ARRAY[a.geom, b.geom, c.geom, a.geom])) AS geom,&#10;    st_makeline(ARRAY[st_startpoint(a.lnk), st_centroid(st_makepolygon(st_makeline(ARRAY[a.geom, b.geom, c.geom, a.geom]))), st_endpoint(a.lnk)]) AS lnk,&#10;    now() AS last_refresh&#10;   FROM (((model1.mesh_1d e&#10;     JOIN model1.coted_point_with_interp a ON (st_dwithin(st_pointn(st_exteriorring(e.geom), 1), a.geom, (0.1)::double precision)))&#10;     JOIN model1.coted_point_with_interp b ON (st_dwithin(st_pointn(st_exteriorring(e.geom), 2), b.geom, (0.1)::double precision)))&#10;     JOIN model1.coted_point_with_interp c ON (st_dwithin(st_pointn(st_exteriorring(e.geom), 3), c.geom, (0.1)::double precision)))&#10;  WHERE ((a.id &lt;&gt; b.id) AND (b.id &lt;&gt; c.id) AND (c.id &lt;&gt; a.id));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="a" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="a_strt" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="3" name="a_strt_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="a_nd" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="a_nd_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="b" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="b_strt" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="8" name="b_strt_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="b_nd" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="10" name="b_nd_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="c" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="c_strt" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="13" name="c_strt_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="c_nd" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="15" name="c_nd_w" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="16" name="z_mean" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="17" name="z_a" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="18" name="z_b" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="19" name="z_c" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="lnk" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="22" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="mesh_2d_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.lateral_contraction_coef,&#10;    c.border,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._mesh_2d_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="lateral_contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="metadata" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="false" defaultValue="1" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="'3.10.10'::character varying" digits="0" id="1" name="version" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="CURRENT_DATE" digits="6" id="2" name="creation_date" nullable="false" remarks="" size="29" type="timestamp" typeCode="93"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="3" name="trigger_coverage" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="true" digits="0" id="4" name="trigger_branch" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="false" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="metadata_configuration_fkey" implied="false" onDeleteCascade="false" schema="model1" table="configuration"/>
         </column>
         <column autoUpdated="false" defaultValue="false" digits="0" id="6" name="is_switching" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <index name="metadata_id_key" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <checkConstraint constraint="((id = 1))" name="metadata_id_check"/>
      </table>
      <table name="model_connect_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.cascade_mode,&#10;    c.zq_array,&#10;    c.tz_array,&#10;    c.quality,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._model_connect_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="cascade_mode" nullable="true" remarks="" size="2147483647" type="hydra_model_connect_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="zq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="quality" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="network_overflow_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_overflow,&#10;    c.area,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._network_overflow_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_overflow" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="open_parametric_geometry" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.open_parametric_geometry_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="op_geom" foreignKey="_pipe_link_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_pipe_link"/>
            <child column="down_op_geom" foreignKey="_river_cross_section_profile_down_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
            <child column="up_op_geom" foreignKey="_river_cross_section_profile_up_op_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('OP_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zbmin_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="false" digits="0" id="3" name="with_flood_plain" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="0" digits="8" id="4" name="flood_plain_width" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="0" digits="8" id="5" name="flood_plain_lateral_slope" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="open_parametric_geometry_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="open_parametric_geometry_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((array_length(zbmin_array, 1) &lt;= 20) AND (array_length(zbmin_array, 1) &gt;= 1) AND (array_length(zbmin_array, 2) = 2)))" name="open_parametric_geometry_zbmin_array_check"/>
      </table>
      <table name="open_reach" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH ends AS (&#10;         SELECT p.id,&#10;            p.geom,&#10;            'down'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up = 'valley'::hydra_cross_section_type) AND (p.type_cross_section_down &lt;&gt; 'valley'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'up'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up &lt;&gt; 'valley'::hydra_cross_section_type) AND (p.type_cross_section_down = 'valley'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'down'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_up = 'valley'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision) AND st_dwithin(p.geom, st_endpoint(r_1.geom), (1)::double precision))&#10;        UNION&#10;         SELECT p.id,&#10;            p.geom,&#10;            'up'::text AS typ,&#10;            r_1.id AS reach,&#10;            st_linelocatepoint(r_1.geom, p.geom) AS alpha&#10;           FROM model1.river_cross_section_profile p,&#10;            model1.reach r_1&#10;          WHERE ((p.type_cross_section_down = 'valley'::hydra_cross_section_type) AND st_dwithin(p.geom, r_1.geom, (0.1)::double precision) AND st_dwithin(p.geom, st_startpoint(r_1.geom), (1)::double precision))&#10;        ), bounds AS (&#10;         SELECT first_value(ends.reach) OVER (PARTITION BY ends.reach ORDER BY ends.alpha) AS first_value,&#10;            ends.typ,&#10;            lag(ends.alpha) OVER (PARTITION BY ends.reach ORDER BY ends.alpha) AS start,&#10;            ends.alpha AS &quot;end&quot;,&#10;            ends.id,&#10;            ends.reach&#10;           FROM ends&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    st_linesubstring(r.geom, b.start, b.&quot;end&quot;) AS geom,&#10;    r.id AS reach&#10;   FROM (bounds b&#10;     JOIN model1.reach r ON ((r.id = b.reach)))&#10;  WHERE (b.typ = 'down'::text);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="reach" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
      </table>
      <table name="overflow_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_crest1,&#10;    c.width1,&#10;    c.z_crest2,&#10;    c.width2,&#10;    c.cc,&#10;    c.lateral_contraction_coef,&#10;    c.break_mode,&#10;    c.z_break,&#10;    c.t_break,&#10;    c.z_invert,&#10;    c.width_breach,&#10;    c.grp,&#10;    c.dt_fracw_array,&#10;    c.border,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._overflow_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_crest1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="z_crest2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="width2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="lateral_contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="break_mode" nullable="true" remarks="" size="2147483647" type="hydra_fuse_spillway_break_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="z_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="t_break" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="width_breach" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="grp" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="dt_fracw_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="22" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="param_headloss_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.q_dz_array,&#10;    c.full_section_discharge_for_headloss,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._param_headloss_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="q_dz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="pipe_branch_marker_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.pk0_km,&#10;    c.dx,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._pipe_branch_marker_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="pk0_km" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="dx" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="pipe_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert_up,&#10;    c.z_invert_down,&#10;    c.cross_section_type,&#10;    c.h_sable,&#10;    c.branch,&#10;    c.exclude_from_branch,&#10;    c.rk,&#10;    c.custom_length,&#10;    c.circular_diameter,&#10;    c.ovoid_height,&#10;    c.ovoid_top_diameter,&#10;    c.ovoid_invert_diameter,&#10;    c.cp_geom,&#10;    c.op_geom,&#10;    c.rk_maj,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN ((((c.z_invert_up - c.z_invert_down) * st_length(p.geom)) &gt; (0)::double precision) AND (st_length(p.geom) &lt;&gt; (0)::double precision)) THEN ( SELECT&#10;                            CASE&#10;                                WHEN (c.cross_section_type = 'circular'::hydra_cross_section_type) THEN ( SELECT&#10;CASE&#10; WHEN (c.circular_diameter &gt; (0)::double precision) THEN ( WITH n AS (&#10;    SELECT ((pi() / (4)::double precision) * pow((c.circular_diameter)::double precision, (2.0)::double precision)) AS s,&#10;       (pi() * c.circular_diameter) AS p,&#10;       c.rk AS k&#10;   )&#10;  SELECT (((n.k * n.s) * pow((n.s / n.p), ((2.0 / 3.0))::double precision)) * sqrt(((c.z_invert_up - c.z_invert_down) / st_length(p.geom))))&#10;    FROM n)&#10; ELSE ('-999'::integer)::double precision&#10;END AS &quot;case&quot;)&#10;                                WHEN (c.cross_section_type = 'ovoid'::hydra_cross_section_type) THEN ( WITH n AS (&#10; SELECT (((pi() / (8)::double precision) * ((c.ovoid_top_diameter * c.ovoid_top_diameter) + (c.ovoid_invert_diameter * c.ovoid_invert_diameter))) + (((0.5)::double precision * (c.ovoid_height - ((0.5)::double precision * (c.ovoid_top_diameter + c.ovoid_invert_diameter)))) * (c.ovoid_top_diameter + c.ovoid_invert_diameter))) AS s,&#10;    (((pi() / (2)::double precision) * (c.ovoid_top_diameter + c.ovoid_invert_diameter)) + ((2)::double precision * sqrt((((c.ovoid_height - ((0.5)::double precision * (c.ovoid_top_diameter + c.ovoid_invert_diameter))) ^ (2)::double precision) + (((0.5)::double precision * (c.ovoid_top_diameter - c.ovoid_invert_diameter)) ^ (2)::double precision))))) AS p,&#10;    c.rk AS k&#10;)&#10;                                 SELECT&#10;CASE&#10; WHEN ((n.s &gt; (0)::double precision) AND (n.p &gt; (0)::double precision)) THEN ( SELECT (((n_1.k * n_1.s) * pow((n_1.s / n_1.p), ((2.0 / 3.0))::double precision)) * sqrt(((c.z_invert_up - c.z_invert_down) / st_length(p.geom))))&#10;    FROM n n_1)&#10; ELSE ('-999'::integer)::double precision&#10;END AS &quot;case&quot;&#10;                                   FROM n)&#10;                                WHEN (c.cross_section_type = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10; SELECT model1.geometric_calc_s_fct(cpg.zbmin_array) AS s,&#10;    model1.cp_geometric_calc_p_fct(cpg.zbmin_array) AS p,&#10;    c.rk AS k&#10;   FROM model1.closed_parametric_geometry cpg&#10;  WHERE (c.cp_geom = cpg.id)&#10;)&#10;                                 SELECT&#10;CASE&#10; WHEN ((n.s &gt; (0)::double precision) AND (n.p &gt; (0)::double precision)) THEN ( SELECT (((n_1.k * n_1.s) * pow((n_1.s / n_1.p), ((2.0 / 3.0))::double precision)) * sqrt(((c.z_invert_up - c.z_invert_down) / st_length(p.geom))))&#10;    FROM n n_1)&#10; ELSE ('-999'::integer)::double precision&#10;END AS &quot;case&quot;&#10;                                   FROM n)&#10;                                WHEN (c.cross_section_type = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10; SELECT model1.geometric_calc_s_fct(opg.zbmin_array) AS s,&#10;    model1.op_geometric_calc_p_fct(opg.zbmin_array) AS p,&#10;    c.rk AS k&#10;   FROM model1.open_parametric_geometry opg&#10;  WHERE (c.op_geom = opg.id)&#10;)&#10;                                 SELECT&#10;CASE&#10; WHEN ((n.s &gt; (0)::double precision) AND (n.p &gt; (0)::double precision)) THEN ( SELECT (((n_1.k * n_1.s) * pow((n_1.s / n_1.p), ((2.0 / 3.0))::double precision)) * sqrt(((c.z_invert_up - c.z_invert_down) / st_length(p.geom))))&#10;    FROM n n_1)&#10; ELSE ('-999'::integer)::double precision&#10;END AS &quot;case&quot;&#10;                                   FROM n)&#10;                                ELSE (0.0)::double precision&#10;                            END AS &quot;case&quot;)&#10;                    ELSE ('-999'::integer)::double precision&#10;                END AS &quot;case&quot;) AS qcap,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.cross_section_type = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.circular_diameter))&#10;                    WHEN (c.cross_section_type = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.ovoid_height))&#10;                    WHEN (c.cross_section_type = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    WHEN (c.cross_section_type = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_vault_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.cross_section_type = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.circular_diameter))&#10;                    WHEN (c.cross_section_type = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.ovoid_height))&#10;                    WHEN (c.cross_section_type = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    WHEN (c.cross_section_type = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_vault_down,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.cross_section_type = 'channel'::hydra_cross_section_type) THEN (( SELECT c.z_invert_up))::double precision&#10;                    ELSE (( SELECT manhole_node.z_ground&#10;                       FROM model1.manhole_node&#10;                      WHERE (p.up = manhole_node.id)))::double precision&#10;                END AS z_ground) AS z_tn_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.cross_section_type = 'channel'::hydra_cross_section_type) THEN (( SELECT c.z_invert_down))::double precision&#10;                    ELSE (( SELECT manhole_node.z_ground&#10;                       FROM model1.manhole_node&#10;                      WHERE (p.down = manhole_node.id)))::double precision&#10;                END AS z_ground) AS z_tn_down&#10;   FROM model1._pipe_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="cross_section_type" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="h_sable" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="branch" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="exclude_from_branch" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="custom_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="13" name="ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="22" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="23" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="26" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="27" name="qcap" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="28" name="z_vault_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="29" name="z_vault_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="30" name="z_tn_up" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="31" name="z_tn_down" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
      </table>
      <table name="porous_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.width,&#10;    c.transmitivity,&#10;    c.border,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._porous_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="transmitivity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="pump_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.npump,&#10;    c.zregul_array,&#10;    c.hq_array,&#10;    c.response_time_sec,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._pump_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="npump" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="zregul_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="response_time_sec" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="qq_split_hydrology_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.qq_array,&#10;    c.downstream,&#10;    c.downstream_type,&#10;    c.split1,&#10;    c.split1_type,&#10;    c.split2,&#10;    c.split2_type,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._qq_split_hydrology_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="qq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="downstream" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="downstream_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="split1" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="split1_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="split2" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="split2_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="reach" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.reach_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="reach" foreignKey="_river_node_reach_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_node"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('REACH_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="8" id="2" name="pk0_km" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="50" digits="8" id="3" name="dx" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="reach_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="model1_reach_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <index name="reach_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="reach_geom_check"/>
      </table>
      <table name="reach_flow_line" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH point AS (&#10;         SELECT t_1.id,&#10;            model1.section_interpolate_point(t_1.geom, t_1.section, (0.999)::real, (t_1.side)::character varying) AS geom&#10;           FROM model1.flood_plain_bluff_point_transect t_1,&#10;            model1.flood_plain_bluff b&#10;          WHERE (t_1.bluff = b.id)&#10;        ), ordered AS (&#10;         SELECT p.id,&#10;            p.geom,&#10;            r.id AS reach,&#10;            st_linelocatepoint(r.geom, p.geom) AS pk&#10;           FROM (point p&#10;             JOIN model1.reach r ON ((r.id = ( SELECT r_1.id&#10;                   FROM model1.reach r_1&#10;                  ORDER BY (st_distance(r_1.geom, p.geom))&#10;                 LIMIT 1))))&#10;        ), segment AS (&#10;         SELECT st_makeline(lag(ordered.geom, 1, NULL::geometry) OVER (PARTITION BY ordered.reach ORDER BY ordered.pk), ordered.geom) AS geom&#10;           FROM ordered&#10;        ), merged AS (&#10;         SELECT st_linemerge(st_collect(s.geom)) AS geom&#10;           FROM (segment s&#10;             JOIN model1.flood_plain p ON (st_covers(p.geom, s.geom)))&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    t.geom&#10;   FROM ( SELECT (st_dump(merged.geom)).geom AS geom&#10;           FROM merged) t;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="regul_gate_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.z_ceiling,&#10;    c.width,&#10;    c.cc,&#10;    c.action_gate_type,&#10;    c.z_invert_stop,&#10;    c.z_ceiling_stop,&#10;    c.v_max_cms,&#10;    c.dt_regul_hr,&#10;    c.mode_regul,&#10;    c.z_control_node,&#10;    c.z_pid_array,&#10;    c.z_tz_array,&#10;    c.q_z_crit,&#10;    c.q_tq_array,&#10;    c.hq_array,&#10;    c.nr_z_gate,&#10;    c.cc_submerged,&#10;    c.h_open,&#10;    c.h_close,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._regul_gate_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="z_invert_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="z_ceiling_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="dt_regul_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_gate_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="z_control_node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="z_pid_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="z_tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="q_z_crit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="q_tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="nr_z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="h_open" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="23" name="h_close" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="26" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="27" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="29" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="30" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="31" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="regul_sluice_gate_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.z_invert,&#10;    c.z_ceiling,&#10;    c.width,&#10;    c.cc,&#10;    c.action_gate_type,&#10;    c.z_invert_stop,&#10;    c.z_ceiling_stop,&#10;    c.v_max_cms,&#10;    c.dt_regul_hr,&#10;    c.mode_regul,&#10;    c.z_control_node,&#10;    c.z_pid_array,&#10;    c.z_tz_array,&#10;    c.q_z_crit,&#10;    c.q_tq_array,&#10;    c.hq_array,&#10;    c.nr_z_gate,&#10;    c.full_section_discharge_for_headloss,&#10;    c.cc_submerged,&#10;    c.h_open,&#10;    c.h_close,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._regul_sluice_gate_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_ceiling" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="action_gate_type" nullable="true" remarks="" size="2147483647" type="hydra_action_gate_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_invert_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="z_ceiling_stop" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="dt_regul_hr" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_gate_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="z_control_node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="z_pid_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="15" name="z_tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="16" name="q_z_crit" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="q_tq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="hq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="nr_z_gate" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="cc_submerged" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="h_open" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="23" name="h_close" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="26" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="27" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="regulated" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT DISTINCT ON (r.name) row_number() OVER () AS id,&#10;    concat(r.type, ':', r.id) AS orig_id,&#10;    r.type,&#10;    r.subtype,&#10;    r.name,&#10;    r.geom&#10;   FROM project.regulated() r(id, scenario, file, iline, model, type, subtype, name, geom)&#10;  WHERE (r.model = 'model1'::text);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="orig_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="subtype" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="regulated_current_scn" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT DISTINCT ON (r.name) row_number() OVER () AS id,&#10;    concat(r.type, ':', r.id) AS orig_id,&#10;    r.type,&#10;    r.subtype,&#10;    r.name,&#10;    r.geom&#10;   FROM project.regulated() r(id, scenario, file, iline, model, type, subtype, name, geom)&#10;  WHERE ((r.model = 'model1'::text) AND (r.scenario = (( SELECT scenario.name&#10;           FROM project.scenario&#10;          WHERE (scenario.id = ( SELECT metadata.current_scenario&#10;                   FROM project.metadata))))::text));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="orig_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="subtype" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="regulated_detailed" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT row_number() OVER () AS id,&#10;    r.scenario,&#10;    r.file,&#10;    r.iline,&#10;    concat(r.type, ':', r.id) AS orig_id,&#10;    r.type,&#10;    r.subtype,&#10;    r.name,&#10;    r.geom&#10;   FROM project.regulated() r(id, scenario, file, iline, model, type, subtype, name, geom)&#10;  WHERE (r.model = 'model1'::text);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="scenario" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="file" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="iline" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="orig_id" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="subtype" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="reservoir_rs_hydrology_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.drainage,&#10;    c.drainage_type,&#10;    c.overflow,&#10;    c.overflow_type,&#10;    c.q_drainage,&#10;    c.z_ini,&#10;    c.zs_array,&#10;    c.treatment_mode,&#10;    (c.treatment_param)::character varying AS treatment_param,&#10;    c.treatment_param AS treatment_param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._reservoir_rs_hydrology_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="drainage" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="drainage_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="overflow" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="overflow_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="q_drainage" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_ini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="treatment_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="treatment_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="reservoir_rsp_hydrology_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.drainage,&#10;    c.drainage_type,&#10;    c.overflow,&#10;    c.overflow_type,&#10;    c.z_ini,&#10;    c.zr_sr_qf_qs_array,&#10;    c.treatment_mode,&#10;    (c.treatment_param)::character varying AS treatment_param,&#10;    c.treatment_param AS treatment_param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._reservoir_rsp_hydrology_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="drainage" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="drainage_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="overflow" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="overflow_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_ini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="zr_sr_qf_qs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="treatment_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="treatment_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="results_catchment" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT catchment_node.id,&#10;    (upper((catchment_node.name)::text))::character varying(24) AS name,&#10;    catchment_node.geom,&#10;    now() AS last_refresh&#10;   FROM model1.catchment_node;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT gate_link.id,&#10;    (upper((gate_link.name)::text))::character varying(24) AS name,&#10;    gate_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.gate_link&#10;UNION&#10; SELECT regul_gate_link.id,&#10;    (upper((regul_gate_link.name)::text))::character varying(24) AS name,&#10;    regul_gate_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.regul_gate_link&#10;UNION&#10; SELECT weir_link.id,&#10;    (upper((weir_link.name)::text))::character varying(24) AS name,&#10;    weir_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.weir_link&#10;UNION&#10; SELECT borda_headloss_link.id,&#10;    (upper((borda_headloss_link.name)::text))::character varying(24) AS name,&#10;    borda_headloss_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.borda_headloss_link&#10;UNION&#10; SELECT pump_link.id,&#10;    (upper((pump_link.name)::text))::character varying(24) AS name,&#10;    pump_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.pump_link&#10;UNION&#10; SELECT deriv_pump_link.id,&#10;    (upper((deriv_pump_link.name)::text))::character varying(24) AS name,&#10;    deriv_pump_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.deriv_pump_link&#10;UNION&#10; SELECT fuse_spillway_link.id,&#10;    (upper((fuse_spillway_link.name)::text))::character varying(24) AS name,&#10;    fuse_spillway_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.fuse_spillway_link&#10;UNION&#10; SELECT connector_link.id,&#10;    (upper((connector_link.name)::text))::character varying(24) AS name,&#10;    connector_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.connector_link&#10;UNION&#10; SELECT strickler_link.id,&#10;    (upper((strickler_link.name)::text))::character varying(24) AS name,&#10;    strickler_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.strickler_link&#10;UNION&#10; SELECT porous_link.id,&#10;    (upper((porous_link.name)::text))::character varying(24) AS name,&#10;    porous_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.porous_link&#10;UNION&#10; SELECT overflow_link.id,&#10;    (upper((overflow_link.name)::text))::character varying(24) AS name,&#10;    overflow_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.overflow_link&#10;UNION&#10; SELECT network_overflow_link.id,&#10;    (upper((network_overflow_link.name)::text))::character varying(24) AS name,&#10;    network_overflow_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.network_overflow_link;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_manhole" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT n.id,&#10;    (upper((n.name)::text))::character varying(24) AS name,&#10;    n.geom,&#10;    now() AS last_refresh&#10;   FROM model1.manhole_node n;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_pipe" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT pipe_link.id,&#10;    (upper((pipe_link.name)::text))::character varying(24) AS name,&#10;    pipe_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.pipe_link&#10;  WHERE ((pipe_link.up_type = 'manhole'::hydra_node_type) AND (pipe_link.down_type = 'manhole'::hydra_node_type));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_pipe_hydrol" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT pipe_link.id,&#10;    (upper((pipe_link.name)::text))::character varying(24) AS name,&#10;    pipe_link.geom,&#10;    now() AS last_refresh&#10;   FROM model1.pipe_link&#10;  WHERE ((pipe_link.up_type = 'manhole_hydrology'::hydra_node_type) AND (pipe_link.down_type = 'manhole_hydrology'::hydra_node_type));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_river" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT n.id,&#10;    (upper((n.name)::text))::character varying(24) AS name,&#10;    n.geom,&#10;        CASE&#10;            WHEN (v.id IS NOT NULL) THEN 'valley'::text&#10;            WHEN (o.id IS NOT NULL) THEN 'channel'::text&#10;            ELSE 'closed'::text&#10;        END AS section_type,&#10;    now() AS last_refresh&#10;   FROM ((model1.river_node n&#10;     LEFT JOIN model1.open_reach v ON (st_dwithin(v.geom, n.geom, (0.001)::double precision)))&#10;     LEFT JOIN model1.channel_reach o ON (st_dwithin(o.geom, n.geom, (0.001)::double precision)));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="section_type" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="4" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="results_surface" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH dump AS (&#10;         SELECT st_collect(n.geom) AS points,&#10;            s.geom AS envelope,&#10;            s.id&#10;           FROM model1.coverage s,&#10;            model1.crossroad_node n&#10;          WHERE ((s.domain_type = 'street'::hydra_coverage_type) AND st_intersects(s.geom, n.geom))&#10;          GROUP BY s.id, s.geom&#10;        ), voronoi_1 AS (&#10;         SELECT st_intersection(st_setsrid((st_dump(st_voronoipolygons(dump.points, (0)::double precision, dump.envelope))).geom, 2154), dump.envelope) AS geom&#10;           FROM dump&#10;        ), voronoi AS (&#10;         SELECT (st_dump(voronoi_1.geom)).geom AS geom&#10;           FROM voronoi_1&#10;        )&#10; SELECT e.id,&#10;    (upper((e.name)::text))::character varying(24) AS name,&#10;    e.contour AS geom,&#10;    now() AS last_refresh&#10;   FROM model1.elem_2d_node e&#10;UNION&#10; SELECT n.id,&#10;    (upper((n.name)::text))::character varying(24) AS name,&#10;    c.geom,&#10;    now() AS last_refresh&#10;   FROM (model1.storage_node n&#10;     JOIN model1.coverage c ON ((n.contour = c.id)))&#10;UNION&#10; SELECT n.id,&#10;    (upper((n.name)::text))::character varying(24) AS name,&#10;    voronoi.geom,&#10;    now() AS last_refresh&#10;   FROM voronoi,&#10;    model1.crossroad_node n&#10;  WHERE st_intersects(voronoi.geom, n.geom)&#10;  ORDER BY 1;">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="6" id="3" name="last_refresh" nullable="true" remarks="" size="35" type="timestamptz" typeCode="93"/>
      </table>
      <table name="river_cross_section_pl1d" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT g.id,&#10;    c.name,&#10;    c.profile,&#10;    c.generated,&#10;    g.geom&#10;   FROM model1._river_cross_section_pl1d c,&#10;    model1._node g&#10;  WHERE (g.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="profile" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="river_cross_section_profile" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT g.id,&#10;    c.name,&#10;        CASE&#10;            WHEN (c.type_cross_section_up IS NOT NULL) THEN c.z_invert_up&#10;            ELSE NULL::real&#10;        END AS z_invert_up,&#10;        CASE&#10;            WHEN (c.type_cross_section_down IS NOT NULL) THEN c.z_invert_down&#10;            ELSE NULL::real&#10;        END AS z_invert_down,&#10;    c.type_cross_section_up,&#10;    c.type_cross_section_down,&#10;    c.up_rk,&#10;    c.up_rk_maj,&#10;    c.up_sinuosity,&#10;    c.up_circular_diameter,&#10;    c.up_ovoid_height,&#10;    c.up_ovoid_top_diameter,&#10;    c.up_ovoid_invert_diameter,&#10;    c.up_cp_geom,&#10;    c.up_op_geom,&#10;    c.up_vcs_geom,&#10;    c.up_vcs_topo_geom,&#10;    c.down_rk,&#10;    c.down_rk_maj,&#10;    c.down_sinuosity,&#10;    c.down_circular_diameter,&#10;    c.down_ovoid_height,&#10;    c.down_ovoid_top_diameter,&#10;    c.down_ovoid_invert_diameter,&#10;    c.down_cp_geom,&#10;    c.down_op_geom,&#10;    c.down_vcs_geom,&#10;    c.down_vcs_topo_geom,&#10;    c.configuration,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN ((c.type_cross_section_up = 'channel'::hydra_cross_section_type) OR (c.type_cross_section_up = 'valley'::hydra_cross_section_type)) THEN (( SELECT c.z_invert_up))::double precision&#10;                    ELSE ( SELECT st_z(st_startpoint(g.geom)) AS st_z)&#10;                END AS st_z) AS z_tn_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN ((c.type_cross_section_down = 'channel'::hydra_cross_section_type) OR (c.type_cross_section_down = 'valley'::hydra_cross_section_type)) THEN (( SELECT c.z_invert_down))::double precision&#10;                    ELSE ( SELECT st_z(st_endpoint(g.geom)) AS st_z)&#10;                END AS st_z) AS z_tn_down,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_up = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.up_circular_diameter))&#10;                    WHEN (c.type_cross_section_up = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.up_ovoid_height))&#10;                    WHEN (c.type_cross_section_up = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.up_cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_up = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.up_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_up = 'valley'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmaj_lbank_array[1][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.valley_cross_section_geometry opg&#10;                              WHERE (c.up_vcs_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_lbank_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_down = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.down_circular_diameter))&#10;                    WHEN (c.type_cross_section_down = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.down_ovoid_height))&#10;                    WHEN (c.type_cross_section_down = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.down_cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_down = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.down_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_down = 'valley'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmaj_lbank_array[1][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.valley_cross_section_geometry opg&#10;                              WHERE (c.down_vcs_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_lbank_down,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_up = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.up_circular_diameter))&#10;                    WHEN (c.type_cross_section_up = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_up + c.up_ovoid_height))&#10;                    WHEN (c.type_cross_section_up = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.up_cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_up = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.up_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_up = 'valley'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmaj_rbank_array[1][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.valley_cross_section_geometry opg&#10;                              WHERE (c.up_vcs_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_rbank_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_down = 'circular'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.down_circular_diameter))&#10;                    WHEN (c.type_cross_section_down = 'ovoid'::hydra_cross_section_type) THEN ( SELECT (c.z_invert_down + c.down_ovoid_height))&#10;                    WHEN (c.type_cross_section_down = 'pipe'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (cpg.zbmin_array[array_length(cpg.zbmin_array, 1)][1] - cpg.zbmin_array[1][1]) AS height&#10;                               FROM model1.closed_parametric_geometry cpg&#10;                              WHERE (c.down_cp_geom = cpg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_down = 'channel'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.open_parametric_geometry opg&#10;                              WHERE (c.down_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    WHEN (c.type_cross_section_down = 'valley'::hydra_cross_section_type) THEN ( WITH n AS (&#10;                             SELECT (opg.zbmaj_rbank_array[1][1] - opg.zbmin_array[1][1]) AS height&#10;                               FROM model1.valley_cross_section_geometry opg&#10;                              WHERE (c.down_vcs_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                    ELSE NULL::real&#10;                END AS &quot;case&quot;) AS z_rbank_down,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_down = 'valley'::hydra_cross_section_type) THEN NULL::real&#10;                    WHEN (c.type_cross_section_down = 'channel'::hydra_cross_section_type) THEN NULL::real&#10;                    ELSE ( WITH n AS (&#10;                             SELECT opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] AS height&#10;                               FROM model1.closed_parametric_geometry opg&#10;                              WHERE (c.down_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_up + n.height)&#10;                       FROM n)&#10;                END) AS z_ceiling_up,&#10;    ( SELECT&#10;                CASE&#10;                    WHEN (c.type_cross_section_down = 'valley'::hydra_cross_section_type) THEN NULL::real&#10;                    WHEN (c.type_cross_section_down = 'channel'::hydra_cross_section_type) THEN NULL::real&#10;                    ELSE ( WITH n AS (&#10;                             SELECT opg.zbmin_array[array_length(opg.zbmin_array, 1)][1] AS height&#10;                               FROM model1.closed_parametric_geometry opg&#10;                              WHERE (c.down_op_geom = opg.id)&#10;                            )&#10;                     SELECT (c.z_invert_down + n.height)&#10;                       FROM n)&#10;                END) AS z_ceiling_down,&#10;    c.validity,&#10;    c.comment,&#10;    g.geom&#10;   FROM model1._river_cross_section_profile c,&#10;    model1._node g&#10;  WHERE (g.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="z_invert_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="type_cross_section_up" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="type_cross_section_down" nullable="true" remarks="" size="2147483647" type="hydra_cross_section_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="up_rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="up_rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="up_sinuosity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="up_circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="10" name="up_ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="11" name="up_ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="12" name="up_ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="up_cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="up_op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="up_vcs_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="up_vcs_topo_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="17" name="down_rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="18" name="down_rk_maj" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="19" name="down_sinuosity" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="20" name="down_circular_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="21" name="down_ovoid_height" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="22" name="down_ovoid_top_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="23" name="down_ovoid_invert_diameter" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="24" name="down_cp_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="25" name="down_op_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="26" name="down_vcs_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="27" name="down_vcs_topo_geom" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="28" name="configuration" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="29" name="z_tn_up" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="30" name="z_tn_down" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="31" name="z_lbank_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="32" name="z_lbank_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="33" name="z_rbank_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="34" name="z_rbank_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="35" name="z_ceiling_up" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="36" name="z_ceiling_down" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="37" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="38" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="39" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="river_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.reach,&#10;    c.z_ground,&#10;    c.area,&#10;    ( SELECT (((st_linelocatepoint(reach.geom, p.geom) * st_length(reach.geom)) / (1000)::double precision) + reach.pk0_km)&#10;           FROM model1.reach reach&#10;          WHERE (reach.id = c.reach)) AS pk_km,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._river_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="reach" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_ground" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="17" id="5" name="pk_km" nullable="true" remarks="" size="17" type="float8" typeCode="8"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="riverbank" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH blade AS (&#10;         SELECT st_linemerge(st_collect(t_1.geom)) AS geom&#10;           FROM ( SELECT COALESCE(st_snap(st_force2d(r.geom), st_collect(st_force2d(l.geom)), (0.1)::double precision), st_force2d(r.geom)) AS geom&#10;                   FROM (model1.open_reach r&#10;                     LEFT JOIN model1.connector_link l ON (st_dwithin(r.geom, l.geom, (0.1)::double precision)))&#10;                  GROUP BY r.geom&#10;                UNION&#10;                 SELECT st_force2d(l.geom) AS geom&#10;                   FROM (model1.open_reach r&#10;                     LEFT JOIN model1.connector_link l ON ((st_dwithin(r.geom, l.geom, (0.1)::double precision) AND st_dwithin(st_collect(ARRAY[st_startpoint(r.geom), st_endpoint(r.geom)]), l.geom, (0.1)::double precision))))) t_1&#10;        ), cov AS (&#10;         SELECT c.id AS coverage,&#10;            st_force2d(c.geom) AS geom,&#10;            st_collect(d_1.geom) AS blade,&#10;            t_1.transects,&#10;            st_difference(st_force2d(st_exteriorring(c.geom)), t_1.discretized) AS mbanks,&#10;            t_1.elem_length&#10;           FROM (((model1.coverage c&#10;             CROSS JOIN blade b_1)&#10;             CROSS JOIN LATERAL ( SELECT st_collect(st_force2d(t_2.geom)) AS transects,&#10;                    st_collect(st_force2d(t_2.discretized)) AS discretized,&#10;                    min(t_2.elem_length) AS elem_length&#10;                   FROM model1.constrain t_2&#10;                  WHERE ((t_2.geom &amp;&amp; c.geom) AND (st_length(st_intersection(t_2.discretized, c.geom)) &gt; (0)::double precision) AND (t_2.constrain_type = 'flood_plain_transect'::hydra_constrain_type))) t_1)&#10;             JOIN LATERAL st_dump(b_1.geom) d_1(path, geom) ON (st_intersects(d_1.geom, c.geom)))&#10;          WHERE (c.domain_type = 'reach'::hydra_coverage_type)&#10;          GROUP BY c.id, c.geom, t_1.transects, t_1.discretized, t_1.elem_length&#10;        ), covr AS (&#10;         SELECT c.coverage,&#10;            d_1.geom,&#10;            c.blade,&#10;            st_linemerge(st_intersection(st_snap(c.blade, d_1.geom, (0.1)::double precision), st_exteriorring(d_1.geom))) AS reach,&#10;            c.transects,&#10;            c.mbanks,&#10;            c.elem_length&#10;           FROM (cov c&#10;             CROSS JOIN LATERAL st_dump(st_split(c.geom, c.blade)) d_1(path, geom))&#10;        ), bank AS (&#10;         SELECT c.geom AS side,&#10;            c.reach,&#10;            s.geom AS start_,&#10;            e.geom AS end_,&#10;            project.line_offset(c.reach, s.geom, e.geom, c.geom) AS geom,&#10;            c.coverage,&#10;            e.transect AS end_transect,&#10;            s.transect AS start_transect,&#10;            COALESCE(left_.geom, st_makeline(st_startpoint(s.transect), st_startpoint(e.transect))) AS left_,&#10;            COALESCE(right_.geom, st_makeline(st_endpoint(s.transect), st_endpoint(e.transect))) AS right_,&#10;            c.elem_length&#10;           FROM ((((covr c&#10;             CROSS JOIN LATERAL ( SELECT p.geom,&#10;                    ((p.path[1] = 1) OR (p.path[1] = st_numpoints(t_1.geom))) AS is_end,&#10;                    t_1.geom AS transect&#10;                   FROM (st_dump(c.transects) t_1(path, geom)&#10;                     CROSS JOIN LATERAL st_dumppoints(t_1.geom) p(path, geom))&#10;                  WHERE (st_dwithin(p.geom, c.geom, (0.1)::double precision) AND st_dwithin(t_1.geom, st_startpoint(c.reach), (0.1)::double precision))&#10;                  ORDER BY (st_distance(p.geom, st_startpoint(c.reach)))&#10;                 LIMIT 1) s)&#10;             CROSS JOIN LATERAL ( SELECT p.geom,&#10;                    ((p.path[1] = 1) OR (p.path[1] = st_numpoints(t_1.geom))) AS is_end,&#10;                    t_1.geom AS transect&#10;                   FROM (st_dump(c.transects) t_1(path, geom)&#10;                     CROSS JOIN LATERAL st_dumppoints(t_1.geom) p(path, geom))&#10;                  WHERE (st_dwithin(p.geom, c.geom, (0.1)::double precision) AND st_dwithin(t_1.geom, st_endpoint(c.reach), (0.1)::double precision))&#10;                  ORDER BY (st_distance(p.geom, st_endpoint(c.reach)))&#10;                 LIMIT 1) e)&#10;             LEFT JOIN LATERAL ( SELECT d_1.geom&#10;                   FROM st_dump(c.mbanks) d_1(path, geom)&#10;                  WHERE st_dwithin(d_1.geom, st_startpoint(e.transect), (0.1)::double precision)) left_ ON (true))&#10;             LEFT JOIN LATERAL ( SELECT d_1.geom&#10;                   FROM st_dump(c.mbanks) d_1(path, geom)&#10;                  WHERE st_dwithin(d_1.geom, st_endpoint(e.transect), (0.1)::double precision)) right_ ON (true))&#10;          WHERE ((NOT (e.is_end AND s.is_end)) AND (NOT (s.geom = e.geom)))&#10;        )&#10; SELECT row_number() OVER () AS id,&#10;    b.coverage,&#10;    b.geom,&#10;    d.geom AS major,&#10;    b.reach,&#10;    t.side,&#10;        CASE&#10;            WHEN (t.side = 'left'::text) THEN st_makeline(st_startpoint(b.start_transect), st_startpoint(b.reach))&#10;            ELSE st_makeline(st_startpoint(b.reach), st_endpoint(b.start_transect))&#10;        END AS start_half_transect,&#10;        CASE&#10;            WHEN (t.side = 'left'::text) THEN st_makeline(st_startpoint(b.end_transect), st_endpoint(b.reach))&#10;            ELSE st_makeline(st_endpoint(b.reach), st_endpoint(b.end_transect))&#10;        END AS end_half_transect,&#10;        CASE&#10;            WHEN (t.side = 'left'::text) THEN b.left_&#10;            ELSE b.right_&#10;        END AS bank,&#10;    b.elem_length&#10;   FROM ((bank b&#10;     CROSS JOIN LATERAL st_dump(st_polygonize(ARRAY[st_union(st_exteriorring(b.side), b.geom)])) d(path, geom))&#10;     CROSS JOIN LATERAL ( SELECT&#10;                CASE&#10;                    WHEN st_ispolygonccw(st_makepolygon(st_makeline(ARRAY[b.start_, st_pointn(b.reach, 1), st_pointn(b.reach, 2), b.start_]))) THEN 'left'::text&#10;                    ELSE 'right'::text&#10;                END AS side) t)&#10;  WHERE (NOT st_intersects(d.geom, b.reach));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="19" type="int8" typeCode="-5"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="coverage" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="major" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="reach" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="side" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="start_half_transect" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="end_half_transect" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="bank" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="elem_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
      </table>
      <table name="routing_hydrology_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.cross_section,&#10;    c.length,&#10;    c.slope,&#10;    c.hydrograph,&#10;    c.split_coef,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._routing_hydrology_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="cross_section" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="hydrograph" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="split_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="station" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.station_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="station" foreignKey="_station_node_station_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_station_node"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('STATION_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="station_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="station_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="station_geom_check"/>
      </table>
      <table name="station_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.area,&#10;    c.z_invert,&#10;    c.station,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._station_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="area" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="station" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="storage_node" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    c.zs_array,&#10;    c.zini,&#10;    c.contour,&#10;    c.contraction_coef,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._storage_node c,&#10;    model1._node p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="contour" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="contraction_coef" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="street" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.street_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="project.unique_name('STREET_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="0" digits="8" id="2" name="width" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="width_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="100" digits="8" id="4" name="elem_length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'40'::numeric" digits="8" id="5" name="rk" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="false" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="comment" nullable="true" remarks="" size="256" type="varchar" typeCode="12"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="street_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="model1_street_geom_idx" unique="false">
            <column ascending="true" name="geom"/>
         </index>
         <index name="street_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(st_isvalid(geom))" name="street_geom_check"/>
      </table>
      <table name="street_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH p AS (&#10;         SELECT metadata.&quot;precision&quot; AS prec&#10;           FROM metadata&#10;        ), links AS (&#10;         SELECT s.rk,&#10;            s.width,&#10;            s.width_invert,&#10;            st_makeline(lag(n.geom) OVER (PARTITION BY s.id ORDER BY (st_linelocatepoint(s.geom, n.geom))), n.geom) AS geom&#10;           FROM model1.street s,&#10;            model1.crossroad_node n,&#10;            p&#10;          WHERE st_dwithin(s.geom, n.geom, (p.prec)::double precision)&#10;        UNION ALL&#10;         SELECT s.rk,&#10;            s.width,&#10;            s.width_invert,&#10;            st_makeline(l_1.geom, f.geom) AS geom&#10;           FROM (((model1.street s&#10;             CROSS JOIN p)&#10;             JOIN model1.crossroad_node f ON (st_dwithin(st_startpoint(s.geom), f.geom, (p.prec)::double precision)))&#10;             CROSS JOIN LATERAL ( SELECT n.geom&#10;                   FROM model1.crossroad_node n&#10;                  WHERE st_dwithin(s.geom, n.geom, (p.prec)::double precision)&#10;                  ORDER BY (st_linelocatepoint(s.geom, n.geom)) DESC&#10;                 LIMIT 1) l_1)&#10;          WHERE st_isring(s.geom)&#10;        )&#10; SELECT ((row_number() OVER ())::integer + mid.i) AS id,&#10;    ('LRUE'::text || ((((row_number() OVER ())::integer + mid.i))::character varying)::text) AS name,&#10;    u.id AS up,&#10;    d.id AS down,&#10;    l.width,&#10;    l.width_invert,&#10;    (st_length(l.geom))::real AS length,&#10;    l.rk,&#10;    l.geom&#10;   FROM (((links l&#10;     JOIN model1.crossroad_node u ON ((st_startpoint(l.geom) = u.geom)))&#10;     JOIN model1.crossroad_node d ON ((st_endpoint(l.geom) = d.geom)))&#10;     CROSS JOIN ( SELECT max(_link.id) AS i&#10;           FROM model1._link) mid)&#10;  WHERE ((l.geom IS NOT NULL) AND st_isvalid(l.geom))&#10;  ORDER BY ((row_number() OVER ())::integer + mid.i);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="2147483647" type="text" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="strickler_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.slope,&#10;    c.k,&#10;    c.width,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._strickler_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="slope" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="k" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="strickler_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_crest1,&#10;    c.width1,&#10;    c.length,&#10;    c.rk,&#10;    c.z_crest2,&#10;    c.width2,&#10;    c.border,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._strickler_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_crest1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width1" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="length" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="rk" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="z_crest2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="9" name="width2" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="border" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="tank_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.zs_array,&#10;    c.zini,&#10;    c.treatment_mode,&#10;    (c.treatment_param)::character varying AS treatment_param,&#10;    c.treatment_param AS treatment_param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._tank_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zs_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="zini" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="treatment_mode" nullable="true" remarks="" size="2147483647" type="hydra_pollution_treatment_mode" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="treatment_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="treatment_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="thiessen_rain_gage" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" WITH vertices AS (&#10;         SELECT st_union(rain_gage.geom) AS geom&#10;           FROM project.rain_gage&#10;        ), extend AS (&#10;         SELECT st_buffer(st_union(st_buffer(catchment.geom, (1)::double precision)), ('-1'::integer)::double precision) AS geom&#10;           FROM model1.catchment&#10;        ), voronoi AS (&#10;         SELECT st_voronoipolygons(v.geom, (0)::double precision, e_1.geom) AS geom&#10;           FROM vertices v,&#10;            extend e_1&#10;        ), polygons AS (&#10;         SELECT (st_dump(voronoi.geom)).geom AS geom&#10;           FROM voronoi&#10;        )&#10; SELECT rg.id,&#10;    rg.name,&#10;    st_intersection(p.geom, e.geom) AS geom&#10;   FROM project.rain_gage rg,&#10;    polygons p,&#10;    extend e&#10;  WHERE (st_contains(p.geom, rg.geom) AND st_intersects(p.geom, e.geom));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
      </table>
      <table name="tz_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.tz_array,&#10;    c.cyclic,&#10;    c.external_file_data,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._tz_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="tz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="cyclic" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="external_file_data" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="urban_flood_risk_area" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.urban_flood_risk_area_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4"/>
         <column autoUpdated="false" defaultValue="project.unique_name('UFRA_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="16" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="urban_flood_risk_area_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="urban_flood_risk_area_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
      </table>
      <table name="valley_cross_section_geometry" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.valley_cross_section_geometry_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="down_vcs_geom" foreignKey="_river_cross_section_profile_down_vcs_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
            <child column="up_vcs_geom" foreignKey="_river_cross_section_profile_up_vcs_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('VA_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="zbmin_array" nullable="false" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zbmaj_lbank_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="zbmaj_rbank_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="1" digits="8" id="5" name="rlambda" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'-999'::integer" digits="8" id="6" name="rmu1" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'-999'::integer" digits="8" id="7" name="rmu2" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'-999'::integer" digits="8" id="8" name="zlevee_lb" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="'-999'::integer" digits="8" id="9" name="zlevee_rb" nullable="false" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="transect" nullable="true" remarks="" size="10" type="int4" typeCode="4">
            <parent column="id" foreignKey="valley_cross_section_geometry_transect_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_constrain"/>
         </column>
         <column autoUpdated="false" defaultValue="false" digits="0" id="11" name="t_ignore_pt" nullable="false" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="150" digits="0" id="12" name="t_discret" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="10" digits="0" id="13" name="t_distance_pt" nullable="false" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="14" name="sz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="valley_cross_section_geometry_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="valley_cross_section_geometry_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((rlambda &gt; (0)::double precision) AND (rlambda &lt;= (1)::double precision)))" name="valley_cross_section_geometry_rlambda_check"/>
         <checkConstraint constraint="(((array_length(zbmaj_lbank_array, 1) &lt;= 8) AND (array_length(zbmaj_lbank_array, 1) &gt;= 1) AND (array_length(zbmaj_lbank_array, 2) = 2)))" name="valley_cross_section_geometry_zbmaj_lbank_array_check"/>
         <checkConstraint constraint="(((array_length(zbmaj_rbank_array, 1) &lt;= 8) AND (array_length(zbmaj_rbank_array, 1) &gt;= 1) AND (array_length(zbmaj_rbank_array, 2) = 2)))" name="valley_cross_section_geometry_zbmaj_rbank_array_check"/>
         <checkConstraint constraint="(((array_length(zbmin_array, 1) &lt;= 6) AND (array_length(zbmin_array, 1) &gt;= 1) AND (array_length(zbmin_array, 2) = 2)))" name="valley_cross_section_geometry_zbmin_array_check"/>
      </table>
      <table name="valley_cross_section_topo_geometry" numRows="0" remarks="" schema="model1" type="TABLE">
         <column autoUpdated="true" defaultValue="nextval('model1.valley_cross_section_topo_geometry_id_seq'::regclass)" digits="0" id="0" name="id" nullable="false" remarks="" size="10" type="serial" typeCode="4">
            <child column="down_vcs_topo_geom" foreignKey="_river_cross_section_profile_down_vcs_topo_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
            <child column="up_vcs_topo_geom" foreignKey="_river_cross_section_profile_up_vcs_topo_geom_fkey" implied="false" onDeleteCascade="false" schema="model1" table="_river_cross_section_profile"/>
         </column>
         <column autoUpdated="false" defaultValue="project.unique_name('VAT_'::character varying)" digits="0" id="1" name="name" nullable="false" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="2" name="xz_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <primaryKey column="id" sequenceNumberInPK="1"/>
         <index name="valley_cross_section_topo_geometry_pkey" unique="true">
            <column ascending="true" name="id"/>
         </index>
         <index name="valley_cross_section_topo_geometry_name_key" unique="true">
            <column ascending="true" name="name"/>
         </index>
         <checkConstraint constraint="(((array_length(xz_array, 1) &lt;= 150) AND (array_length(xz_array, 1) &gt;= 1) AND (array_length(xz_array, 2) = 2)))" name="valley_cross_section_topo_geometry_xz_array_check"/>
      </table>
      <table name="ventilator_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.q_dp_array,&#10;    c.is_up_to_down,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._ventilator_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="q_dp_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="is_up_to_down" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="weir_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.z_weir,&#10;    c.width,&#10;    c.cc,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._weir_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_weir" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="weir_link" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    p.up,&#10;    p.down,&#10;    c.z_invert,&#10;    c.width,&#10;    c.cc,&#10;    c.z_weir,&#10;    c.v_max_cms,&#10;    p.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.generated,&#10;    p.validity,&#10;    p.up_type,&#10;    p.down_type,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._weir_link c,&#10;    model1._link p&#10;  WHERE (p.id = c.id);">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="up" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="down" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="7" name="z_weir" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="8" name="v_max_cms" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="generated" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="up_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="down_type" nullable="true" remarks="" size="2147483647" type="hydra_node_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="zq_bc_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.zq_array,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._zq_bc_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="zq_array" nullable="true" remarks="" size="8" type="_float4" typeCode="2003"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="zq_split_hydrology_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.downstream,&#10;    c.downstream_type,&#10;    c.split1,&#10;    c.split1_type,&#10;    c.split2,&#10;    c.split2_type,&#10;    c.downstream_law,&#10;    (c.downstream_param)::character varying AS downstream_param,&#10;    c.split1_law,&#10;    (c.split1_param)::character varying AS split1_param,&#10;    c.split2_law,&#10;    (c.split2_param)::character varying AS split2_param,&#10;    c.downstream_param AS downstream_param_json,&#10;    c.split1_param AS split1_param_json,&#10;    c.split2_param AS split2_param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._zq_split_hydrology_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="3" name="downstream" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="4" name="downstream_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="5" name="split1" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="6" name="split1_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="split2" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="split2_type" nullable="true" remarks="" size="2147483647" type="hydra_link_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="downstream_law" nullable="true" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="downstream_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="split1_law" nullable="true" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="split1_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="split2_law" nullable="true" remarks="" size="2147483647" type="hydra_split_law_type" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="split2_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="downstream_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="split1_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="17" name="split2_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="18" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="19" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="20" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="21" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="22" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
      <table name="zregul_weir_singularity" numRows="0" remarks="" schema="model1" type="VIEW" viewSql=" SELECT p.id,&#10;    p.name,&#10;    n.id AS node,&#10;    c.z_invert,&#10;    c.z_regul,&#10;    c.width,&#10;    c.cc,&#10;    c.mode_regul,&#10;    c.reoxy_law,&#10;    (c.reoxy_param)::character varying AS reoxy_param,&#10;    c.full_section_discharge_for_headloss,&#10;    c.reoxy_param AS reoxy_param_json,&#10;    n.geom,&#10;    (p.configuration)::character varying AS configuration,&#10;    p.validity,&#10;    p.configuration AS configuration_json,&#10;    p.comment&#10;   FROM model1._zregul_weir_singularity c,&#10;    model1._singularity p,&#10;    model1._node n&#10;  WHERE ((p.id = c.id) AND (n.id = p.node));">
         <column autoUpdated="false" defaultValue="null" digits="0" id="0" name="id" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="1" name="name" nullable="true" remarks="" size="24" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="2" name="node" nullable="true" remarks="" size="10" type="int4" typeCode="4"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="3" name="z_invert" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="4" name="z_regul" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="5" name="width" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="8" id="6" name="cc" nullable="true" remarks="" size="8" type="float4" typeCode="7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="7" name="mode_regul" nullable="true" remarks="" size="2147483647" type="hydra_weir_mode_regul" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="8" name="reoxy_law" nullable="true" remarks="" size="2147483647" type="hydra_weir_mode_reoxy" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="9" name="reoxy_param" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="10" name="full_section_discharge_for_headloss" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="11" name="reoxy_param_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="12" name="geom" nullable="true" remarks="" size="2147483647" type="geometry" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="13" name="configuration" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="14" name="validity" nullable="true" remarks="" size="1" type="bool" typeCode="-7"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="15" name="configuration_json" nullable="true" remarks="" size="2147483647" type="json" typeCode="1111"/>
         <column autoUpdated="false" defaultValue="null" digits="0" id="16" name="comment" nullable="true" remarks="" size="2147483647" type="varchar" typeCode="12"/>
      </table>
   </tables>
   <routines>
      <routine dataAccess="MODIFIES" deterministic="false" name="_link_after_delete_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        delete from model1._node
        where id=old.down
        and generated is not null
        and (select count(1) from model1._link where up=old.down) = 0
        and (select count(1) from model1._link where down=old.down) = 0
        and (select count(1) from model1._singularity as s where s.id=id) = 0;
        delete from model1._node
        where id=old.up
        and generated is not null
        and (select count(1) from model1._link where up=old.up) = 0
        and (select count(1) from model1._link where down=old.up) = 0
        and (select count(1) from model1._singularity as s where s.id=id) = 0;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="_str_profile_from_transect(flood_plain_transect geometry, interpolate boolean DEFAULT false, discretization integer DEFAULT 150, ignore_points boolean DEFAULT false, distance_point integer DEFAULT 100)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import profile_from_transect
    return profile_from_transect(plpy, flood_plain_transect, 'model1', 2154, interpolate, discretization, ignore_points, distance_point)]]></definition>
         <parameters>
            <parameter mode="IN" name="flood_plain_transect" type="geometry"/>
            <parameter mode="IN" name="interpolate" type="boolean"/>
            <parameter mode="IN" name="discretization" type="integer"/>
            <parameter mode="IN" name="ignore_points" type="boolean"/>
            <parameter mode="IN" name="distance_point" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="add_configuration_fct(configuration json, id integer, table_name character varying)" returnType="void" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config varchar;
    begin
        if configuration is not null then
            -- @todo complete configuration with default if needed
            if 'default' not in (select k from json_object_keys(configuration) as k) then
                raise exception 'trying to add a configuration with no default values';
            end if;
            insert into model1.configuration(name)
                select k
                from json_object_keys(configuration) as k
                where k not in (select name from model1.configuration);
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="configuration" type="json"/>
            <parameter mode="IN" name="id" type="integer"/>
            <parameter mode="IN" name="table_name" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="air_duct_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'air_duct' = 'routing_hydrology' or 'air_duct' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('air_duct', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'air_duct') where name = 'define_later' and id = id_;
            insert into model1._air_duct_link(id, link_type, z_invert_up, z_invert_down, area, perimeter, friction_coefficient, custom_length)
                values (id_, 'air_duct', new.z_invert_up, new.z_invert_down, new.area, new.perimeter, coalesce(new.friction_coefficient, .008), new.custom_length);
            if 'air_duct' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'air_duct_link');
            update model1._link set validity = (select (z_invert_up is not null) and (z_invert_down is not null) and (area > 0) and (perimeter > 0) and (friction_coefficient > 0) from  model1._air_duct_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'air_duct' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert_up, new.z_invert_down, new.area, new.perimeter, new.friction_coefficient, new.custom_length) is distinct from (old.z_invert_up, old.z_invert_down, old.area, old.perimeter, old.friction_coefficient, old.custom_length)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert_up, old.z_invert_down, old.area, old.perimeter, old.friction_coefficient, old.custom_length) as o, (select new.z_invert_up, new.z_invert_down, new.area, new.perimeter, new.friction_coefficient, new.custom_length) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert_up, new.z_invert_down, new.area, new.perimeter, new.friction_coefficient, new.custom_length) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._air_duct_link set z_invert_up=new.z_invert_up, z_invert_down=new.z_invert_down, area=new.area, perimeter=new.perimeter, friction_coefficient=new.friction_coefficient, custom_length=new.custom_length where id=old.id;

            if 'air_duct' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'air_duct_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'air_duct' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert_up is not null) and (z_invert_down is not null) and (area > 0) and (perimeter > 0) and (friction_coefficient > 0) from  model1._air_duct_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._air_duct_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'air_duct' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'air_duct' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="air_flow_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'air_flow_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'air_flow_bc') where name = 'define_later' and id = id_;

            insert into model1._air_flow_bc_singularity(id, singularity_type, flow, is_inwards)
                values (id_, 'air_flow_bc', coalesce(new.flow, 0), coalesce(new.is_inwards, false));
            if 'air_flow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'air_flow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'air_flow_bc_singularity');
            update model1._singularity set validity = (select (flow >= 0) and (is_inwards is not null) from  model1._air_flow_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.flow, new.is_inwards) is distinct from (old.flow, old.is_inwards)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.flow, old.is_inwards) as o, (select new.flow, new.is_inwards) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.flow, new.is_inwards) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._air_flow_bc_singularity set flow=new.flow, is_inwards=new.is_inwards where id=old.id;
            if 'air_flow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'air_flow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'air_flow_bc_singularity');
            update model1._singularity set validity = (select (flow >= 0) and (is_inwards is not null) from  model1._air_flow_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'air_flow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._air_flow_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'air_flow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="air_headloss_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'air_headloss' = 'routing_hydrology' or 'air_headloss' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('air_headloss', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'air_headloss') where name = 'define_later' and id = id_;
            insert into model1._air_headloss_link(id, link_type, area, up_to_down_headloss_coefficient, down_to_up_headloss_coefficient)
                values (id_, 'air_headloss', new.area, coalesce(new.up_to_down_headloss_coefficient, .008), coalesce(new.down_to_up_headloss_coefficient, .008));
            if 'air_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'air_headloss_link');
            update model1._link set validity = (select (area > 0) and (up_to_down_headloss_coefficient > 0) and (down_to_up_headloss_coefficient > 0) from  model1._air_headloss_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'air_headloss' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.up_to_down_headloss_coefficient, new.down_to_up_headloss_coefficient) is distinct from (old.area, old.up_to_down_headloss_coefficient, old.down_to_up_headloss_coefficient)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.up_to_down_headloss_coefficient, old.down_to_up_headloss_coefficient) as o, (select new.area, new.up_to_down_headloss_coefficient, new.down_to_up_headloss_coefficient) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.up_to_down_headloss_coefficient, new.down_to_up_headloss_coefficient) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._air_headloss_link set area=new.area, up_to_down_headloss_coefficient=new.up_to_down_headloss_coefficient, down_to_up_headloss_coefficient=new.down_to_up_headloss_coefficient where id=old.id;

            if 'air_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'air_headloss_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'air_headloss' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (area > 0) and (up_to_down_headloss_coefficient > 0) and (down_to_up_headloss_coefficient > 0) from  model1._air_headloss_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._air_headloss_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'air_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'air_headloss' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="air_pressure_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'air_pressure_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'air_pressure_bc') where name = 'define_later' and id = id_;

            insert into model1._air_pressure_bc_singularity(id, singularity_type, relative_pressure)
                values (id_, 'air_pressure_bc', coalesce(new.relative_pressure, 0));
            if 'air_pressure_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'air_pressure_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'air_pressure_bc_singularity');
            update model1._singularity set validity = (select (relative_pressure is not null) from  model1._air_pressure_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.relative_pressure) is distinct from (old.relative_pressure)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.relative_pressure) as o, (select new.relative_pressure) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.relative_pressure) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._air_pressure_bc_singularity set relative_pressure=new.relative_pressure where id=old.id;
            if 'air_pressure_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'air_pressure_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'air_pressure_bc_singularity');
            update model1._singularity set validity = (select (relative_pressure is not null) from  model1._air_pressure_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'air_pressure_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._air_pressure_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'air_pressure_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="auto_param_catchment(catchment_id integer)" returnType="TABLE(area real, rl real, slope real, c_imp real)" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        select ST_Area(c.geom)
        from model1.catchment_node as n, model1.catchment as c
        where n.id=catchment_id and ST_Contains(c.geom, n.geom)
        into area;

        select ST_Length(l.geom), Greatest(( project.altitude(ST_StartPoint(l.geom)) - project.altitude(ST_EndPoint(l.geom)) ) / ST_Length(l.geom), 0.005)
        from model1.catchment_node as n, model1.routing_hydrology_link as l
        where n.id=catchment_id and l.up=n.id
        into rl, slope;

        select Sum((ST_Area(ST_Intersection(c.geom, lo.geom)) / ST_Area(c.geom)) * t.c_imp)
	    from model1.catchment_node as n, model1.catchment as c, project.land_occupation as lo
	    join project.land_type as t on t.land_type=lo.land_type
	    where n.id=catchment_id and ST_Contains(c.geom, n.geom) and ST_Intersects(c.geom, lo.geom)
	    into c_imp;

        return next;
        return;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="catchment_id" type="integer"/>
            <parameter mode="TABLE" name="area" type="real"/>
            <parameter mode="TABLE" name="rl" type="real"/>
            <parameter mode="TABLE" name="slope" type="real"/>
            <parameter mode="TABLE" name="c_imp" type="real"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="borda_headloss_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'borda_headloss' = 'routing_hydrology' or 'borda_headloss' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('borda_headloss', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'borda_headloss') where name = 'define_later' and id = id_;
            insert into model1._borda_headloss_link(id, link_type, law_type, param)
                values (id_, 'borda_headloss', new.law_type, new.param::json);
            if 'borda_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'borda_headloss_link');
            update model1._link set validity = (select (law_type is not null) and (param is not null) from  model1._borda_headloss_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'borda_headloss' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.law_type, new.param) is distinct from (old.law_type, old.param)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.law_type, old.param) as o, (select new.law_type, new.param) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.law_type, new.param) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._borda_headloss_link set law_type=new.law_type, param=new.param::json where id=old.id;

            if 'borda_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'borda_headloss_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'borda_headloss' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (law_type is not null) and (param is not null) from  model1._borda_headloss_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._borda_headloss_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'borda_headloss' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'borda_headloss' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="borda_headloss_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'borda_headloss', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'borda_headloss') where name = 'define_later' and id = id_;

            insert into model1._borda_headloss_singularity(id, singularity_type, law_type, param, full_section_discharge_for_headloss)
                values (id_, 'borda_headloss', new.law_type, new.param::json, coalesce(new.full_section_discharge_for_headloss, 't'));
            if 'borda_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'borda_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'borda_headloss_singularity');
            update model1._singularity set validity = (select (law_type is not null) and (param is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._borda_headloss_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.law_type, new.param, new.full_section_discharge_for_headloss) is distinct from (old.law_type, old.param, old.full_section_discharge_for_headloss)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.law_type, old.param, old.full_section_discharge_for_headloss) as o, (select new.law_type, new.param, new.full_section_discharge_for_headloss) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.law_type, new.param, new.full_section_discharge_for_headloss) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._borda_headloss_singularity set law_type=new.law_type, param=new.param::json, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss where id=old.id;
            if 'borda_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'borda_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'borda_headloss_singularity');
            update model1._singularity set validity = (select (law_type is not null) and (param is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._borda_headloss_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'borda_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._borda_headloss_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'borda_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bradley_headloss_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'bradley_headloss', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'bradley_headloss') where name = 'define_later' and id = id_;

            insert into model1._bradley_headloss_singularity(id, singularity_type, d_abutment_l, d_abutment_r, abutment_type, zw_array, z_ceiling)
                values (id_, 'bradley_headloss', new.d_abutment_l, new.d_abutment_r, coalesce(new.abutment_type, 'angle_90'), new.zw_array, coalesce(new.z_ceiling, new.zw_array[array_length(new.zw_array, 1)][1]));
            if 'bradley_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'bradley_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'bradley_headloss_singularity');
            update model1._singularity set validity = (select (d_abutment_l is not null) and (d_abutment_r is not null) and (abutment_type is not null) and (zw_array is not null ) and (z_ceiling is not null) and (array_length(zw_array, 1)<=10) and (array_length(zw_array, 1)>=1) and (array_length(zw_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._bradley_headloss_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.d_abutment_l, new.d_abutment_r, new.abutment_type, new.zw_array, new.z_ceiling) is distinct from (old.d_abutment_l, old.d_abutment_r, old.abutment_type, old.zw_array, old.z_ceiling)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.d_abutment_l, old.d_abutment_r, old.abutment_type, old.zw_array, old.z_ceiling) as o, (select new.d_abutment_l, new.d_abutment_r, new.abutment_type, new.zw_array, new.z_ceiling) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.d_abutment_l, new.d_abutment_r, new.abutment_type, new.zw_array, new.z_ceiling) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._bradley_headloss_singularity set d_abutment_l=new.d_abutment_l, d_abutment_r=new.d_abutment_r, abutment_type=new.abutment_type, zw_array=new.zw_array, z_ceiling=new.z_ceiling where id=old.id;
            if 'bradley_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'bradley_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'bradley_headloss_singularity');
            update model1._singularity set validity = (select (d_abutment_l is not null) and (d_abutment_r is not null) and (abutment_type is not null) and (zw_array is not null ) and (z_ceiling is not null) and (array_length(zw_array, 1)<=10) and (array_length(zw_array, 1)>=1) and (array_length(zw_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._bradley_headloss_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'bradley_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._bradley_headloss_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'bradley_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="branch_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        if tg_op = 'INSERT' then
            update model1.hydraulic_cut_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.zregul_weir_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.param_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.regul_sluice_gate_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.gate_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.borda_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            return new;
        else
            if tg_op = 'UPDATE' then
                update model1.hydraulic_cut_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.zregul_weir_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.param_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.regul_sluice_gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.borda_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                return new;
            else
                update model1.hydraulic_cut_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.zregul_weir_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.param_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.regul_sluice_gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.borda_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                return old;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="branch_update_fct()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        update model1._pipe_link set branch = null;
        delete from model1.branch;

        -- count up and down node connectivity on pipes
        -- select pass_through manhole nodes that have one up and one down
        -- line merge pipes that have pass_through at both ends
        -- add pipes that are touching

        with up as (
            select n.id, count(1) as ct, n.geom
            from model1.pipe_link as l join model1.manhole_node as n on n.id=l.up
            where not l.exclude_from_branch
            group by n.id, n.geom
        ),
        down as (
            select n.id, count(1) as ct
            from model1.pipe_link as l join model1.manhole_node as n on n.id=l.down
            where not l.exclude_from_branch
            group by n.id
        ),
        blade as (
            select st_collect(n.geom) as geom
            from model1.manhole_node as n
            where id in (
            select id from model1.manhole_node
            except
            select up.id
            from up join down on up.id=down.id
            where up.ct = 1
            and down.ct = 1)
        ),
        branch as (
            select (st_dump(st_split(st_linemerge(st_collect(l.geom)), b.geom))).geom as geom
            from model1.pipe_link as l, blade as b
            where l.up_type='manhole' and not l.exclude_from_branch
            group by b.geom
        ),
        oriented as (
            select (st_dump(st_linemerge(st_collect(p.geom)))).geom as geom, min(p.id) as min_pipe_id
            from branch as b,  model1.pipe_link as p
            where st_covers(b.geom, p.geom) and not p.exclude_from_branch
            group by b.geom
        )
        insert into model1.branch(id, name, geom)
        select row_number() over w, 'BRANCH_'||(row_number() over w)::varchar, geom
        from oriented
        window w as (order by st_length(geom) asc, min_pipe_id asc)
        ;

        update model1.branch as b set name=m.name, dx=m.dx, pk0_km=m.pk0_km
        from model1.pipe_branch_marker_singularity as m where st_intersects(m.geom, b.geom);

        update model1._pipe_link as p set branch = b.id
        from model1._link as l, model1.branch as b
        where p.id = l.id and st_covers(b.geom, l.geom) and not p.exclude_from_branch;

        return 't';
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="bridge_headloss_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'bridge_headloss', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'bridge_headloss') where name = 'define_later' and id = id_;

            insert into model1._bridge_headloss_singularity(id, singularity_type, l_road, z_road, zw_array, full_section_discharge_for_headloss)
                values (id_, 'bridge_headloss', new.l_road, new.z_road, new.zw_array, coalesce(new.full_section_discharge_for_headloss, 't'));
            if 'bridge_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'bridge_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'bridge_headloss_singularity');
            update model1._singularity set validity = (select (l_road is not null) and (l_road>=0) and (z_road is not null) and (zw_array is not null ) and (array_length(zw_array, 1)<=10) and (array_length(zw_array, 1)>=1) and (array_length(zw_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._bridge_headloss_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.l_road, new.z_road, new.zw_array, new.full_section_discharge_for_headloss) is distinct from (old.l_road, old.z_road, old.zw_array, old.full_section_discharge_for_headloss)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.l_road, old.z_road, old.zw_array, old.full_section_discharge_for_headloss) as o, (select new.l_road, new.z_road, new.zw_array, new.full_section_discharge_for_headloss) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.l_road, new.z_road, new.zw_array, new.full_section_discharge_for_headloss) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._bridge_headloss_singularity set l_road=new.l_road, z_road=new.z_road, zw_array=new.zw_array, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss where id=old.id;
            if 'bridge_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'bridge_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'bridge_headloss_singularity');
            update model1._singularity set validity = (select (l_road is not null) and (l_road>=0) and (z_road is not null) and (zw_array is not null ) and (array_length(zw_array, 1)<=10) and (array_length(zw_array, 1)>=1) and (array_length(zw_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._bridge_headloss_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'bridge_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._bridge_headloss_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'bridge_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="catchment_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        if tg_op = 'INSERT' then
            update model1.catchment_node set contour=new.id where ST_Intersects(model1.catchment_node.geom, new.geom);
            return new;
        else
            if tg_op = 'UPDATE' then
                update model1.catchment_node set contour=null where contour=old.id;
                update model1.catchment_node set contour=new.id where ST_Intersects(model1.catchment_node.geom, new.geom);
                return new;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="catchment_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('catchment', coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'catchment') where name = 'define_later' and id = new.id;
            insert into model1._catchment_node(id, node_type, area_ha, rl, slope, c_imp, netflow_type, constant_runoff, horner_ini_loss_coef, horner_recharge_coef, holtan_sat_inf_rate_mmh, holtan_dry_inf_rate_mmh, holtan_soil_storage_cap_mm, scs_j_mm, scs_soil_drainage_time_day, scs_rfu_mm, hydra_surface_soil_storage_rfu_mm, hydra_inf_rate_f0_mm_hr, hydra_int_soil_storage_j_mm, hydra_soil_drainage_time_qres_day, hydra_split_coefficient, hydra_catchment_connect_coef, hydra_aquifer_infiltration_rate, hydra_soil_infiltration_type, gr4_k1, gr4_k2, gr4_k3, gr4_k4, runoff_type, socose_tc_mn, socose_shape_param_beta, define_k_mn, q_limit, q0, contour, network_type, rural_land_use, industrial_land_use, suburban_housing_land_use, dense_housing_land_use)
                values (new.id, 'catchment', new.area_ha, new.rl, new.slope, new.c_imp, new.netflow_type, new.constant_runoff, new.horner_ini_loss_coef, new.horner_recharge_coef, new.holtan_sat_inf_rate_mmh, new.holtan_dry_inf_rate_mmh, new.holtan_soil_storage_cap_mm, new.scs_j_mm, new.scs_soil_drainage_time_day, new.scs_rfu_mm, new.hydra_surface_soil_storage_rfu_mm, coalesce(new.hydra_inf_rate_f0_mm_hr, 100), coalesce(new.hydra_int_soil_storage_j_mm, 100), new.hydra_soil_drainage_time_qres_day, new.hydra_split_coefficient, coalesce(new.hydra_catchment_connect_coef, 1), coalesce(new.hydra_aquifer_infiltration_rate, 100), new.hydra_soil_infiltration_type, new.gr4_k1, new.gr4_k2, new.gr4_k3, new.gr4_k4, new.runoff_type, new.socose_tc_mn, coalesce(new.socose_shape_param_beta, 4), new.define_k_mn, coalesce(new.q_limit, 9999), coalesce(new.q0, 0), coalesce(new.contour, (select id from model1.catchment where st_intersects(geom, new.geom))), coalesce(new.network_type, 'separative'), new.rural_land_use, new.industrial_land_use, new.suburban_housing_land_use, new.dense_housing_land_use)
                returning area_ha, rl, slope, c_imp, netflow_type, constant_runoff, horner_ini_loss_coef, horner_recharge_coef, holtan_sat_inf_rate_mmh, holtan_dry_inf_rate_mmh, holtan_soil_storage_cap_mm, scs_j_mm, scs_soil_drainage_time_day, scs_rfu_mm, hydra_surface_soil_storage_rfu_mm, hydra_inf_rate_f0_mm_hr, hydra_int_soil_storage_j_mm, hydra_soil_drainage_time_qres_day, hydra_split_coefficient, hydra_catchment_connect_coef, hydra_aquifer_infiltration_rate, hydra_soil_infiltration_type, gr4_k1, gr4_k2, gr4_k3, gr4_k4, runoff_type, socose_tc_mn, socose_shape_param_beta, define_k_mn, q_limit, q0, contour, network_type, rural_land_use, industrial_land_use, suburban_housing_land_use, dense_housing_land_use into new.area_ha, new.rl, new.slope, new.c_imp, new.netflow_type, new.constant_runoff, new.horner_ini_loss_coef, new.horner_recharge_coef, new.holtan_sat_inf_rate_mmh, new.holtan_dry_inf_rate_mmh, new.holtan_soil_storage_cap_mm, new.scs_j_mm, new.scs_soil_drainage_time_day, new.scs_rfu_mm, new.hydra_surface_soil_storage_rfu_mm, new.hydra_inf_rate_f0_mm_hr, new.hydra_int_soil_storage_j_mm, new.hydra_soil_drainage_time_qres_day, new.hydra_split_coefficient, new.hydra_catchment_connect_coef, new.hydra_aquifer_infiltration_rate, new.hydra_soil_infiltration_type, new.gr4_k1, new.gr4_k2, new.gr4_k3, new.gr4_k4, new.runoff_type, new.socose_tc_mn, new.socose_shape_param_beta, new.define_k_mn, new.q_limit, new.q0, new.contour, new.network_type, new.rural_land_use, new.industrial_land_use, new.suburban_housing_land_use, new.dense_housing_land_use;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'catchment_node');

            -- Lines to update specific nodes that works with associated contours
            if 'catchment' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area_ha is not null) and (area_ha>0) and (rl is not null) and (rl>0) and (slope is not null) and (c_imp is not null) and (c_imp>=0) and (c_imp<=1) and (netflow_type is not null) and (netflow_type!='constant_runoff' or (constant_runoff is not null and constant_runoff>=0 and constant_runoff<=1)) and (netflow_type!='horner' or (horner_ini_loss_coef is not null and horner_ini_loss_coef>=0)) and (netflow_type!='horner' or (horner_recharge_coef is not null and horner_recharge_coef>=0)) and (netflow_type!='holtan' or (holtan_sat_inf_rate_mmh is not null and holtan_sat_inf_rate_mmh>=0)) and (netflow_type!='holtan' or (holtan_dry_inf_rate_mmh is not null and holtan_dry_inf_rate_mmh>=0)) and (netflow_type!='holtan' or (holtan_soil_storage_cap_mm is not null and holtan_soil_storage_cap_mm>=0)) and (netflow_type!='scs' or (scs_j_mm is not null and scs_j_mm>=0)) and (netflow_type!='scs' or (scs_soil_drainage_time_day is not null and scs_soil_drainage_time_day>=0)) and (netflow_type!='scs' or (scs_rfu_mm is not null and scs_rfu_mm>=0)) and (netflow_type!='hydra' or (hydra_surface_soil_storage_rfu_mm is not null and hydra_surface_soil_storage_rfu_mm>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_inf_rate_f0_mm_hr is not null and hydra_inf_rate_f0_mm_hr>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_int_soil_storage_j_mm is not null and hydra_int_soil_storage_j_mm>=0)) and (netflow_type!='hydra' or (hydra_soil_drainage_time_qres_day is not null and hydra_soil_drainage_time_qres_day>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='rate' or (hydra_split_coefficient is not null and hydra_split_coefficient>=0 and hydra_split_coefficient<=1)) and (netflow_type!='hydra' or (hydra_catchment_connect_coef is not null and hydra_catchment_connect_coef>=0 and hydra_catchment_connect_coef<=1)) and (netflow_type!='hydra' or (hydra_aquifer_infiltration_rate is not null and hydra_aquifer_infiltration_rate>=0)) and (netflow_type!='gr4' or (gr4_k1 is not null and gr4_k1>=0)) and (netflow_type!='gr4' or (gr4_k2 is not null)) and (netflow_type!='gr4' or (gr4_k3 is not null and gr4_k3>=0)) and (netflow_type!='gr4' or (gr4_k4 is not null and gr4_k4>=0)) and (runoff_type is not null or netflow_type='gr4') and (runoff_type!='Define Tc' or (socose_tc_mn is not null and socose_tc_mn>0) or netflow_type='gr4') and (runoff_type!='Define Tc' or (socose_shape_param_beta is not null and socose_shape_param_beta>=1 and socose_shape_param_beta<=6) or netflow_type='gr4') and (runoff_type!='Define K' or (define_k_mn is not null and define_k_mn>0) or netflow_type='gr4') and (runoff_type!='Desbordes 1 Cr' or (netflow_type='constant_runoff')) and (q_limit is not null) and (q0 is not null) and (network_type is not null) and (rural_land_use is null or rural_land_use>=0) and (industrial_land_use is null or industrial_land_use>=0) and (suburban_housing_land_use is null or suburban_housing_land_use>=0) and (dense_housing_land_use is null or dense_housing_land_use>=0) from  model1._catchment_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area_ha, new.rl, new.slope, new.c_imp, new.netflow_type, new.constant_runoff, new.horner_ini_loss_coef, new.horner_recharge_coef, new.holtan_sat_inf_rate_mmh, new.holtan_dry_inf_rate_mmh, new.holtan_soil_storage_cap_mm, new.scs_j_mm, new.scs_soil_drainage_time_day, new.scs_rfu_mm, new.hydra_surface_soil_storage_rfu_mm, new.hydra_inf_rate_f0_mm_hr, new.hydra_int_soil_storage_j_mm, new.hydra_soil_drainage_time_qres_day, new.hydra_split_coefficient, new.hydra_catchment_connect_coef, new.hydra_aquifer_infiltration_rate, new.hydra_soil_infiltration_type, new.gr4_k1, new.gr4_k2, new.gr4_k3, new.gr4_k4, new.runoff_type, new.socose_tc_mn, new.socose_shape_param_beta, new.define_k_mn, new.q_limit, new.q0, new.contour, new.network_type, new.rural_land_use, new.industrial_land_use, new.suburban_housing_land_use, new.dense_housing_land_use) is distinct from (old.area_ha, old.rl, old.slope, old.c_imp, old.netflow_type, old.constant_runoff, old.horner_ini_loss_coef, old.horner_recharge_coef, old.holtan_sat_inf_rate_mmh, old.holtan_dry_inf_rate_mmh, old.holtan_soil_storage_cap_mm, old.scs_j_mm, old.scs_soil_drainage_time_day, old.scs_rfu_mm, old.hydra_surface_soil_storage_rfu_mm, old.hydra_inf_rate_f0_mm_hr, old.hydra_int_soil_storage_j_mm, old.hydra_soil_drainage_time_qres_day, old.hydra_split_coefficient, old.hydra_catchment_connect_coef, old.hydra_aquifer_infiltration_rate, old.hydra_soil_infiltration_type, old.gr4_k1, old.gr4_k2, old.gr4_k3, old.gr4_k4, old.runoff_type, old.socose_tc_mn, old.socose_shape_param_beta, old.define_k_mn, old.q_limit, old.q0, old.contour, old.network_type, old.rural_land_use, old.industrial_land_use, old.suburban_housing_land_use, old.dense_housing_land_use)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area_ha, old.rl, old.slope, old.c_imp, old.netflow_type, old.constant_runoff, old.horner_ini_loss_coef, old.horner_recharge_coef, old.holtan_sat_inf_rate_mmh, old.holtan_dry_inf_rate_mmh, old.holtan_soil_storage_cap_mm, old.scs_j_mm, old.scs_soil_drainage_time_day, old.scs_rfu_mm, old.hydra_surface_soil_storage_rfu_mm, old.hydra_inf_rate_f0_mm_hr, old.hydra_int_soil_storage_j_mm, old.hydra_soil_drainage_time_qres_day, old.hydra_split_coefficient, old.hydra_catchment_connect_coef, old.hydra_aquifer_infiltration_rate, old.hydra_soil_infiltration_type, old.gr4_k1, old.gr4_k2, old.gr4_k3, old.gr4_k4, old.runoff_type, old.socose_tc_mn, old.socose_shape_param_beta, old.define_k_mn, old.q_limit, old.q0, old.contour, old.network_type, old.rural_land_use, old.industrial_land_use, old.suburban_housing_land_use, old.dense_housing_land_use) as o, (select new.area_ha, new.rl, new.slope, new.c_imp, new.netflow_type, new.constant_runoff, new.horner_ini_loss_coef, new.horner_recharge_coef, new.holtan_sat_inf_rate_mmh, new.holtan_dry_inf_rate_mmh, new.holtan_soil_storage_cap_mm, new.scs_j_mm, new.scs_soil_drainage_time_day, new.scs_rfu_mm, new.hydra_surface_soil_storage_rfu_mm, new.hydra_inf_rate_f0_mm_hr, new.hydra_int_soil_storage_j_mm, new.hydra_soil_drainage_time_qres_day, new.hydra_split_coefficient, new.hydra_catchment_connect_coef, new.hydra_aquifer_infiltration_rate, new.hydra_soil_infiltration_type, new.gr4_k1, new.gr4_k2, new.gr4_k3, new.gr4_k4, new.runoff_type, new.socose_tc_mn, new.socose_shape_param_beta, new.define_k_mn, new.q_limit, new.q0, new.contour, new.network_type, new.rural_land_use, new.industrial_land_use, new.suburban_housing_land_use, new.dense_housing_land_use) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area_ha, new.rl, new.slope, new.c_imp, new.netflow_type, new.constant_runoff, new.horner_ini_loss_coef, new.horner_recharge_coef, new.holtan_sat_inf_rate_mmh, new.holtan_dry_inf_rate_mmh, new.holtan_soil_storage_cap_mm, new.scs_j_mm, new.scs_soil_drainage_time_day, new.scs_rfu_mm, new.hydra_surface_soil_storage_rfu_mm, new.hydra_inf_rate_f0_mm_hr, new.hydra_int_soil_storage_j_mm, new.hydra_soil_drainage_time_qres_day, new.hydra_split_coefficient, new.hydra_catchment_connect_coef, new.hydra_aquifer_infiltration_rate, new.hydra_soil_infiltration_type, new.gr4_k1, new.gr4_k2, new.gr4_k3, new.gr4_k4, new.runoff_type, new.socose_tc_mn, new.socose_shape_param_beta, new.define_k_mn, new.q_limit, new.q0, new.contour, new.network_type, new.rural_land_use, new.industrial_land_use, new.suburban_housing_land_use, new.dense_housing_land_use) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._catchment_node set area_ha=new.area_ha, rl=new.rl, slope=new.slope, c_imp=new.c_imp, netflow_type=new.netflow_type, constant_runoff=new.constant_runoff, horner_ini_loss_coef=new.horner_ini_loss_coef, horner_recharge_coef=new.horner_recharge_coef, holtan_sat_inf_rate_mmh=new.holtan_sat_inf_rate_mmh, holtan_dry_inf_rate_mmh=new.holtan_dry_inf_rate_mmh, holtan_soil_storage_cap_mm=new.holtan_soil_storage_cap_mm, scs_j_mm=new.scs_j_mm, scs_soil_drainage_time_day=new.scs_soil_drainage_time_day, scs_rfu_mm=new.scs_rfu_mm, hydra_surface_soil_storage_rfu_mm=new.hydra_surface_soil_storage_rfu_mm, hydra_inf_rate_f0_mm_hr=new.hydra_inf_rate_f0_mm_hr, hydra_int_soil_storage_j_mm=new.hydra_int_soil_storage_j_mm, hydra_soil_drainage_time_qres_day=new.hydra_soil_drainage_time_qres_day, hydra_split_coefficient=new.hydra_split_coefficient, hydra_catchment_connect_coef=new.hydra_catchment_connect_coef, hydra_aquifer_infiltration_rate=new.hydra_aquifer_infiltration_rate, hydra_soil_infiltration_type=new.hydra_soil_infiltration_type, gr4_k1=new.gr4_k1, gr4_k2=new.gr4_k2, gr4_k3=new.gr4_k3, gr4_k4=new.gr4_k4, runoff_type=new.runoff_type, socose_tc_mn=new.socose_tc_mn, socose_shape_param_beta=new.socose_shape_param_beta, define_k_mn=new.define_k_mn, q_limit=new.q_limit, q0=new.q0, contour=new.contour, network_type=new.network_type, rural_land_use=new.rural_land_use, industrial_land_use=new.industrial_land_use, suburban_housing_land_use=new.suburban_housing_land_use, dense_housing_land_use=new.dense_housing_land_use where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'catchment_node');

            -- Lines to update specific nodes that works with associated contours
            if 'catchment' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'catchment' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'catchment' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area_ha is not null) and (area_ha>0) and (rl is not null) and (rl>0) and (slope is not null) and (c_imp is not null) and (c_imp>=0) and (c_imp<=1) and (netflow_type is not null) and (netflow_type!='constant_runoff' or (constant_runoff is not null and constant_runoff>=0 and constant_runoff<=1)) and (netflow_type!='horner' or (horner_ini_loss_coef is not null and horner_ini_loss_coef>=0)) and (netflow_type!='horner' or (horner_recharge_coef is not null and horner_recharge_coef>=0)) and (netflow_type!='holtan' or (holtan_sat_inf_rate_mmh is not null and holtan_sat_inf_rate_mmh>=0)) and (netflow_type!='holtan' or (holtan_dry_inf_rate_mmh is not null and holtan_dry_inf_rate_mmh>=0)) and (netflow_type!='holtan' or (holtan_soil_storage_cap_mm is not null and holtan_soil_storage_cap_mm>=0)) and (netflow_type!='scs' or (scs_j_mm is not null and scs_j_mm>=0)) and (netflow_type!='scs' or (scs_soil_drainage_time_day is not null and scs_soil_drainage_time_day>=0)) and (netflow_type!='scs' or (scs_rfu_mm is not null and scs_rfu_mm>=0)) and (netflow_type!='hydra' or (hydra_surface_soil_storage_rfu_mm is not null and hydra_surface_soil_storage_rfu_mm>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_inf_rate_f0_mm_hr is not null and hydra_inf_rate_f0_mm_hr>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_int_soil_storage_j_mm is not null and hydra_int_soil_storage_j_mm>=0)) and (netflow_type!='hydra' or (hydra_soil_drainage_time_qres_day is not null and hydra_soil_drainage_time_qres_day>=0)) and (netflow_type!='hydra' or hydra_soil_infiltration_type='rate' or (hydra_split_coefficient is not null and hydra_split_coefficient>=0 and hydra_split_coefficient<=1)) and (netflow_type!='hydra' or (hydra_catchment_connect_coef is not null and hydra_catchment_connect_coef>=0 and hydra_catchment_connect_coef<=1)) and (netflow_type!='hydra' or (hydra_aquifer_infiltration_rate is not null and hydra_aquifer_infiltration_rate>=0)) and (netflow_type!='gr4' or (gr4_k1 is not null and gr4_k1>=0)) and (netflow_type!='gr4' or (gr4_k2 is not null)) and (netflow_type!='gr4' or (gr4_k3 is not null and gr4_k3>=0)) and (netflow_type!='gr4' or (gr4_k4 is not null and gr4_k4>=0)) and (runoff_type is not null or netflow_type='gr4') and (runoff_type!='Define Tc' or (socose_tc_mn is not null and socose_tc_mn>0) or netflow_type='gr4') and (runoff_type!='Define Tc' or (socose_shape_param_beta is not null and socose_shape_param_beta>=1 and socose_shape_param_beta<=6) or netflow_type='gr4') and (runoff_type!='Define K' or (define_k_mn is not null and define_k_mn>0) or netflow_type='gr4') and (runoff_type!='Desbordes 1 Cr' or (netflow_type='constant_runoff')) and (q_limit is not null) and (q0 is not null) and (network_type is not null) and (rural_land_use is null or rural_land_use>=0) and (industrial_land_use is null or industrial_land_use>=0) and (suburban_housing_land_use is null or suburban_housing_land_use>=0) and (dense_housing_land_use is null or dense_housing_land_use>=0) from  model1._catchment_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'catchment' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._catchment_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_catchment_has_one_route_fct()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res boolean;
    begin
        with link as (
            select count(1) as count from model1.catchment_node as bv, model1._link as r
            where bv.id=r.up and r.link_type='routing_hydrology'
            group by r.id)
        select max(count)=min(count) and min(count)=1 from link into res;
        return res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_hydrogramme_apport_on_down_route_fct()" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res boolean;
    begin
        /* apres: routing with hydrograms at down */
        with routing_with_hydrogramme_apport_at_down as (
            select r.id as rid from model1._link as r, model1._hydrograph_bc_singularity as a
            where r.down=a.id and r.link_type='routing_hydrology'
        )
        select count(1)=0 from model1._link as r
        where r.down_type!='manhole_hydrology' and r.link_type='routing_hydrology'
        and r.id not in (select rid from routing_with_hydrogramme_apport_at_down) into res;
        return res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="check_on_branch_or_reach_endpoint(geom geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res_ boolean;
    begin
        with forbidden as (select ST_StartPoint(reach.geom) as point from model1.reach
                               union
                               select ST_EndPoint(reach.geom) as point from model1.reach
                               union
                               select ST_StartPoint(branch.geom) as point from model1.branch
                               union
                               select ST_EndPoint(branch.geom) as point from model1.branch
                               )
        select exists(select 1 from forbidden where ST_Intersects(geom, forbidden.point)) into res_;
        return res_;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="closed_parametric_geometry_before_del_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config record;
    begin
        for config in select name from model1.configuration loop
            update model1._link
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', cp_geom}')::text[], 'null'::jsonb))::json
            where link_type='pipe' and (configuration->config.name->'cp_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', up_cp_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'up_cp_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', down_cp_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'down_cp_geom')::text=old.id::text;
        end loop;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="config_before_delete_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        update model1._node set configuration=null where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)=1;
        update model1._node set configuration=configuration::jsonb-old.name where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)>1;
        update model1._link set configuration=null where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)=1;
        update model1._link set configuration=configuration::jsonb-old.name where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)>1;
        update model1._singularity set configuration=null where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)=1;
        update model1._singularity set configuration=configuration::jsonb-old.name where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)>1;
        update model1._river_cross_section_profile set configuration=null where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)=1;
        update model1._river_cross_section_profile set configuration=configuration::jsonb-old.name where configuration is not null and array_length(array((select json_object_keys((configuration::jsonb-old.name)::json))),1)>1;

        delete from project.config_scenario where model='model1' and configuration=old.id;
        delete from project.config_serie where model='model1' and configuration=old.id;

        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="config_rename_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        update model1._node set configuration=(configuration::jsonb - old.name || jsonb_build_object(new.name, (configuration->old.name)))::json where configuration is not null and configuration::jsonb ? old.name;
        update model1._link set configuration=(configuration::jsonb - old.name || jsonb_build_object(new.name, (configuration->old.name)))::json where configuration is not null and configuration::jsonb ? old.name;
        update model1._singularity set configuration=(configuration::jsonb - old.name || jsonb_build_object(new.name, (configuration->old.name)))::json where configuration is not null and configuration::jsonb ? old.name;
        update model1._river_cross_section_profile set configuration=(configuration::jsonb - old.name || jsonb_build_object(new.name, (configuration->old.name)))::json where configuration is not null and configuration::jsonb ? old.name;
        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="connector_hydrology_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'connector_hydrology' = 'routing_hydrology' or 'connector_hydrology' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('connector_hydrology', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'connector_hydrology') where name = 'define_later' and id = id_;
            insert into model1._connector_hydrology_link(id, link_type, hydrograph)
                values (id_, 'connector_hydrology', coalesce(new.hydrograph, (select hbc.id from model1.hydrograph_bc_singularity as hbc where ST_DWithin(ST_EndPoint(new.geom), hbc.geom, .1))));
            if 'connector_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'connector_hydrology_link');
            update model1._link set validity = (select (down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'storage', 'crossroad', 'elem_2d') and (hydrograph is not null))) from  model1._connector_hydrology_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'connector_hydrology' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if (('no_column') is distinct from ('no_column')) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') as o, (select 'no_column') as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._connector_hydrology_link set hydrograph=new.hydrograph where id=old.id;

            if 'connector_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'connector_hydrology_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'connector_hydrology' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'storage', 'crossroad', 'elem_2d') and (hydrograph is not null))) from  model1._connector_hydrology_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._connector_hydrology_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'connector_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'connector_hydrology' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="connector_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'connector' = 'routing_hydrology' or 'connector' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('connector', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'connector') where name = 'define_later' and id = id_;
            insert into model1._connector_link(id, link_type, main_branch, border)
                values (id_, 'connector', coalesce(new.main_branch, 'f'), new.border);
            if 'connector' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'connector_link');
            update model1._link set validity = (select 't'::boolean from  model1._connector_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'connector' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.main_branch) is distinct from (old.main_branch)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.main_branch) as o, (select new.main_branch) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.main_branch) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._connector_link set main_branch=new.main_branch, border=new.border where id=old.id;

            if 'connector' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'connector_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'connector' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select 't'::boolean from  model1._connector_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._connector_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'connector' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'connector' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="constant_inflow_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'constant_inflow_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'constant_inflow_bc') where name = 'define_later' and id = id_;

            insert into model1._constant_inflow_bc_singularity(id, singularity_type, q0)
                values (id_, 'constant_inflow_bc', new.q0);
            if 'constant_inflow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'constant_inflow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'constant_inflow_bc_singularity');
            update model1._singularity set validity = (select (q0 is not null) from  model1._constant_inflow_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.q0) is distinct from (old.q0)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.q0) as o, (select new.q0) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.q0) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._constant_inflow_bc_singularity set q0=new.q0 where id=old.id;
            if 'constant_inflow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'constant_inflow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'constant_inflow_bc_singularity');
            update model1._singularity set validity = (select (q0 is not null) from  model1._constant_inflow_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'constant_inflow_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._constant_inflow_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'constant_inflow_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="constrain_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        cov integer;
    begin
        if (select trigger_coverage from model1.metadata) then
            select model1.coverage_update() into cov;
        end if;

        if tg_op = 'INSERT' or tg_op = 'UPDATE'  then
            return new;
        else
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="constrain_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        prec_ real;
        snapped_ geometry;
        other_cst_ geometry;
        differenced_ geometry;
        oned_ geometry;
        discretized_ geometry;
    begin
        select precision from hydra.metadata into prec_;
        if tg_op = 'INSERT' then
            select st_snaptogrid(new.geom, prec_) into snapped_;
            if new.constrain_type != 'ignored_for_coverages' then
                select ST_Linemerge(ST_Collect(geom)) from model1._constrain where ST_Intersects(snapped_, geom) and constrain_type != 'ignored_for_coverages' into other_cst_;
                select ST_LineMerge(coalesce(ST_Difference(snapped_, other_cst_), snapped_)) into differenced_;
            else
                select snapped_ into differenced_;
            end if;
            if not ST_IsEmpty(differenced_) then
                select ST_GeometryN(differenced_, 1) into oned_;
                select st_snaptogrid(project.discretize_line(oned_, coalesce(new.elem_length, 100)), prec_) into discretized_;
                if not (select St_IsEmpty(st_snaptogrid(new.geom, prec_))) then
                    insert into model1._constrain(name, geom, discretized, elem_length, constrain_type, link_attributes, points_xyz, points_xyz_proximity, line_xyz, comment)
                    values (coalesce(new.name, 'define_later'), oned_, discretized_, coalesce(new.elem_length, 100), new.constrain_type, new.link_attributes, new.points_xyz, coalesce(new.points_xyz_proximity, 1), new.line_xyz, new.comment)
                    returning id, elem_length, points_xyz, points_xyz_proximity into new.id, new.elem_length, new.points_xyz, new.points_xyz_proximity ;
                    update model1._constrain set name = 'CONSTR'||new.id::varchar where name = 'define_later' and id = new.id
                    returning name into new.name;
                    return new;
                end if;
                return null;
            end if;
            return null;
        elsif tg_op = 'UPDATE' then
            select st_snaptogrid(new.geom, prec_) into snapped_;
            if new.constrain_type != 'ignored_for_coverages' then
                select ST_Linemerge(ST_Collect(geom)) from model1._constrain where ST_Intersects(snapped_, geom) and id!=old.id and constrain_type != 'ignored_for_coverages' into other_cst_;
                select ST_LineMerge(coalesce(ST_Difference(snapped_, other_cst_), snapped_)) into differenced_;
            else
                select snapped_ into differenced_;
            end if;
            if not ST_IsEmpty(differenced_) then
                select ST_GeometryN(differenced_, 1) into oned_;
                select st_snaptogrid(project.discretize_line(differenced_, coalesce(new.elem_length, 100)), prec_) into discretized_;
                update model1._constrain set name=new.name, geom=differenced_, discretized=discretized_,
                    elem_length=new.elem_length, constrain_type=new.constrain_type, link_attributes=new.link_attributes,
                    points_xyz=new.points_xyz, points_xyz_proximity=coalesce(new.points_xyz_proximity, 1),
                    line_xyz=new.line_xyz, comment=new.comment
                    where id = old.id;
                return new;
            end if;
            return old;
        elsif tg_op = 'DELETE' then
            delete from model1._constrain where id=old.id;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="coverage_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        if tg_op = 'INSERT' then
            update model1.storage_node set
                contour=new.id
                where ST_Intersects(model1.storage_node.geom, new.geom);
            return new;
        else
            if tg_op = 'UPDATE' then
                update model1.storage_node set contour=null where contour=old.id;

                update model1.storage_node set
                    contour=new.id
                    where ST_Intersects(model1.storage_node.geom, new.geom);
                    return new;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="coverage_update()" returnType="integer" securityType="DEFINER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res_ integer;
    begin
        delete from model1.coverage ; -- where domain_2d is null;
        alter sequence model1.coverage_id_seq restart;

        with cst as (
            select ST_Node(ST_Collect(a.discretized)) as geom
            from model1.constrain as a
            where a.constrain_type is distinct from 'ignored_for_coverages'
            )
        insert into model1.coverage(geom, domain_type) select (st_dump(st_polygonize(geom))).geom, '2d' from cst;

        with oned as (
            select c.id
            from model1.coverage as c, model1.street as d
            where ST_Intersects(c.geom, d.geom)
            group by c.id
        )
        update model1.coverage set domain_type='street' where id in (select oned.id from oned);

        update model1.coverage as c set domain_type='reach'
        where exists (select 1 from model1.open_reach as r
        where ST_Intersects(c.geom, r.geom)
        and ST_Length(ST_CollectionExtract(ST_Intersection(c.geom, r.geom), 2)) > 0);

        with oned as (
            select distinct c.id
            from model1.coverage as c, model1.storage_node as d
            where ST_Intersects(c.geom, d.geom)
        )
        update model1.coverage set domain_type='storage' where id in (select oned.id from oned);

        with oned as (
            select c.id, count(1) as ct
            from model1.coverage as c, model1.coverage_marker as mkc
            where ST_Intersects(c.geom, mkc.geom)
            group by c.id
        )
        update model1.coverage set domain_type=null where id in (select oned.id from oned where ct=1);

        select count(*) from model1.coverage into res_;
        return res_;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="cp_geometric_calc_p_fct(real[])" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[select model1.op_geometric_calc_p_fct($1) + $1[array_length($1, 1)][2];]]></definition>
         <parameters>
            <parameter mode="IN" type="real[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_boundary_links(up_type character varying, up_id integer, station_node_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import create_boundary_links
    return create_boundary_links(plpy, up_type, up_id, station_node_id, 'model1', 2154)]]></definition>
         <parameters>
            <parameter mode="IN" name="up_type" type="character varying"/>
            <parameter mode="IN" name="up_id" type="integer"/>
            <parameter mode="IN" name="station_node_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_elem2d_links(elem_id integer, border geometry, generation_step integer DEFAULT NULL::integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import create_elem2d_links
    return create_elem2d_links(plpy, elem_id, border, 'model1', 2154, generation_step)]]></definition>
         <parameters>
            <parameter mode="IN" name="elem_id" type="integer"/>
            <parameter mode="IN" name="border" type="geometry"/>
            <parameter mode="IN" name="generation_step" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_links(up_domain_id integer, down_domain_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import create_links
    return create_links(plpy, up_domain_id, down_domain_id, 'model1', 2154)]]></definition>
         <parameters>
            <parameter mode="IN" name="up_domain_id" type="integer"/>
            <parameter mode="IN" name="down_domain_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_network_overflow_links(domain_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import create_network_overflow_links
    return create_network_overflow_links(plpy, domain_id, 'model1', 2154)]]></definition>
         <parameters>
            <parameter mode="IN" name="domain_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="create_river_cross_section_from_line_xyz(candidate_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    res integer;
    z_invert real;
    top timestamp;
begin
    top := clock_timestamp();

    insert into model1.constrain(name, line_xyz, geom, constrain_type)
    select name, line_xyz, geom, constrain_type
    from model1.flood_plain_transect_candidate t
    where t.id = candidate_id and not exists (select 1 from model1.constrain c where c.name=t.name)
    ;

    select min(st_z(p.geom))
    from model1.flood_plain_transect_candidate t
    join lateral st_dumppoints(t.topo) p on true
    where t.id = candidate_id
    into z_invert
    ;

    insert into model1.valley_cross_section_geometry(name, zbmin_array, zbmaj_lbank_array, zbmaj_rbank_array, transect, sz_array)
    select t.name, ('{{'||z_invert||', 0}}')::real[], ('{{'||z_invert||', 0}}')::real[], ('{{'||z_invert||', 0}}')::real[],
        c.id, array_agg(ARRAY[st_linelocatepoint(t.geom, p.geom)*st_length(t.geom), st_z(p.geom)] order by p.path)
    from model1.flood_plain_transect_candidate t
    join model1.constrain c on c.name = t.name
    join lateral st_dumppoints(c.topo) p on true
    where t.id = candidate_id and not exists (select 1 from model1.valley_cross_section_geometry g where g.name=t.name)
    group by t.name, c.id
    ;

    -- create river nodes where needed
    insert into model1.river_node(name, geom)
    select distinct t.name, t.reach_intersection
    from model1.flood_plain_transect_candidate t
    where t.id = candidate_id and not exists (select 1 from model1.river_node n where st_dwithin(t.reach_intersection, n.geom, 1.))
    ;

    insert into model1._river_cross_section_profile(name, id, type_cross_section_up, type_cross_section_down, down_vcs_geom, z_invert_down)
    select t.name, (select n.id from model1.river_node n order by n.geom <-> t.reach_intersection limit 1) id, null, 'valley', g.id down_vcs_geom, z_invert
    from model1.flood_plain_transect_candidate t
    join model1.valley_cross_section_geometry g on g.name = t.name
    where not exists (select 1 from model1.river_cross_section_profile p where st_dwithin(t.reach_intersection, p.geom, 1.))
    and t.id = candidate_id
    returning id into res
    ;

    return res;
end;]]></definition>
         <parameters>
            <parameter mode="IN" name="candidate_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="crossroad_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('crossroad', coalesce(new.name, 'define_later'), (ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.z_ground, project.altitude(new.geom))), 2154)), new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'crossroad') where name = 'define_later' and id = new.id;
            insert into model1._crossroad_node(id, node_type, area, z_ground, h)
                values (new.id, 'crossroad', coalesce(new.area, 1), coalesce(new.z_ground, (select project.altitude(new.geom))), coalesce(new.h, 0))
                returning area, z_ground, h into new.area, new.z_ground, new.h;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'crossroad_node');

            -- Lines to update specific nodes that works with associated contours
            if 'crossroad' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and ((area > 0)) and (z_ground is not null) and (h is not null) and (h>=0) from  model1._crossroad_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.z_ground, new.h) is distinct from (old.area, old.z_ground, old.h)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.z_ground, old.h) as o, (select new.area, new.z_ground, new.h) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.z_ground, new.h) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=(ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.z_ground, project.altitude(new.geom))), 2154)), generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._crossroad_node set area=new.area, z_ground=new.z_ground, h=new.h where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'crossroad_node');

            -- Lines to update specific nodes that works with associated contours
            if 'crossroad' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'crossroad' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'crossroad' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and ((area > 0)) and (z_ground is not null) and (h is not null) and (h>=0) from  model1._crossroad_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'crossroad' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._crossroad_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="crossroad_update()" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res_ integer;
    begin
        with nodes as (
            insert into model1.crossroad_node(geom)
                (select distinct s.geom
                    from (
                        select (st_dumppoints(geom)).geom
                        from model1.street
                            union
                        select (st_dumppoints(st_intersection(s1.geom, s2.geom))).geom as geom
                        from model1.street as s1, model1.street as s2
                        where ST_intersects(s1.geom,s2.geom)
                        and s1.id<s2.id
                    ) as s
                    join hydra.metadata m on true
                    left join (select st_force2d(geom) as geom from model1.crossroad_node) as c
                    on st_dwithin(s.geom, c.geom, m.precision)
                    where c.geom is null)
            returning id
        )
        select count(1) from nodes into res_;
        return res_;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ctrz_dat()" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import ctrz_dat
    return ctrz_dat(plpy, 'model1')]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="deriv_pump_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'deriv_pump' = 'routing_hydrology' or 'deriv_pump' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('deriv_pump', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'deriv_pump') where name = 'define_later' and id = id_;
            insert into model1._deriv_pump_link(id, link_type, q_pump, qz_array)
                values (id_, 'deriv_pump', new.q_pump, new.qz_array);
            if 'deriv_pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'deriv_pump_link');
            update model1._link set validity = (select (q_pump is not null) and (q_pump>= 0) and (qz_array is not null) and (array_length(qz_array, 1)<=10) and (array_length(qz_array, 1)>=1) and (array_length(qz_array, 2)=2) and ((/*   qz_array: 0<=q   */ select bool_and(bool) from (select 0<=unnest(new.qz_array[:][1]) as bool) as data_set)) and ((/*   qz_array: q<=1   */ select bool_and(bool) from (select unnest(new.qz_array[:][1])<=1 as bool) as data_set)) from  model1._deriv_pump_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'deriv_pump' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.q_pump, new.qz_array) is distinct from (old.q_pump, old.qz_array)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.q_pump, old.qz_array) as o, (select new.q_pump, new.qz_array) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.q_pump, new.qz_array) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._deriv_pump_link set q_pump=new.q_pump, qz_array=new.qz_array where id=old.id;

            if 'deriv_pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'deriv_pump_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'deriv_pump' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (q_pump is not null) and (q_pump>= 0) and (qz_array is not null) and (array_length(qz_array, 1)<=10) and (array_length(qz_array, 1)>=1) and (array_length(qz_array, 2)=2) and ((/*   qz_array: 0<=q   */ select bool_and(bool) from (select 0<=unnest(new.qz_array[:][1]) as bool) as data_set)) and ((/*   qz_array: q<=1   */ select bool_and(bool) from (select unnest(new.qz_array[:][1])<=1 as bool) as data_set)) from  model1._deriv_pump_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._deriv_pump_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'deriv_pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'deriv_pump' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="downstream_valley_section(transect geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        return (
        with reach as (
            select r.id, st_intersection(r.geom, transect) as inter, geom, pk0_km
            from model1.reach as r
            where st_intersects(r.geom, transect)
        ),
        pk as (
            select st_linelocatepoint(geom, inter)*st_length(geom)/1000+pk0_km as pk_km from reach
        ),
        down_reach as (
            select ndown.reach as id
            from model1.river_node as ndown
            join model1.connector_link as l on l.down=ndown.id
            join model1.river_node as nup on nup.id=l.up
            where l.main_branch
            and nup.reach = (select id from reach)
        ),
        extended_reach_node as (
            select n.id, n.pk_km
            from model1.river_node as n, pk
            where n.reach in (select id from reach union select id from down_reach)
            and n.pk_km >= pk.pk_km
        ),
        section_down as (
            select c.id
            from extended_reach_node as n
            join model1.river_cross_section_profile as c on c.id = n.id,
            pk
            where ((c.type_cross_section_down='valley' and c.down_vcs_geom is not null)
                or (c.type_cross_section_up='valley' and c.up_vcs_geom is not null))
            order by n.pk_km asc
            limit 1
        )
        select id from section_down);
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="transect" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="elem_2d_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('elem_2d', coalesce(new.name, 'define_later'), (ST_SnapToGrid(ST_SetSRID(ST_MakePoint(ST_X(ST_Centroid(new.contour)), ST_Y(ST_Centroid(new.contour)), coalesce(new.zb, project.altitude(ST_Centroid(new.contour)))), 2154), (select precision from hydra.metadata))), new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'elem_2d') where name = 'define_later' and id = new.id;
            insert into model1._elem_2d_node(id, node_type, area, zb, rk, domain_2d, contour)
                values (new.id, 'elem_2d', coalesce(new.area, ST_Area(new.contour)), coalesce(new.zb, (select project.altitude(ST_Centroid(new.contour)))), coalesce(new.rk, 12), new.domain_2d, new.contour)
                returning area, zb, rk, domain_2d, contour into new.area, new.zb, new.rk, new.domain_2d, new.contour;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'elem_2d_node');

            -- Lines to update specific nodes that works with associated contours
            if 'elem_2d' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and (area>0) and (zb is not null) and (rk is not null) and (rk>0) from  model1._elem_2d_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.zb, new.rk) is distinct from (old.area, old.zb, old.rk)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.zb, old.rk) as o, (select new.area, new.zb, new.rk) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.zb, new.rk) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=(ST_SnapToGrid(ST_SetSRID(ST_MakePoint(ST_X(ST_Centroid(new.contour)), ST_Y(ST_Centroid(new.contour)), coalesce(new.zb, project.altitude(ST_Centroid(new.contour)))), 2154), (select precision from hydra.metadata))), generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._elem_2d_node set area=new.area, zb=new.zb, rk=new.rk, domain_2d=new.domain_2d, contour=new.contour where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'elem_2d_node');

            -- Lines to update specific nodes that works with associated contours
            if 'elem_2d' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'elem_2d' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'elem_2d' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and (area>0) and (zb is not null) and (rk is not null) and (rk>0) from  model1._elem_2d_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'elem_2d' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._elem_2d_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="find_link_fct(geom_ geometry, OUT up_ integer, OUT up_type_ hydra_node_type, OUT down_ integer, OUT down_type_ hydra_node_type)" returnType="record" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        select id, node_type from model1._node
        where ST_DWithin(ST_StartPoint(geom_), geom, .1)
        order by ST_Distance(ST_StartPoint(geom_), geom) asc
        limit 1 into up_, up_type_
        ;
        select id, node_type from model1._node
        where ST_DWithin(ST_EndPoint(geom_), geom, .1)
        order by ST_Distance(ST_EndPoint(geom_), geom) asc
        limit 1 into down_, down_type_
        ;
        if (up_ is null) then
            -- find link from contours
            with node as (
                select s.id, 'storage' as node_type, c.geom as contour from model1._storage_node as s, model1.coverage as c where c.id=s.contour
                union
                select id, 'elem_2d' as node_type, contour from model1._elem_2d_node
            )
            select id, node_type from node
            where ST_Intersects(ST_StartPoint(geom_), contour)
            order by ST_Distance(ST_StartPoint(geom_), ST_Centroid(contour)) asc
            limit 1 into up_, up_type_
            ;
        end if;
        if (down_ is null) then
            -- find link from contours
            with node as (
                select s.id, 'storage' as node_type, c.geom as contour from model1._storage_node as s, model1.coverage as c where c.id=s.contour
                union
                select id, 'elem_2d' as node_type, contour from model1._elem_2d_node
            )
            select id, node_type from node
            where ST_Intersects(ST_EndPoint(geom_), contour)
            order by ST_Distance(ST_EndPoint(geom_), ST_Centroid(contour)) asc
            limit 1 into down_, down_type_
            ;
        end if;

        if (up_ is null or down_ is null) then
            raise exception 'link % not touching nodes (distance from start % distance from end %)', ST_AsText(geom_), (select ST_Distance(ST_StartPoint(geom_), geom) from model1._node order by ST_Distance(ST_StartPoint(geom_), geom) limit 1), (select ST_Distance(ST_EndPoint(geom_), geom) from model1._node order by ST_Distance(ST_EndPoint(geom_), geom) limit 1);
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="geom_" type="geometry"/>
            <parameter mode="OUT" name="up_" type="integer"/>
            <parameter mode="OUT" name="up_type_" type="hydra_node_type"/>
            <parameter mode="OUT" name="down_" type="integer"/>
            <parameter mode="OUT" name="down_type_" type="hydra_node_type"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="find_minimal_hydrology_network(node_array integer[])" returnType="integer[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        temp_array integer ARRAY;
    begin
	select model1.find_nodes_network(node_array) into temp_array;
	while temp_array != node_array loop
		select model1.find_nodes_network(node_array) into node_array;
		select model1.find_nodes_network(temp_array) into temp_array;
	end loop;
	return temp_array;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="node_array" type="integer[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="find_nodes_network(node_array integer[])" returnType="integer[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        up_node integer;
        down_node integer;
        result_array integer array;
    begin
        for up_node in select unnest(node_array)
        loop
            with link as (
            select id from model1._link where up = up_node)
            select l.down into down_node from model1._link as l, link where l.id = link.id;
            if (select exists(select 1 from model1.manhole_hydrology_node where id = down_node)) then
                select array_append(result_array, down_node) into result_array;
            end if;
        end loop;
        select array_cat(result_array, node_array) into result_array;
        select array(select distinct unnest(result_array) order by 1) into result_array;

        return result_array;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="node_array" type="integer[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="froude_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'froude_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'froude_bc') where name = 'define_later' and id = id_;

            insert into model1._froude_bc_singularity(id, singularity_type)
                values (id_, 'froude_bc');
            if 'froude_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'froude_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'froude_bc_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._froude_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if (('no_column') is distinct from ('no_column')) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') as o, (select 'no_column') as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            --update model1._froude_bc_singularity set  where id=old.id;
            if 'froude_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'froude_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'froude_bc_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._froude_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'froude_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._froude_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'froude_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="fuse_spillway_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'fuse_spillway' = 'routing_hydrology' or 'fuse_spillway' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('fuse_spillway', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'fuse_spillway') where name = 'define_later' and id = id_;
            insert into model1._fuse_spillway_link(id, link_type, z_invert, width, cc, break_mode, z_break, t_break, grp, dt_fracw_array)
                values (id_, 'fuse_spillway', new.z_invert, new.width, coalesce(new.cc, .6), coalesce(new.break_mode, 'none'), new.z_break, new.t_break, coalesce(new.grp, 1), new.dt_fracw_array);
            if 'fuse_spillway' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'fuse_spillway_link');
            update model1._link set validity = (select (z_invert is not null) and (width is not null) and (width>=0.) and (cc is not null) and (cc<=1) and (cc>=0.) and (break_mode is not null) and (break_mode!='zw_critical' or z_break is not null) and (break_mode!='time_critical' or t_break is not null) and (break_mode='none' or grp is not null) and (break_mode='none' or grp>0) and (break_mode='none' or grp<100) and (break_mode='none' or dt_fracw_array is not null) and (break_mode='none' or array_length(dt_fracw_array, 1)<=10) and (break_mode='none' or array_length(dt_fracw_array, 1)>=1) and (break_mode='none' or array_length(dt_fracw_array, 2)=2) from  model1._fuse_spillway_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'fuse_spillway' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.width, new.cc, new.break_mode, new.z_break, new.t_break, new.grp, new.dt_fracw_array) is distinct from (old.z_invert, old.width, old.cc, old.break_mode, old.z_break, old.t_break, old.grp, old.dt_fracw_array)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.width, old.cc, old.break_mode, old.z_break, old.t_break, old.grp, old.dt_fracw_array) as o, (select new.z_invert, new.width, new.cc, new.break_mode, new.z_break, new.t_break, new.grp, new.dt_fracw_array) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.width, new.cc, new.break_mode, new.z_break, new.t_break, new.grp, new.dt_fracw_array) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._fuse_spillway_link set z_invert=new.z_invert, width=new.width, cc=new.cc, break_mode=new.break_mode, z_break=new.z_break, t_break=new.t_break, grp=new.grp, dt_fracw_array=new.dt_fracw_array where id=old.id;

            if 'fuse_spillway' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'fuse_spillway_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'fuse_spillway' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null) and (width is not null) and (width>=0.) and (cc is not null) and (cc<=1) and (cc>=0.) and (break_mode is not null) and (break_mode!='zw_critical' or z_break is not null) and (break_mode!='time_critical' or t_break is not null) and (break_mode='none' or grp is not null) and (break_mode='none' or grp>0) and (break_mode='none' or grp<100) and (break_mode='none' or dt_fracw_array is not null) and (break_mode='none' or array_length(dt_fracw_array, 1)<=10) and (break_mode='none' or array_length(dt_fracw_array, 1)>=1) and (break_mode='none' or array_length(dt_fracw_array, 2)=2) from  model1._fuse_spillway_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._fuse_spillway_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'fuse_spillway' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'fuse_spillway' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gate_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'gate' = 'routing_hydrology' or 'gate' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('gate', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'gate') where name = 'define_later' and id = id_;
            insert into model1._gate_link(id, link_type, z_invert, z_ceiling, width, cc, action_gate_type, mode_valve, z_gate, v_max_cms, cc_submerged)
                values (id_, 'gate', new.z_invert, new.z_ceiling, new.width, coalesce(new.cc, .6), coalesce(new.action_gate_type, 'upward_opening'), coalesce(new.mode_valve, 'no_valve'), coalesce(new.z_gate, new.z_ceiling), coalesce(new.v_max_cms, .2), new.cc_submerged);
            if 'gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'gate_link');
            update model1._link set validity = (select (z_invert is not null) and (z_ceiling is not null) and (z_ceiling>z_invert) and (width is not null) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (mode_valve is not null) and (z_gate is not null) and (z_gate>=z_invert) and (z_gate<=z_ceiling) and (v_max_cms is not null) and (cc_submerged >0) from  model1._gate_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'gate' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.cc_submerged) is distinct from (old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.mode_valve, old.z_gate, old.v_max_cms, old.cc_submerged)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.mode_valve, old.z_gate, old.v_max_cms, old.cc_submerged) as o, (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.cc_submerged) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.cc_submerged) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._gate_link set z_invert=new.z_invert, z_ceiling=new.z_ceiling, width=new.width, cc=new.cc, action_gate_type=new.action_gate_type, mode_valve=new.mode_valve, z_gate=new.z_gate, v_max_cms=new.v_max_cms, cc_submerged=new.cc_submerged where id=old.id;

            if 'gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'gate_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'gate' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null) and (z_ceiling is not null) and (z_ceiling>z_invert) and (width is not null) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (mode_valve is not null) and (z_gate is not null) and (z_gate>=z_invert) and (z_gate<=z_ceiling) and (v_max_cms is not null) and (cc_submerged >0) from  model1._gate_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._gate_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'gate' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gate_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'gate', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'gate') where name = 'define_later' and id = id_;

            insert into model1._gate_singularity(id, singularity_type, z_invert, z_ceiling, width, cc, action_gate_type, mode_valve, z_gate, v_max_cms, full_section_discharge_for_headloss, cc_submerged)
                values (id_, 'gate', new.z_invert, new.z_ceiling, new.width, coalesce(new.cc, .6), coalesce(new.action_gate_type, 'upward_opening'), coalesce(new.mode_valve, 'no_valve'), coalesce(new.z_gate, new.z_ceiling), coalesce(new.v_max_cms, .2), coalesce(new.full_section_discharge_for_headloss, 't'), new.cc_submerged);
            if 'gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'gate_singularity');
            update model1._singularity set validity = (select (z_invert is not null) and (z_ceiling is not null) and (z_ceiling>z_invert) and (width is not null) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (mode_valve is not null) and (z_gate is not null) and (z_gate>=z_invert) and (z_gate<=z_ceiling) and (v_max_cms is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) and (cc_submerged >0) from  model1._gate_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.full_section_discharge_for_headloss, new.cc_submerged) is distinct from (old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.mode_valve, old.z_gate, old.v_max_cms, old.full_section_discharge_for_headloss, old.cc_submerged)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.mode_valve, old.z_gate, old.v_max_cms, old.full_section_discharge_for_headloss, old.cc_submerged) as o, (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.full_section_discharge_for_headloss, new.cc_submerged) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.mode_valve, new.z_gate, new.v_max_cms, new.full_section_discharge_for_headloss, new.cc_submerged) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._gate_singularity set z_invert=new.z_invert, z_ceiling=new.z_ceiling, width=new.width, cc=new.cc, action_gate_type=new.action_gate_type, mode_valve=new.mode_valve, z_gate=new.z_gate, v_max_cms=new.v_max_cms, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss, cc_submerged=new.cc_submerged where id=old.id;
            if 'gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'gate_singularity');
            update model1._singularity set validity = (select (z_invert is not null) and (z_ceiling is not null) and (z_ceiling>z_invert) and (width is not null) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (mode_valve is not null) and (z_gate is not null) and (z_gate>=z_invert) and (z_gate<=z_ceiling) and (v_max_cms is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) and (cc_submerged >0) from  model1._gate_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._gate_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="gen_cst_street(street_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _street_geom geometry;
        _street_width real;
        _street_el real;
        _trigger_state boolean;
    begin
        select geom, width, elem_length
        from model1.street
        where id=street_id
        into _street_geom, _street_width, _street_el;

        select trigger_coverage from model1.metadata into _trigger_state;
        update model1.metadata set trigger_coverage = 'f';

        with buf as (
                -- select ST_Buffer(ST_Force2d(_street_geom), _street_width/2, 'quad_segs=1 join=mitre mitre_limit='||(_street_width*2)::varchar) as geom
                -- workaroud for postgis 3
                select ST_Union(
                    ST_Difference(st_buffer(_street_geom, _street_width/2, 'quad_segs=1'), st_buffer(_street_geom, _street_width/2, 'quad_segs=1 endcap=flat')), st_buffer(_street_geom, _street_width/2, 'join=mitre endcap=flat mitre_limit='||(_street_width*2)::varchar)) as geom
            ),
            cst as (
                select ST_ExteriorRing(geom) as geom from buf
            ),
            spl as (
                select coalesce(ST_Split(cst.geom, (select ST_Collect(ST_Force2d(c.geom))
                                                    from model1.constrain as c
                                                    where ST_Intersects(c.geom, cst.geom) and c.constrain_type is distinct from 'ignored_for_coverages')
                                                    ), cst.geom) as geom
                from cst
            ),
            spld as (
                select ST_Force3d((st_dump(geom)).geom) as geom from spl
            ),
            diff as (
                select id, (ST_Dump(ST_CollectionExtract(ST_Split(c.geom, b.geom), 2))).geom as geom
                from model1.constrain as c, cst as b
                where ST_Intersects(b.geom, c.geom)
                and c.constrain_type is distinct from 'ignored_for_coverages'
            ),
            ins as (
                insert into model1.constrain(geom, elem_length, constrain_type)
                select d.geom, c.elem_length, c.constrain_type
                from model1.constrain as c, diff as d
                where c.id = d.id
                union
                select geom, _street_el, 'overflow'
                from spld
                returning id
            )
        delete from model1.constrain
        where id in (select id from diff);

        with cst_brut as (
                select a.id, (ST_Dump(coalesce(ST_Split(a.discretized,
                    (select ST_Collect(discretized) from model1.constrain as b
                        where a.id!=b.id
                        and ST_Intersects(a.discretized, b.discretized)
                        and b.constrain_type is distinct from 'ignored_for_coverages'
                        and ST_Dimension(ST_Intersection(a.discretized, b.discretized))=0)
                    ),
                a.discretized))).geom as geom
                from model1.constrain as a
                where a.constrain_type is distinct from 'ignored_for_coverages'
            ),
            cst as (
                select id, ST_Union(geom) over (partition by id) as geom from cst_brut
            ),
            polyg as (
                select (ST_Dump(ST_Polygonize(cst_brut.geom))).geom as geom from cst_brut
            ),
            inter as (
                select p.geom from polyg as p, model1.street as s
                where ST_Intersects(p.geom, s.geom)
            ),
            un as (
                select ST_Union(i.geom) as geom from inter as i
            ),
            boundary as (
                select ST_Boundary(u.geom) as geom from un as u
            ),
            to_del as (
                select id from cst as c
                where (select ST_Dimension(ST_Intersection(c.geom, b.geom))=0 from boundary as b)
                and (select ST_Contains(u.geom, c.geom) from un as u)
            )
            delete from model1.constrain as c
            where exists (select 1 from to_del as d where d.id=c.id limit 1)
            and not exists (select 1 from model1.valley_cross_section_geometry where transect=c.id limit 1)
            and c.constrain_type is distinct from 'ignored_for_coverages'
            and c.constrain_type is not null;


        if _trigger_state then
            perform model1.coverage_update();
        end if;

        update model1.metadata set trigger_coverage = _trigger_state;

        return 1;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="street_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="geom_dat(type_ character varying, id integer)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import geom_dat
    return geom_dat(plpy, 'model1', type_, id)]]></definition>
         <parameters>
            <parameter mode="IN" name="type_" type="character varying"/>
            <parameter mode="IN" name="id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="geometric_calc_s_fct(real[])" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        z_array alias for $1;
        x real[];
        s double precision := 0.0;
        last_h double precision := 0.0;
        last_w double precision := 0.0;
    begin
        foreach x slice 1 in array z_array
        loop
            s:=s+0.5*(x[2]+last_w)*(x[1]-last_h);
            last_h:=x[1];
            last_w:=x[2];
        end loop;
        return s;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" type="real[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hydraulic_cut_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'hydraulic_cut', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'hydraulic_cut') where name = 'define_later' and id = id_;

            insert into model1._hydraulic_cut_singularity(id, singularity_type, qz_array, full_section_discharge_for_headloss)
                values (id_, 'hydraulic_cut', new.qz_array, coalesce(new.full_section_discharge_for_headloss, 't'));
            if 'hydraulic_cut' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydraulic_cut' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'hydraulic_cut_singularity');
            update model1._singularity set validity = (select (qz_array is not null) and (array_length(qz_array, 1)<=10) and (array_length(qz_array, 1)>=1) and (array_length(qz_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._hydraulic_cut_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.qz_array, new.full_section_discharge_for_headloss) is distinct from (old.qz_array, old.full_section_discharge_for_headloss)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.qz_array, old.full_section_discharge_for_headloss) as o, (select new.qz_array, new.full_section_discharge_for_headloss) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.qz_array, new.full_section_discharge_for_headloss) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._hydraulic_cut_singularity set qz_array=new.qz_array, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss where id=old.id;
            if 'hydraulic_cut' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydraulic_cut' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'hydraulic_cut_singularity');
            update model1._singularity set validity = (select (qz_array is not null) and (array_length(qz_array, 1)<=10) and (array_length(qz_array, 1)>=1) and (array_length(qz_array, 2)=2) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._hydraulic_cut_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'hydraulic_cut' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._hydraulic_cut_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'hydraulic_cut' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hydrograph_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'hydrograph_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'hydrograph_bc') where name = 'define_later' and id = id_;

            insert into model1._hydrograph_bc_singularity(id, singularity_type, storage_area, tq_array, constant_dry_flow, distrib_coef, lag_time_hr, sector, hourly_modulation, pollution_dryweather_runoff, quality_dryweather_runoff, external_file_data)
                values (id_, 'hydrograph_bc', coalesce(new.storage_area, 1), coalesce(new.tq_array, '{{0, 0}}'::real[]), coalesce(new.constant_dry_flow, 0), coalesce(new.distrib_coef, 1), coalesce(new.lag_time_hr, 0), new.sector, new.hourly_modulation, coalesce(new.pollution_dryweather_runoff, '{{0, 0, 0, 0},{0, 0, 0, 0}}'::real[]), coalesce(new.quality_dryweather_runoff, '{{0, 0, 0, 0, 0, 0, 0, 0, 0},{0, 0, 0, 0, 0, 0, 0, 0, 0}}'::real[]), coalesce(new.external_file_data, 'f'));
            if 'hydrograph_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydrograph_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'hydrograph_bc_singularity');
            update model1._singularity set validity = (select (storage_area is not null) and (storage_area>=0) and (constant_dry_flow is not null) and (constant_dry_flow>=0) and (distrib_coef is null or distrib_coef>=0) and (lag_time_hr is null or (lag_time_hr>=0)) and (sector is null or (distrib_coef is not null and lag_time_hr is not null)) and (array_length(pollution_dryweather_runoff, 1)=2) and (array_length(pollution_dryweather_runoff, 2)=4) and (array_length(quality_dryweather_runoff, 1)=2) and (array_length(quality_dryweather_runoff, 2)=9) and (external_file_data or tq_array is not null) and (external_file_data or array_length(tq_array, 1)<=10) and (external_file_data or array_length(tq_array, 1)>=1) and (external_file_data or array_length(tq_array, 2)=2) from  model1._hydrograph_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.storage_area, new.tq_array, new.constant_dry_flow, new.distrib_coef, new.lag_time_hr, new.hourly_modulation, new.pollution_dryweather_runoff, new.quality_dryweather_runoff, new.external_file_data) is distinct from (old.storage_area, old.tq_array, old.constant_dry_flow, old.distrib_coef, old.lag_time_hr, old.hourly_modulation, old.pollution_dryweather_runoff, old.quality_dryweather_runoff, old.external_file_data)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.storage_area, old.tq_array, old.constant_dry_flow, old.distrib_coef, old.lag_time_hr, old.hourly_modulation, old.pollution_dryweather_runoff, old.quality_dryweather_runoff, old.external_file_data) as o, (select new.storage_area, new.tq_array, new.constant_dry_flow, new.distrib_coef, new.lag_time_hr, new.hourly_modulation, new.pollution_dryweather_runoff, new.quality_dryweather_runoff, new.external_file_data) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.storage_area, new.tq_array, new.constant_dry_flow, new.distrib_coef, new.lag_time_hr, new.hourly_modulation, new.pollution_dryweather_runoff, new.quality_dryweather_runoff, new.external_file_data) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._hydrograph_bc_singularity set storage_area=new.storage_area, tq_array=new.tq_array, constant_dry_flow=new.constant_dry_flow, distrib_coef=new.distrib_coef, lag_time_hr=new.lag_time_hr, sector=new.sector, hourly_modulation=new.hourly_modulation, pollution_dryweather_runoff=new.pollution_dryweather_runoff, quality_dryweather_runoff=new.quality_dryweather_runoff, external_file_data=new.external_file_data where id=old.id;
            if 'hydrograph_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydrograph_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'hydrograph_bc_singularity');
            update model1._singularity set validity = (select (storage_area is not null) and (storage_area>=0) and (constant_dry_flow is not null) and (constant_dry_flow>=0) and (distrib_coef is null or distrib_coef>=0) and (lag_time_hr is null or (lag_time_hr>=0)) and (sector is null or (distrib_coef is not null and lag_time_hr is not null)) and (array_length(pollution_dryweather_runoff, 1)=2) and (array_length(pollution_dryweather_runoff, 2)=4) and (array_length(quality_dryweather_runoff, 1)=2) and (array_length(quality_dryweather_runoff, 2)=9) and (external_file_data or tq_array is not null) and (external_file_data or array_length(tq_array, 1)<=10) and (external_file_data or array_length(tq_array, 1)>=1) and (external_file_data or array_length(tq_array, 2)=2) from  model1._hydrograph_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'hydrograph_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._hydrograph_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'hydrograph_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="hydrology_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'hydrology_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'hydrology_bc') where name = 'define_later' and id = id_;

            insert into model1._hydrology_bc_singularity(id, singularity_type)
                values (id_, 'hydrology_bc');
            if 'hydrology_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydrology_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'hydrology_bc_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._hydrology_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if (('no_column') is distinct from ('no_column')) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') as o, (select 'no_column') as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            --update model1._hydrology_bc_singularity set  where id=old.id;
            if 'hydrology_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'hydrology_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'hydrology_bc_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._hydrology_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'hydrology_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._hydrology_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'hydrology_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="inter_pave_border_fct(up integer, down integer, OUT out_ geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        with border as (
            select ST_CollectionHomogenize(
                ST_Intersection(n1.contour, n2.contour)) as geom, 0.5*(ST_Z(n1.geom) + ST_Z(n2.geom)) as z
            from model1.elem_2d_node as n1, model1.elem_2d_node as n2
            where n1.id=up and n2.id=down
        )
        select ST_SetSRID(ST_MakeLine(
                ST_MakePoint(ST_X(ST_StartPoint(geom)), ST_Y(ST_StartPoint(geom)), z),
                ST_MakePoint(ST_X(ST_EndPoint(geom)), ST_Y(ST_EndPoint(geom)), z)), 2154)
        from border into out_;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="up" type="integer"/>
            <parameter mode="IN" name="down" type="integer"/>
            <parameter mode="OUT" name="out_" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="inter_pave_symbol_fct(up integer, down integer, OUT out_ geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
       pstart_ geometry('POINTZ',2154);
       pend_ geometry('POINTZ',2154);
       tx_ real;
       ty_ real;
    begin
       select geom from model1._node where id=up into pstart_;
       select geom from model1._node where id=down into pend_;
       select .1*(ST_X(pend_)-ST_X(pstart_)), .1*(ST_Y(pend_)-ST_Y(pstart_)) into tx_, ty_;
       with p1 as (select (ST_DumpPoints(contour)).geom::geometry as geom from model1._elem_2d_node where id=up),
       p2 as (select (ST_DumpPoints(contour)).geom::geometry as geom from model1._elem_2d_node where id=down),
       p1_ as (select distinct geom from p1),
       p2_ as (select distinct geom from p2),
       pairs as (select ST_Collect(p1_.geom, p2_.geom) as geom from p1_, p2_ order by ST_Distance(p1_.geom, p2_.geom) limit 2),
       line as (select ST_Collect(geom) as geom from pairs),
       symb as (select ST_Centroid(geom) as geom from line)
       select ST_SetSRID(ST_MakeLine(ST_MakePoint(ST_X(geom)-tx_, ST_Y(geom)-ty_, ST_Z(pstart_)), ST_MakePoint(ST_X(geom)+tx_, ST_Y(geom)+ty_, ST_Z(pend_))), 2154) from symb into out_;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="up" type="integer"/>
            <parameter mode="IN" name="down" type="integer"/>
            <parameter mode="OUT" name="out_" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="interpolate_transect_at(point geometry, coverage_id integer DEFAULT NULL::integer)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        l_ real;
        coverage geometry;
        reach geometry;
        res geometry;
        left_transects geometry;
        right_transects geometry;
        closest geometry;
        direction vector2;
        other_direction vector2;
        other_side geometry;
        side varchar;
    begin
        l_ := 10000;

        --raise notice 'point %', point;
        select ST_CollectionHomogenize(ST_Collect(ST_MakeLine(array[ST_StartPoint(discretized), ST_ClosestPoint(discretized, reach), ST_EndPoint(discretized)])))
        from model1.constrain
        where constrain_type='flood_plain_transect'
        and ST_Intersects(discretized, point)
        and constrain_type is distinct from 'ignored_for_coverages'
        into res;

        if ST_GeometryType(res) = 'ST_LineString' then
            return (
                select ST_MakeLine(array[ST_StartPoint(res), ST_ClosestPoint(r.geom, res), ST_EndPoint(res)])
                from model1.reach r
                order by r.geom <-> res
                limit 1
            );
        end if;

        -- closest coverage or specified one
        select coalesce(
            (select geom from model1.coverage where id=coverage_id),
            (select geom from model1.coverage where domain_type='reach' order by geom <-> point limit 1)
        ) into coverage;

        if not ST_DWithin(coverage, point, .1) then
            raise 'point % is not close enought to nearest coverage %', point, coverage ;
        end if;

        -- closest reach in coverage
        select geom from model1.reach where ST_Intersects(geom, coverage) order by geom <-> point limit 1 into reach;

        if reach is null then
            raise 'no reach in reach coverage %', coverage ;
        end if;

        with pt as (
            select ST_StartPoint(t.geom) as s, ST_ClosestPoint(t.geom, reach) as m, ST_EndPoint(t.geom) as e
            from model1.constrain as t
            where ST_Intersects(coverage, t.discretized)
            and t.constrain_type='flood_plain_transect'
            and ST_Length(ST_CollectionExtract(ST_Intersection(t.discretized, coverage), 2)) > 0
            order by ST_Distance(geom, reach)
            limit 2
        )
        select ST_Collect(ST_MakeLine(s, m)), ST_Collect(ST_MakeLine(e, m))
        from pt
        into left_transects, right_transects;

        if ST_NumGeometries(left_transects) = 0 then
            return ST_MakeLine(point, ST_ClosestPoint(reach, point));
        end if;

        select ST_ClosestPoint(reach, point) into closest;
        if dot(difference(ST_EndPoint(ST_GeometryN(right_transects,1)), ST_StartPoint(ST_GeometryN(right_transects,1))), difference(closest, point)) > 0 then
            side := 'right';
        else
            side := 'left';
        end if;

        if ST_NumGeometries(left_transects) = 1 then
            if side = 'right' then
                direction := difference(ST_EndPoint(ST_GeometryN(right_transects,1)), ST_StartPoint(ST_GeometryN(right_transects,1)));
            else
                direction := difference(ST_EndPoint(ST_GeometryN(left_transects,1)), ST_StartPoint(ST_GeometryN(left_transects,1)));
            end if;
            other_direction := direction;
        else
            if side = 'right' then
                direction := interpolate_direction( ST_GeometryN(right_transects,1), ST_GeometryN(right_transects,2), point);
            else
                direction := interpolate_direction( ST_GeometryN(left_transects,1), ST_GeometryN(left_transects,2), point);
            end if;
        end if;

        closest := coalesce(ST_ClosestPoint(ST_Intersection(ST_MakeLine(point, ST_Translate(point, l_*direction.x, l_*direction.y)), reach), point), closest);
        --raise notice 'point % closest %', point, closest;

        if ST_NumGeometries(left_transects) = 1 then
            other_direction := row(-direction.x, -direction.y)::vector2;
        else
            if side = 'right' then
                other_direction := interpolate_direction( ST_GeometryN(left_transects,1), ST_GeometryN(left_transects,2), closest);
            else
                other_direction := interpolate_direction( ST_GeometryN(right_transects,1), ST_GeometryN(right_transects,2), closest);
            end if;
        end if;

        other_side := ST_ClosestPoint(ST_Intersection(ST_MakeLine(closest, ST_Translate(closest, -l_*other_direction.x, -l_*other_direction.y)), ST_ExteriorRing(coverage)), closest);

        if side = 'right' then
            return ST_MakeLine(array[other_side, closest, point]);
        else
            return ST_MakeLine(array[point, closest, other_side]);
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="point" type="geometry"/>
            <parameter mode="IN" name="coverage_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="jet_fan_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'jet_fan' = 'routing_hydrology' or 'jet_fan' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('jet_fan', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'jet_fan') where name = 'define_later' and id = id_;
            insert into model1._jet_fan_link(id, link_type, unit_thrust_newton, number_of_units, efficiency, flow_velocity, pipe_area, is_up_to_down)
                values (id_, 'jet_fan', coalesce(new.unit_thrust_newton, 1), coalesce(new.number_of_units, 1), coalesce(new.efficiency, .08), coalesce(new.flow_velocity, 30), new.pipe_area, coalesce(new.is_up_to_down, true));
            if 'jet_fan' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'jet_fan_link');
            update model1._link set validity = (select (unit_thrust_newton > 0) and (number_of_units > 0) and (efficiency > 0) and (efficiency <= 1) and (flow_velocity > 0) and (pipe_area > 0) and (is_up_to_down is not null) from  model1._jet_fan_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'jet_fan' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.unit_thrust_newton, new.number_of_units, new.efficiency, new.flow_velocity, new.pipe_area, new.is_up_to_down) is distinct from (old.unit_thrust_newton, old.number_of_units, old.efficiency, old.flow_velocity, old.pipe_area, old.is_up_to_down)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.unit_thrust_newton, old.number_of_units, old.efficiency, old.flow_velocity, old.pipe_area, old.is_up_to_down) as o, (select new.unit_thrust_newton, new.number_of_units, new.efficiency, new.flow_velocity, new.pipe_area, new.is_up_to_down) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.unit_thrust_newton, new.number_of_units, new.efficiency, new.flow_velocity, new.pipe_area, new.is_up_to_down) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._jet_fan_link set unit_thrust_newton=new.unit_thrust_newton, number_of_units=new.number_of_units, efficiency=new.efficiency, flow_velocity=new.flow_velocity, pipe_area=new.pipe_area, is_up_to_down=new.is_up_to_down where id=old.id;

            if 'jet_fan' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'jet_fan_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'jet_fan' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (unit_thrust_newton > 0) and (number_of_units > 0) and (efficiency > 0) and (efficiency <= 1) and (flow_velocity > 0) and (pipe_area > 0) and (is_up_to_down is not null) from  model1._jet_fan_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._jet_fan_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'jet_fan' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'jet_fan' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="line_set_z(line geometry, z_up real, z_down real)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        geom geometry('LINESTRINGZ', 2154);
    begin
        with d as (select (ST_DumpPoints(line)).geom as geom),
        p as (select ST_X(d.geom) as x, ST_Y(d.geom) as y,
            ST_LineLocatePoint(line, d.geom) as a
            from d),
        i as (select x, y, (1-a)*z_up + a*z_down as z, a from p)
        select ST_SetSRID(ST_MakeLine(ST_MakePoint(x, y, z) order by a), 2154) as geom from i into geom;
        return geom;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="line" type="geometry"/>
            <parameter mode="IN" name="z_up" type="real"/>
            <parameter mode="IN" name="z_down" type="real"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="link_invalidity_reason(id_ integer)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
            reason varchar;
        begin
            reason := '';
            if not (select z_invert_up is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   z_invert_up is not null   ';
               end if;

if not (select z_invert_down is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   z_invert_down is not null   ';
               end if;

if not (select area > 0 from model1.air_duct_link as new where id=id_) then
               reason := reason || '   area > 0   ';
               end if;

if not (select perimeter > 0 from model1.air_duct_link as new where id=id_) then
               reason := reason || '   perimeter > 0   ';
               end if;

if not (select friction_coefficient > 0 from model1.air_duct_link as new where id=id_) then
               reason := reason || '   friction_coefficient > 0   ';
               end if;

if not (select up is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.air_duct_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select area > 0 from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   area > 0   ';
               end if;

if not (select up_to_down_headloss_coefficient > 0 from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   up_to_down_headloss_coefficient > 0   ';
               end if;

if not (select down_to_up_headloss_coefficient > 0 from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   down_to_up_headloss_coefficient > 0   ';
               end if;

if not (select up is not null from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.air_headloss_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select array_length(q_dp_array, 1) <= 10 from model1.ventilator_link as new where id=id_) then
               reason := reason || '   array_length(q_dp_array, 1) <= 10   ';
               end if;

if not (select array_length(q_dp_array, 2) <= 2 from model1.ventilator_link as new where id=id_) then
               reason := reason || '   array_length(q_dp_array, 2) <= 2   ';
               end if;

if not (select q_dp_array[1][2]=0 from model1.ventilator_link as new where id=id_) then
               reason := reason || '   q_dp_array[1][2]=0   ';
               end if;

if not (select q_dp_array[array_length(q_dp_array, 1)][1]=0 from model1.ventilator_link as new where id=id_) then
               reason := reason || '   q_dp_array[array_length(q_dp_array, 1)][1]=0   ';
               end if;

if not (select is_up_to_down is not null from model1.ventilator_link as new where id=id_) then
               reason := reason || '   is_up_to_down is not null   ';
               end if;

if not (select up is not null from model1.ventilator_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.ventilator_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.ventilator_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.ventilator_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select unit_thrust_newton > 0 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   unit_thrust_newton > 0   ';
               end if;

if not (select number_of_units > 0 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   number_of_units > 0   ';
               end if;

if not (select efficiency > 0 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   efficiency > 0   ';
               end if;

if not (select efficiency <= 1 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   efficiency <= 1   ';
               end if;

if not (select flow_velocity > 0 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   flow_velocity > 0   ';
               end if;

if not (select pipe_area > 0 from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   pipe_area > 0   ';
               end if;

if not (select is_up_to_down is not null from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   is_up_to_down is not null   ';
               end if;

if not (select up is not null from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.jet_fan_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select z_ceiling is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   z_ceiling is not null   ';
               end if;

if not (select width is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select cc is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   cc>=0   ';
               end if;

if not (select action_gate_type is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   action_gate_type is not null   ';
               end if;

if not (select z_invert_stop is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   z_invert_stop is not null   ';
               end if;

if not (select z_ceiling_stop is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   z_ceiling_stop is not null   ';
               end if;

if not (select v_max_cms is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   v_max_cms is not null   ';
               end if;

if not (select v_max_cms>=0 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   v_max_cms>=0   ';
               end if;

if not (select dt_regul_hr is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   dt_regul_hr is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_control_node is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_control_node is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_pid_array is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_pid_array is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_tz_array is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_tz_array is not null   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 1)<=10 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 1)<=10   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 1)>=1 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 1)>=1   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 2)=2 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 2)=2   ';
               end if;

if not (select mode_regul!='discharge' or q_z_crit is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or q_z_crit is not null   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 1)<=10 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 1)<=10   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 1)>=1 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 1)>=1   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 2)=2 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 2)=2   ';
               end if;

if not (select mode_regul!='no_regulation' or nr_z_gate is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''no_regulation'' or nr_z_gate is not null   ';
               end if;

if not (select mode_regul!='relief' or h_open is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''relief'' or h_open is not null   ';
               end if;

if not (select mode_regul!='relief' or h_close is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''relief'' or h_close is not null   ';
               end if;

if not (select mode_regul!='head' or h_open is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''head'' or h_open is not null   ';
               end if;

if not (select mode_regul!='head' or h_close is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''head'' or h_close is not null   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 1)<=10 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 1)<=10   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 1)>=1 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 1)>=1   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 2)=2 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 2)=2   ';
               end if;

if not (select cc_submerged >0 from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   cc_submerged >0   ';
               end if;

if not (select up is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.regul_gate_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select width is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0. from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   width>=0.   ';
               end if;

if not (select cc is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0. from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   cc>=0.   ';
               end if;

if not (select break_mode is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode is not null   ';
               end if;

if not (select break_mode!='zw_critical' or z_break is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode!=''zw_critical'' or z_break is not null   ';
               end if;

if not (select break_mode!='time_critical' or t_break is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode!=''time_critical'' or t_break is not null   ';
               end if;

if not (select break_mode='none' or grp is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp is not null   ';
               end if;

if not (select break_mode='none' or grp>0 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp>0   ';
               end if;

if not (select break_mode='none' or grp<100 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp<100   ';
               end if;

if not (select break_mode='none' or dt_fracw_array is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or dt_fracw_array is not null   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 1)<=10 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 1)<=10   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 1)>=1 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 1)>=1   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 2)=2 from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 2)=2   ';
               end if;

if not (select up is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.fuse_spillway_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert_up is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   z_invert_up is not null   ';
               end if;

if not (select z_invert_down is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   z_invert_down is not null   ';
               end if;

if not (select h_sable is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   h_sable is not null   ';
               end if;

if not (select cross_section_type is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type is not null   ';
               end if;

if not (select cross_section_type not in ('valley') from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type not in (''valley'')   ';
               end if;

if not (select rk is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   rk is not null   ';
               end if;

if not (select rk >0 from model1.pipe_link as new where id=id_) then
               reason := reason || '   rk >0   ';
               end if;

if not (select cross_section_type!='circular' or (circular_diameter is not null and circular_diameter > 0) from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''circular'' or (circular_diameter is not null and circular_diameter > 0)   ';
               end if;

if not (select cross_section_type!='ovoid' or (ovoid_top_diameter is not null and ovoid_top_diameter > 0) from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''ovoid'' or (ovoid_top_diameter is not null and ovoid_top_diameter > 0)   ';
               end if;

if not (select cross_section_type!='ovoid' or (ovoid_invert_diameter is not null and ovoid_invert_diameter > 0) from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''ovoid'' or (ovoid_invert_diameter is not null and ovoid_invert_diameter > 0)   ';
               end if;

if not (select cross_section_type!='ovoid' or (ovoid_height is not null and ovoid_height >0 ) from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''ovoid'' or (ovoid_height is not null and ovoid_height >0 )   ';
               end if;

if not (select cross_section_type!='ovoid' or (ovoid_height > (ovoid_top_diameter+ovoid_invert_diameter)/2) from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''ovoid'' or (ovoid_height > (ovoid_top_diameter+ovoid_invert_diameter)/2)   ';
               end if;

if not (select cross_section_type!='pipe' or cp_geom is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''pipe'' or cp_geom is not null   ';
               end if;

if not (select cross_section_type!='channel' or op_geom is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   cross_section_type!=''channel'' or op_geom is not null   ';
               end if;

if not (select rk_maj is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   rk_maj is not null   ';
               end if;

if not (select rk_maj >=0 from model1.pipe_link as new where id=id_) then
               reason := reason || '   rk_maj >=0   ';
               end if;

if not (select up is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.pipe_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select cross_section is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   cross_section is not null   ';
               end if;

if not (select cross_section>=0 from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   cross_section>=0   ';
               end if;

if not (select length is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   length is not null   ';
               end if;

if not (select length>=0 from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   length>=0   ';
               end if;

if not (select slope is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   slope is not null   ';
               end if;

if not (select down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'crossroad', 'storage', 'elem_2d') and (hydrograph is not null)) from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   down_type=''manhole_hydrology'' or (down_type in (''manhole'', ''river'', ''station'', ''crossroad'', ''storage'', ''elem_2d'') and (hydrograph is not null))   ';
               end if;

if not (select split_coef is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   split_coef is not null   ';
               end if;

if not (select split_coef>=0 from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   split_coef>=0   ';
               end if;

if not (select up is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.routing_hydrology_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select q_pump is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   q_pump is not null   ';
               end if;

if not (select q_pump>= 0 from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   q_pump>= 0   ';
               end if;

if not (select qz_array is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   qz_array is not null   ';
               end if;

if not (select array_length(qz_array, 1)<=10 from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   array_length(qz_array, 1)<=10   ';
               end if;

if not (select array_length(qz_array, 1)>=1 from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   array_length(qz_array, 1)>=1   ';
               end if;

if not (select array_length(qz_array, 2)=2 from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   array_length(qz_array, 2)=2   ';
               end if;

if not (select (/*   qz_array: 0<=q   */ select bool_and(bool) from (select 0<=unnest(new.qz_array[:][1]) as bool) as data_set) from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   (/*   qz_array: 0<=q   */ select bool_and(bool) from (select 0<=unnest(new.qz_array[:][1]) as bool) as data_set)   ';
               end if;

if not (select (/*   qz_array: q<=1   */ select bool_and(bool) from (select unnest(new.qz_array[:][1])<=1 as bool) as data_set) from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   (/*   qz_array: q<=1   */ select bool_and(bool) from (select unnest(new.qz_array[:][1])<=1 as bool) as data_set)   ';
               end if;

if not (select up is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.deriv_pump_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select width is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.porous_link as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select transmitivity is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   transmitivity is not null   ';
               end if;

if not (select transmitivity>=0 from model1.porous_link as new where id=id_) then
               reason := reason || '   transmitivity>=0   ';
               end if;

if not (select up is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.porous_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null  from model1.weir_link as new where id=id_) then
               reason := reason || '   z_invert is not null    ';
               end if;

if not (select width is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.weir_link as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select cc is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.weir_link as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0 from model1.weir_link as new where id=id_) then
               reason := reason || '   cc>=0   ';
               end if;

if not (select v_max_cms is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   v_max_cms is not null   ';
               end if;

if not (select v_max_cms>=0 from model1.weir_link as new where id=id_) then
               reason := reason || '   v_max_cms>=0   ';
               end if;

if not (select up is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.weir_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select law_type is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   law_type is not null   ';
               end if;

if not (select param is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   param is not null   ';
               end if;

if not (select up is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.borda_headloss_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select npump is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   npump is not null   ';
               end if;

if not (select npump<=10 from model1.pump_link as new where id=id_) then
               reason := reason || '   npump<=10   ';
               end if;

if not (select npump>=1 from model1.pump_link as new where id=id_) then
               reason := reason || '   npump>=1   ';
               end if;

if not (select zregul_array is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   zregul_array is not null   ';
               end if;

if not (select hq_array is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   hq_array is not null   ';
               end if;

if not (select array_length(zregul_array, 1)=npump from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(zregul_array, 1)=npump   ';
               end if;

if not (select array_length(zregul_array, 2)=2 from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(zregul_array, 2)=2   ';
               end if;

if not (select array_length(hq_array, 1)=npump from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(hq_array, 1)=npump   ';
               end if;

if not (select array_length(hq_array, 2)<=10 from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(hq_array, 2)<=10   ';
               end if;

if not (select array_length(hq_array, 2)>=1 from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(hq_array, 2)>=1   ';
               end if;

if not (select array_length(hq_array, 3)=2 from model1.pump_link as new where id=id_) then
               reason := reason || '   array_length(hq_array, 3)=2   ';
               end if;

if not (select up is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.pump_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select lateral_contraction_coef is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef is not null   ';
               end if;

if not (select lateral_contraction_coef<=1 from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef<=1   ';
               end if;

if not (select lateral_contraction_coef>=0 from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef>=0   ';
               end if;

if not (select ST_NPoints(border)=2 from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   ST_NPoints(border)=2   ';
               end if;

if not (select ST_IsValid(border) from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   ST_IsValid(border)   ';
               end if;

if not (select up is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.mesh_2d_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_crest1 is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   z_crest1 is not null   ';
               end if;

if not (select width1 is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   width1 is not null   ';
               end if;

if not (select width1>=0 from model1.overflow_link as new where id=id_) then
               reason := reason || '   width1>=0   ';
               end if;

if not (select z_crest2 is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   z_crest2 is not null   ';
               end if;

if not (select z_crest2>=z_crest1 from model1.overflow_link as new where id=id_) then
               reason := reason || '   z_crest2>=z_crest1   ';
               end if;

if not (select width2 is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   width2 is not null   ';
               end if;

if not (select width2>=0 from model1.overflow_link as new where id=id_) then
               reason := reason || '   width2>=0   ';
               end if;

if not (select cc is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.overflow_link as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0 from model1.overflow_link as new where id=id_) then
               reason := reason || '   cc>=0   ';
               end if;

if not (select lateral_contraction_coef is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef is not null   ';
               end if;

if not (select lateral_contraction_coef<=1 from model1.overflow_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef<=1   ';
               end if;

if not (select lateral_contraction_coef>=0 from model1.overflow_link as new where id=id_) then
               reason := reason || '   lateral_contraction_coef>=0   ';
               end if;

if not (select break_mode is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode is not null   ';
               end if;

if not (select break_mode!='zw_critical' or z_break is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode!=''zw_critical'' or z_break is not null   ';
               end if;

if not (select break_mode!='time_critical' or t_break is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode!=''time_critical'' or t_break is not null   ';
               end if;

if not (select break_mode='none' or width_breach is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or width_breach is not null   ';
               end if;

if not (select break_mode='none' or z_invert is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or z_invert is not null   ';
               end if;

if not (select break_mode='none' or grp is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp is not null   ';
               end if;

if not (select break_mode='none' or grp>0 from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp>0   ';
               end if;

if not (select break_mode='none' or grp<100 from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or grp<100   ';
               end if;

if not (select break_mode='none' or dt_fracw_array is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or dt_fracw_array is not null   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 1)<=10 from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 1)<=10   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 1)>=1 from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 1)>=1   ';
               end if;

if not (select break_mode='none' or array_length(dt_fracw_array, 2)=2 from model1.overflow_link as new where id=id_) then
               reason := reason || '   break_mode=''none'' or array_length(dt_fracw_array, 2)=2   ';
               end if;

if not (select up is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.overflow_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_overflow is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   z_overflow is not null   ';
               end if;

if not (select area is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select area>=0 from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   area>=0   ';
               end if;

if not (select up is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.network_overflow_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_invert is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select z_ceiling is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   z_ceiling is not null   ';
               end if;

if not (select z_ceiling>z_invert from model1.gate_link as new where id=id_) then
               reason := reason || '   z_ceiling>z_invert   ';
               end if;

if not (select width is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select cc is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc <=1 from model1.gate_link as new where id=id_) then
               reason := reason || '   cc <=1   ';
               end if;

if not (select cc >=0 from model1.gate_link as new where id=id_) then
               reason := reason || '   cc >=0   ';
               end if;

if not (select action_gate_type is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   action_gate_type is not null   ';
               end if;

if not (select mode_valve is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   mode_valve is not null   ';
               end if;

if not (select z_gate is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   z_gate is not null   ';
               end if;

if not (select z_gate>=z_invert from model1.gate_link as new where id=id_) then
               reason := reason || '   z_gate>=z_invert   ';
               end if;

if not (select z_gate<=z_ceiling from model1.gate_link as new where id=id_) then
               reason := reason || '   z_gate<=z_ceiling   ';
               end if;

if not (select v_max_cms is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   v_max_cms is not null   ';
               end if;

if not (select cc_submerged >0 from model1.gate_link as new where id=id_) then
               reason := reason || '   cc_submerged >0   ';
               end if;

if not (select up is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.gate_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'storage', 'crossroad', 'elem_2d') and (hydrograph is not null)) from model1.connector_hydrology_link as new where id=id_) then
               reason := reason || '   down_type=''manhole_hydrology'' or (down_type in (''manhole'', ''river'', ''station'', ''storage'', ''crossroad'', ''elem_2d'') and (hydrograph is not null))   ';
               end if;

if not (select up is not null from model1.connector_hydrology_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.connector_hydrology_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.connector_hydrology_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.connector_hydrology_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;

if not (select z_crest1 is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   z_crest1 is not null   ';
               end if;

if not (select width1 is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   width1 is not null   ';
               end if;

if not (select width1>0 from model1.strickler_link as new where id=id_) then
               reason := reason || '   width1>0   ';
               end if;

if not (select length is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   length is not null   ';
               end if;

if not (select length>0 from model1.strickler_link as new where id=id_) then
               reason := reason || '   length>0   ';
               end if;

if not (select rk is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   rk is not null   ';
               end if;

if not (select rk>=0 from model1.strickler_link as new where id=id_) then
               reason := reason || '   rk>=0   ';
               end if;

if not (select z_crest2 is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   z_crest2 is not null   ';
               end if;

if not (select z_crest2>z_crest1 from model1.strickler_link as new where id=id_) then
               reason := reason || '   z_crest2>z_crest1   ';
               end if;

if not (select width2 is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   width2 is not null   ';
               end if;

if not (select width2>width1 from model1.strickler_link as new where id=id_) then
               reason := reason || '   width2>width1   ';
               end if;

if not (select up is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   up is not null   ';
               end if;

if not (select down is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   down is not null   ';
               end if;

if not (select up_type is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   up_type is not null   ';
               end if;

if not (select down_type is not null from model1.strickler_link as new where id=id_) then
               reason := reason || '   down_type is not null   ';
               end if;
            return reason;
        end;]]></definition>
         <parameters>
            <parameter mode="IN" name="id_" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="manhole_hydrology_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('manhole_hydrology', coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'manhole_hydrology') where name = 'define_later' and id = new.id;
            insert into model1._manhole_hydrology_node(id, node_type, area, z_ground)
                values (new.id, 'manhole_hydrology', coalesce(new.area, 1), coalesce(new.z_ground, (select project.altitude(new.geom))))
                returning area, z_ground into new.area, new.z_ground;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'manhole_hydrology_node');

            -- Lines to update specific nodes that works with associated contours
            if 'manhole_hydrology' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and ((area > 0)) and (z_ground is not null) from  model1._manhole_hydrology_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.z_ground) is distinct from (old.area, old.z_ground)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.z_ground) as o, (select new.area, new.z_ground) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.z_ground) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._manhole_hydrology_node set area=new.area, z_ground=new.z_ground where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'manhole_hydrology_node');

            -- Lines to update specific nodes that works with associated contours
            if 'manhole_hydrology' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'manhole_hydrology' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'manhole_hydrology' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and ((area > 0)) and (z_ground is not null) from  model1._manhole_hydrology_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'manhole_hydrology' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._manhole_hydrology_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="manhole_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('manhole', coalesce(new.name, 'define_later'), (ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.z_ground, project.altitude(new.geom))), 2154)), new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'manhole') where name = 'define_later' and id = new.id;
            insert into model1._manhole_node(id, node_type, area, z_ground, cover_diameter, cover_critical_pressure, inlet_width, inlet_height, connection_law)
                values (new.id, 'manhole', coalesce(new.area, 1), coalesce(new.z_ground, (select project.altitude(new.geom))), coalesce(new.cover_diameter, 0.6), coalesce(new.cover_critical_pressure, 2.0), coalesce(new.inlet_width, 1.0), coalesce(new.inlet_height, 0.25), coalesce(new.connection_law, 'manhole_cover'))
                returning area, z_ground, cover_diameter, cover_critical_pressure, inlet_width, inlet_height, connection_law into new.area, new.z_ground, new.cover_diameter, new.cover_critical_pressure, new.inlet_width, new.inlet_height, new.connection_law;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'manhole_node');

            -- Lines to update specific nodes that works with associated contours
            if 'manhole' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (connection_law is not null) and (connection_law != 'manhole_cover' or cover_diameter is not null) and (connection_law != 'manhole_cover' or cover_diameter >= 0) and (connection_law != 'manhole_cover' or cover_critical_pressure is not null) and (connection_law != 'manhole_cover' or cover_critical_pressure > 0) and (connection_law != 'drainage_inlet' or inlet_width is not null) and (connection_law != 'drainage_inlet' or inlet_width >0) and (connection_law != 'drainage_inlet' or inlet_height is not null) and (connection_law != 'drainage_inlet' or inlet_height >0) and (area is not null) and (area>0) and (z_ground is not null) and ((select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))) and ((select exists (select 1 from model1.pipe_link where up=new.id or down=new.id))) from  model1._manhole_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.z_ground, new.cover_diameter, new.cover_critical_pressure, new.inlet_width, new.inlet_height, new.connection_law) is distinct from (old.area, old.z_ground, old.cover_diameter, old.cover_critical_pressure, old.inlet_width, old.inlet_height, old.connection_law)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.z_ground, old.cover_diameter, old.cover_critical_pressure, old.inlet_width, old.inlet_height, old.connection_law) as o, (select new.area, new.z_ground, new.cover_diameter, new.cover_critical_pressure, new.inlet_width, new.inlet_height, new.connection_law) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.z_ground, new.cover_diameter, new.cover_critical_pressure, new.inlet_width, new.inlet_height, new.connection_law) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=(ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.z_ground, project.altitude(new.geom))), 2154)), generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._manhole_node set area=new.area, z_ground=new.z_ground, cover_diameter=new.cover_diameter, cover_critical_pressure=new.cover_critical_pressure, inlet_width=new.inlet_width, inlet_height=new.inlet_height, connection_law=new.connection_law where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'manhole_node');

            -- Lines to update specific nodes that works with associated contours
            if 'manhole' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'manhole' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'manhole' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (connection_law is not null) and (connection_law != 'manhole_cover' or cover_diameter is not null) and (connection_law != 'manhole_cover' or cover_diameter >= 0) and (connection_law != 'manhole_cover' or cover_critical_pressure is not null) and (connection_law != 'manhole_cover' or cover_critical_pressure > 0) and (connection_law != 'drainage_inlet' or inlet_width is not null) and (connection_law != 'drainage_inlet' or inlet_width >0) and (connection_law != 'drainage_inlet' or inlet_height is not null) and (connection_law != 'drainage_inlet' or inlet_height >0) and (area is not null) and (area>0) and (z_ground is not null) and ((select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))) and ((select exists (select 1 from model1.pipe_link where up=new.id or down=new.id))) from  model1._manhole_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'manhole' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._manhole_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="marker_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'marker', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'marker') where name = 'define_later' and id = id_;

            insert into model1._marker_singularity(id, singularity_type)
                values (id_, 'marker');
            if 'marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'marker_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._marker_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if (('no_column') is distinct from ('no_column')) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') as o, (select 'no_column') as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select 'no_column') n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            --update model1._marker_singularity set  where id=old.id;
            if 'marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'marker_singularity');
            update model1._singularity set validity = (select 't'::boolean from  model1._marker_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._marker_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mesh(domain_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    cfg integer;
    lnk integer;
    rec record;
    domain_2d_id integer;
begin
    select configuration from model1.metadata into cfg;
    update model1.metadata set configuration=1;

    select m.domain_2d
    from model1.coverage c
    left join model1.domain_2d_marker m on st_intersects(c.geom, m.geom)
    where c.id=domain_id 
    into domain_2d_id;

    with meshable as (
        select
            p.geom as polygon,
            st_multi(st_difference(ct.geom, rg.geom)) as constraints,
            rg.geom as border
        from model1.coverage p
        cross join lateral (
            select st_union(geom) as geom from (
                select st_intersection(discretized, p.geom) as geom
                from model1.constrain c
                where st_intersects(p.geom, c.discretized)
                and (c.constrain_type is null or c.constrain_type != 'ignored_for_coverages')
                ) t
            ) ct
        cross join lateral (
            select st_collect(st_exteriorring(r.geom)) as geom from st_dumprings(p.geom) r
            ) as rg
        where domain_type='2d'
        and p.id = domain_id
        and not exists (select 1 from model1.elem_2d_node n where st_intersects(p.geom, n.geom))
    ),
    tess as (
        select vertex, face from meshable cross join lateral project.tesselate(polygon, constrains=>constraints, has_quads=>true)
    ),
    gen as (
        insert into model1.generation_step default values returning id
    ),
    msh as (
        insert into model1.elem_2d_node(contour, generated, domain_2d)
        select st_makepolygon(st_makeline(st_force3d(st_geometryn(tess.vertex, i), project.altitude(st_geometryn(tess.vertex, i))))), gen.id, domain_2d_id
        from tess
        cross join gen
        cross join lateral generate_series(1, array_length(tess.face, 1)) f
        cross join lateral unnest(tess.face[f:f][:]) i
        where i is not null
        group by f, gen.id
        returning id, contour, geom, zb
    ),
    msh_lnk as (
        select model1.create_elem2d_links(n1.id, (st_dump(st_collectionextract(st_intersection(n1.contour, n2.contour), 2))).geom, gen.id)
        from msh as n1
        , msh as n2
        , gen
        where st_intersects(n1.contour, n2.contour)
        and st_length(st_collectionextract(st_intersection(n1.contour, n2.contour), 2)) > 0
        and n1.id > n2.id
    ),
    brd_lnk as (
        select model1.create_elem2d_links(e.id, (st_dump(st_collectionextract(st_intersection(e.contour, b.border), 2))).geom, gen.id)
                from msh as e
                , meshable as b
                , gen
                where st_intersects(e.contour, b.border)
                and st_length(st_collectionextract(st_intersection(e.contour, b.border), 2)) > 0
    ),
    exterior as (
        select e.id as id, ST_Difference(e.contour, ST_buffer(e.contour, -sqrt(ST_Area(e.contour))/4.)) as geom
        from msh as e
    ),
    reach_segments as (
        select distinct on (elem_id, reach_id) e.id as elem_id, c.reach as reach_id, (st_dump(st_intersection(e.contour, c.geom))).geom as geom, (st_dump(st_intersection(ext.geom, c.geom))).geom as limited_geom
        from model1.channel_reach as c
        , msh as e
        join exterior as ext on e.id=ext.id
        where st_intersects(e.contour, c.geom)
    ),
    generated_node as (
        select elem_id, reach_id, ST_LineInterpolatePoint(limited_geom, .5) as geom
        from reach_segments as s
    ),
    new_node as (
        select n.elem_id, n.reach_id, project.set_altitude(st_force3d(n.geom)) as geom, e.geom as elem_geom
        from generated_node as n
        join msh as e on n.elem_id=e.id
        where not exists (select 1 from model1.river_node as r where r.reach=n.reach_id and ST_Contains(e.contour, r.geom))
    ),
    ins_node as (
        insert into model1.river_node(geom, generated, reach)
        select geom, gen.id, reach_id
        from new_node
        , gen
        returning id, geom, reach
    ),
    links_geom as (
        select distinct on (id, reach) n.geom as g1, e.geom as g2, e.id, n.reach
            from model1.river_node as n
            , msh as e
            where st_contains(e.contour, n.geom)
        union
        select i.geom as g1, e.geom as g2, e.id, i.reach
            from ins_node as i
            , msh as e
            where st_contains(e.contour, i.geom)
        order by id
    ),
    immersed_channel as (
        insert into model1.overflow_link(geom, generated, z_crest1, width1, z_crest2, width2)
        select st_makeline(ARRAY[l.g1, st_centroid(st_union(l.g1, l.g2))]),gen.id, e.zb, 0, e.zb, st_length(s.geom)*2
        from links_geom as l
        , msh as e
        , gen
        , reach_segments as s
        where l.id=e.id and l.id = s.elem_id
        and s.reach_id = l.reach
        returning id
    )
    select count(1) from (select 1 from brd_lnk union all select 1 from msh_lnk union select 1 from immersed_channel) t into lnk
    ;

    update model1.metadata set configuration=cfg;

    update model1.gate_link l set geom=l.geom
    from model1.coverage c
    where l.generated is null and st_intersects(c.geom, l.geom) and c.id = domain_id;

    update model1.overflow_link l set geom=l.geom
    from model1.coverage c
    where l.generated is null and st_intersects(c.geom, l.geom) and c.id = domain_id;

    -- fake update to re-attach links
    for rec in select unnest(enum_range(null::hydra_link_type)) as type_ loop
        execute 'update model1.'||rec.type_||'_link l set geom=l.geom '||
        'from model1.coverage c '||
        'where l.generated is null and st_intersects(c.geom, l.geom) and c.id = '||domain_id;
    end loop;

    return 0;
end;]]></definition>
         <parameters>
            <parameter mode="IN" name="domain_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mesh_2d_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'mesh_2d' = 'routing_hydrology' or 'mesh_2d' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('mesh_2d', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'mesh_2d') where name = 'define_later' and id = id_;
            insert into model1._mesh_2d_link(id, link_type, z_invert, lateral_contraction_coef, border)
                values (id_, 'mesh_2d', new.z_invert, coalesce(new.lateral_contraction_coef, 1), coalesce(new.border, model1.inter_pave_border_fct(up_, down_)));
            if 'mesh_2d' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'mesh_2d_link');
            update model1._link set validity = (select (z_invert is not null) and (lateral_contraction_coef is not null) and (lateral_contraction_coef<=1) and (lateral_contraction_coef>=0) and (ST_NPoints(border)=2) and (ST_IsValid(border)) from  model1._mesh_2d_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'mesh_2d' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.lateral_contraction_coef) is distinct from (old.z_invert, old.lateral_contraction_coef)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.lateral_contraction_coef) as o, (select new.z_invert, new.lateral_contraction_coef) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.lateral_contraction_coef) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._mesh_2d_link set z_invert=new.z_invert, lateral_contraction_coef=new.lateral_contraction_coef, border=new.border where id=old.id;

            if 'mesh_2d' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'mesh_2d_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'mesh_2d' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null) and (lateral_contraction_coef is not null) and (lateral_contraction_coef<=1) and (lateral_contraction_coef>=0) and (ST_NPoints(border)=2) and (ST_IsValid(border)) from  model1._mesh_2d_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._mesh_2d_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'mesh_2d' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'mesh_2d' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mesh_all_1d()" returnType="integer" securityType="DEFINER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    _res integer;
begin
    refresh materialized view model1.flood_plain ;
    refresh materialized view model1.flood_plain_bluff_point_transect;
    refresh materialized view model1.flood_plain_flow_line;
    refresh materialized view model1.reach_flow_line;
    refresh materialized view model1.coted_point;
    refresh materialized view model1.coted_point_with_interp;
    refresh materialized view model1.mesh_1d;
    refresh materialized view model1.mesh_1d_coted;
    select count(*) from model1.mesh_1d_coted into _res;
    return _res;
end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="metadata_configuration_after_update_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        -- Unpack all configured items in default config
        perform model1.unpack_config(1);
        if new.configuration != 1 then
            -- Unpack configured items for new config only (on top of all items in default)
            perform model1.unpack_config(new.configuration);
        end if;
        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mkc_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        cov_ integer;
    begin
        if (select trigger_coverage from model1.metadata) then
            select model1.coverage_update() into cov_;
        end if;

        if tg_op = 'INSERT' or tg_op = 'UPDATE'  then
            return new;
        else
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="mkd_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        old_cov integer;
        new_cov integer;
    begin
        if tg_op = 'INSERT' then
            select id from model1.coverage as c where st_intersects(c.geom, new.geom) into new_cov;
            update model1.elem_2d_node as n set domain_2d = new.domain_2d from model1.coverage as c where st_intersects(n.geom, c.geom) and c.id = new_cov;
            return new;
        else
            if tg_op = 'UPDATE' then
                select id from model1.coverage as c where st_intersects(c.geom, old.geom) into old_cov;
                update model1.elem_2d_node as n set domain_2d = new.domain_2d from model1.coverage as c where st_intersects(n.geom, c.geom) and c.id = old_cov;
                select id from model1.coverage as c where st_intersects(c.geom, new.geom) into new_cov;
                update model1.elem_2d_node as n set domain_2d = new.domain_2d from model1.coverage as c where st_intersects(n.geom, c.geom) and c.id = new_cov;
                return new;
            else
                select id from model1.coverage as c where st_intersects(c.geom, old.geom) into old_cov;
                update model1.elem_2d_node as n set domain_2d = null from model1.coverage as c where st_intersects(n.geom, c.geom) and c.id = old_cov;
                return old;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="model_connect_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'model_connect_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'model_connect_bc') where name = 'define_later' and id = id_;

            insert into model1._model_connect_bc_singularity(id, singularity_type, cascade_mode, zq_array, tz_array, quality)
                values (id_, 'model_connect_bc', coalesce(new.cascade_mode, 'hydrograph'), new.zq_array, new.tz_array, coalesce(new.quality, '{0, 0, 0, 0, 0, 0, 0, 0, 0}'::real[]));
            if 'model_connect_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'model_connect_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'model_connect_bc_singularity');
            update model1._singularity set validity = (select (cascade_mode is not null) and (cascade_mode='hydrograph' or zq_array is not null or tz_array is not null) and (array_length(zq_array, 1)<=20) and (array_length(zq_array, 1)>=1) and (array_length(zq_array, 2)=2) and (array_length(tz_array, 1)<=20) and (array_length(tz_array, 1)>=1) and (array_length(tz_array, 2)=2) and (array_length(quality, 1)=9) from  model1._model_connect_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.cascade_mode, new.zq_array, new.tz_array, new.quality) is distinct from (old.cascade_mode, old.zq_array, old.tz_array, old.quality)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.cascade_mode, old.zq_array, old.tz_array, old.quality) as o, (select new.cascade_mode, new.zq_array, new.tz_array, new.quality) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.cascade_mode, new.zq_array, new.tz_array, new.quality) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._model_connect_bc_singularity set cascade_mode=new.cascade_mode, zq_array=new.zq_array, tz_array=new.tz_array, quality=new.quality where id=old.id;
            if 'model_connect_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'model_connect_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'model_connect_bc_singularity');
            update model1._singularity set validity = (select (cascade_mode is not null) and (cascade_mode='hydrograph' or zq_array is not null or tz_array is not null) and (array_length(zq_array, 1)<=20) and (array_length(zq_array, 1)>=1) and (array_length(zq_array, 2)=2) and (array_length(tz_array, 1)<=20) and (array_length(tz_array, 1)>=1) and (array_length(tz_array, 2)=2) and (array_length(quality, 1)=9) from  model1._model_connect_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'model_connect_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._model_connect_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'model_connect_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="network_overflow_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'network_overflow' = 'routing_hydrology' or 'network_overflow' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('network_overflow', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'network_overflow') where name = 'define_later' and id = id_;
            insert into model1._network_overflow_link(id, link_type, z_overflow, area)
                values (id_, 'network_overflow', coalesce(new.z_overflow, st_z(st_endpoint(new.geom))), coalesce(new.area, 1));
            if 'network_overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'network_overflow_link');
            update model1._link set validity = (select (z_overflow is not null) and (area is not null) and (area>=0) from  model1._network_overflow_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'network_overflow' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_overflow, new.area) is distinct from (old.z_overflow, old.area)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_overflow, old.area) as o, (select new.z_overflow, new.area) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_overflow, new.area) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._network_overflow_link set z_overflow=new.z_overflow, area=new.area where id=old.id;

            if 'network_overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'network_overflow_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'network_overflow' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_overflow is not null) and (area is not null) and (area>=0) from  model1._network_overflow_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._network_overflow_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'network_overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'network_overflow' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="node_invalidity_reason(id_ integer)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
            reason varchar;
        begin
            reason := '';
            if not (select area is not null from model1.crossroad_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select (area > 0) from model1.crossroad_node as new where id=id_) then
               reason := reason || '   (area > 0)   ';
               end if;

if not (select z_ground is not null from model1.crossroad_node as new where id=id_) then
               reason := reason || '   z_ground is not null   ';
               end if;

if not (select h is not null from model1.crossroad_node as new where id=id_) then
               reason := reason || '   h is not null   ';
               end if;

if not (select h>=0 from model1.crossroad_node as new where id=id_) then
               reason := reason || '   h>=0   ';
               end if;

if not (select area is not null from model1.manhole_hydrology_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select (area > 0) from model1.manhole_hydrology_node as new where id=id_) then
               reason := reason || '   (area > 0)   ';
               end if;

if not (select z_ground is not null from model1.manhole_hydrology_node as new where id=id_) then
               reason := reason || '   z_ground is not null   ';
               end if;

if not (select zs_array is not null  from model1.storage_node as new where id=id_) then
               reason := reason || '   zs_array is not null    ';
               end if;

if not (select zini is not null from model1.storage_node as new where id=id_) then
               reason := reason || '   zini is not null   ';
               end if;

if not (select array_length(zs_array, 1) <= 10  from model1.storage_node as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1) <= 10    ';
               end if;

if not (select array_length(zs_array, 1) >= 1 from model1.storage_node as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1) >= 1   ';
               end if;

if not (select array_length(zs_array, 2) = 2 from model1.storage_node as new where id=id_) then
               reason := reason || '   array_length(zs_array, 2) = 2   ';
               end if;

if not (select contraction_coef is not null from model1.storage_node as new where id=id_) then
               reason := reason || '   contraction_coef is not null   ';
               end if;

if not (select contraction_coef<=1 from model1.storage_node as new where id=id_) then
               reason := reason || '   contraction_coef<=1   ';
               end if;

if not (select contraction_coef>=0 from model1.storage_node as new where id=id_) then
               reason := reason || '   contraction_coef>=0   ';
               end if;

if not (select area_ha is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   area_ha is not null   ';
               end if;

if not (select area_ha>0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   area_ha>0   ';
               end if;

if not (select rl is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   rl is not null   ';
               end if;

if not (select rl>0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   rl>0   ';
               end if;

if not (select slope is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   slope is not null   ';
               end if;

if not (select c_imp is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   c_imp is not null   ';
               end if;

if not (select c_imp>=0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   c_imp>=0   ';
               end if;

if not (select c_imp<=1 from model1.catchment_node as new where id=id_) then
               reason := reason || '   c_imp<=1   ';
               end if;

if not (select netflow_type is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type is not null   ';
               end if;

if not (select netflow_type!='constant_runoff' or (constant_runoff is not null and constant_runoff>=0 and constant_runoff<=1) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''constant_runoff'' or (constant_runoff is not null and constant_runoff>=0 and constant_runoff<=1)   ';
               end if;

if not (select netflow_type!='horner' or (horner_ini_loss_coef is not null and horner_ini_loss_coef>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''horner'' or (horner_ini_loss_coef is not null and horner_ini_loss_coef>=0)   ';
               end if;

if not (select netflow_type!='horner' or (horner_recharge_coef is not null and horner_recharge_coef>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''horner'' or (horner_recharge_coef is not null and horner_recharge_coef>=0)   ';
               end if;

if not (select netflow_type!='holtan' or (holtan_sat_inf_rate_mmh is not null and holtan_sat_inf_rate_mmh>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''holtan'' or (holtan_sat_inf_rate_mmh is not null and holtan_sat_inf_rate_mmh>=0)   ';
               end if;

if not (select netflow_type!='holtan' or (holtan_dry_inf_rate_mmh is not null and holtan_dry_inf_rate_mmh>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''holtan'' or (holtan_dry_inf_rate_mmh is not null and holtan_dry_inf_rate_mmh>=0)   ';
               end if;

if not (select netflow_type!='holtan' or (holtan_soil_storage_cap_mm is not null and holtan_soil_storage_cap_mm>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''holtan'' or (holtan_soil_storage_cap_mm is not null and holtan_soil_storage_cap_mm>=0)   ';
               end if;

if not (select netflow_type!='scs' or (scs_j_mm is not null and scs_j_mm>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''scs'' or (scs_j_mm is not null and scs_j_mm>=0)   ';
               end if;

if not (select netflow_type!='scs' or (scs_soil_drainage_time_day is not null and scs_soil_drainage_time_day>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''scs'' or (scs_soil_drainage_time_day is not null and scs_soil_drainage_time_day>=0)   ';
               end if;

if not (select netflow_type!='scs' or (scs_rfu_mm is not null and scs_rfu_mm>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''scs'' or (scs_rfu_mm is not null and scs_rfu_mm>=0)   ';
               end if;

if not (select netflow_type!='hydra' or (hydra_surface_soil_storage_rfu_mm is not null and hydra_surface_soil_storage_rfu_mm>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or (hydra_surface_soil_storage_rfu_mm is not null and hydra_surface_soil_storage_rfu_mm>=0)   ';
               end if;

if not (select netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_inf_rate_f0_mm_hr is not null and hydra_inf_rate_f0_mm_hr>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or hydra_soil_infiltration_type=''split'' or (hydra_inf_rate_f0_mm_hr is not null and hydra_inf_rate_f0_mm_hr>=0)   ';
               end if;

if not (select netflow_type!='hydra' or hydra_soil_infiltration_type='split' or (hydra_int_soil_storage_j_mm is not null and hydra_int_soil_storage_j_mm>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or hydra_soil_infiltration_type=''split'' or (hydra_int_soil_storage_j_mm is not null and hydra_int_soil_storage_j_mm>=0)   ';
               end if;

if not (select netflow_type!='hydra' or (hydra_soil_drainage_time_qres_day is not null and hydra_soil_drainage_time_qres_day>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or (hydra_soil_drainage_time_qres_day is not null and hydra_soil_drainage_time_qres_day>=0)   ';
               end if;

if not (select netflow_type!='hydra' or hydra_soil_infiltration_type='rate' or (hydra_split_coefficient is not null and hydra_split_coefficient>=0 and hydra_split_coefficient<=1) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or hydra_soil_infiltration_type=''rate'' or (hydra_split_coefficient is not null and hydra_split_coefficient>=0 and hydra_split_coefficient<=1)   ';
               end if;

if not (select netflow_type!='hydra' or (hydra_catchment_connect_coef is not null and hydra_catchment_connect_coef>=0 and hydra_catchment_connect_coef<=1) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or (hydra_catchment_connect_coef is not null and hydra_catchment_connect_coef>=0 and hydra_catchment_connect_coef<=1)   ';
               end if;

if not (select netflow_type!='hydra' or (hydra_aquifer_infiltration_rate is not null and hydra_aquifer_infiltration_rate>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''hydra'' or (hydra_aquifer_infiltration_rate is not null and hydra_aquifer_infiltration_rate>=0)   ';
               end if;

if not (select netflow_type!='gr4' or (gr4_k1 is not null and gr4_k1>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''gr4'' or (gr4_k1 is not null and gr4_k1>=0)   ';
               end if;

if not (select netflow_type!='gr4' or (gr4_k2 is not null) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''gr4'' or (gr4_k2 is not null)   ';
               end if;

if not (select netflow_type!='gr4' or (gr4_k3 is not null and gr4_k3>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''gr4'' or (gr4_k3 is not null and gr4_k3>=0)   ';
               end if;

if not (select netflow_type!='gr4' or (gr4_k4 is not null and gr4_k4>=0) from model1.catchment_node as new where id=id_) then
               reason := reason || '   netflow_type!=''gr4'' or (gr4_k4 is not null and gr4_k4>=0)   ';
               end if;

if not (select runoff_type is not null or netflow_type='gr4' from model1.catchment_node as new where id=id_) then
               reason := reason || '   runoff_type is not null or netflow_type=''gr4''   ';
               end if;

if not (select runoff_type!='Define Tc' or (socose_tc_mn is not null and socose_tc_mn>0) or netflow_type='gr4' from model1.catchment_node as new where id=id_) then
               reason := reason || '   runoff_type!=''Define Tc'' or (socose_tc_mn is not null and socose_tc_mn>0) or netflow_type=''gr4''   ';
               end if;

if not (select runoff_type!='Define Tc' or (socose_shape_param_beta is not null and socose_shape_param_beta>=1 and socose_shape_param_beta<=6) or netflow_type='gr4' from model1.catchment_node as new where id=id_) then
               reason := reason || '   runoff_type!=''Define Tc'' or (socose_shape_param_beta is not null and socose_shape_param_beta>=1 and socose_shape_param_beta<=6) or netflow_type=''gr4''   ';
               end if;

if not (select runoff_type!='Define K' or (define_k_mn is not null and define_k_mn>0) or netflow_type='gr4' from model1.catchment_node as new where id=id_) then
               reason := reason || '   runoff_type!=''Define K'' or (define_k_mn is not null and define_k_mn>0) or netflow_type=''gr4''   ';
               end if;

if not (select runoff_type!='Desbordes 1 Cr' or (netflow_type='constant_runoff') from model1.catchment_node as new where id=id_) then
               reason := reason || '   runoff_type!=''Desbordes 1 Cr'' or (netflow_type=''constant_runoff'')   ';
               end if;

if not (select q_limit is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   q_limit is not null   ';
               end if;

if not (select q0 is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   q0 is not null   ';
               end if;

if not (select network_type is not null from model1.catchment_node as new where id=id_) then
               reason := reason || '   network_type is not null   ';
               end if;

if not (select rural_land_use is null or rural_land_use>=0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   rural_land_use is null or rural_land_use>=0   ';
               end if;

if not (select industrial_land_use is null or industrial_land_use>=0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   industrial_land_use is null or industrial_land_use>=0   ';
               end if;

if not (select suburban_housing_land_use is null or suburban_housing_land_use>=0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   suburban_housing_land_use is null or suburban_housing_land_use>=0   ';
               end if;

if not (select dense_housing_land_use is null or dense_housing_land_use>=0 from model1.catchment_node as new where id=id_) then
               reason := reason || '   dense_housing_land_use is null or dense_housing_land_use>=0   ';
               end if;

if not (select area is not null from model1.station_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select area>0 from model1.station_node as new where id=id_) then
               reason := reason || '   area>0   ';
               end if;

if not (select z_invert is not null from model1.station_node as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select station is not null  from model1.station_node as new where id=id_) then
               reason := reason || '   station is not null    ';
               end if;

if not (select (select st_intersects(new.geom, geom) from model1.station where id=new.station) from model1.station_node as new where id=id_) then
               reason := reason || '   (select st_intersects(new.geom, geom) from model1.station where id=new.station)   ';
               end if;

if not (select connection_law is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law is not null   ';
               end if;

if not (select connection_law != 'manhole_cover' or cover_diameter is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''manhole_cover'' or cover_diameter is not null   ';
               end if;

if not (select connection_law != 'manhole_cover' or cover_diameter >= 0 from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''manhole_cover'' or cover_diameter >= 0   ';
               end if;

if not (select connection_law != 'manhole_cover' or cover_critical_pressure is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''manhole_cover'' or cover_critical_pressure is not null   ';
               end if;

if not (select connection_law != 'manhole_cover' or cover_critical_pressure > 0 from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''manhole_cover'' or cover_critical_pressure > 0   ';
               end if;

if not (select connection_law != 'drainage_inlet' or inlet_width is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''drainage_inlet'' or inlet_width is not null   ';
               end if;

if not (select connection_law != 'drainage_inlet' or inlet_width >0 from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''drainage_inlet'' or inlet_width >0   ';
               end if;

if not (select connection_law != 'drainage_inlet' or inlet_height is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''drainage_inlet'' or inlet_height is not null   ';
               end if;

if not (select connection_law != 'drainage_inlet' or inlet_height >0 from model1.manhole_node as new where id=id_) then
               reason := reason || '   connection_law != ''drainage_inlet'' or inlet_height >0   ';
               end if;

if not (select area is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select area>0 from model1.manhole_node as new where id=id_) then
               reason := reason || '   area>0   ';
               end if;

if not (select z_ground is not null from model1.manhole_node as new where id=id_) then
               reason := reason || '   z_ground is not null   ';
               end if;

if not (select (select not exists(select 1 from model1.station where st_intersects(geom, new.geom))) from model1.manhole_node as new where id=id_) then
               reason := reason || '   (select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))   ';
               end if;

if not (select (select exists (select 1 from model1.pipe_link where up=new.id or down=new.id)) from model1.manhole_node as new where id=id_) then
               reason := reason || '   (select exists (select 1 from model1.pipe_link where up=new.id or down=new.id))   ';
               end if;

if not (select area is not null from model1.elem_2d_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select area>0 from model1.elem_2d_node as new where id=id_) then
               reason := reason || '   area>0   ';
               end if;

if not (select zb is not null from model1.elem_2d_node as new where id=id_) then
               reason := reason || '   zb is not null   ';
               end if;

if not (select rk is not null from model1.elem_2d_node as new where id=id_) then
               reason := reason || '   rk is not null   ';
               end if;

if not (select rk>0 from model1.elem_2d_node as new where id=id_) then
               reason := reason || '   rk>0   ';
               end if;

if not (select z_ground is not null from model1.river_node as new where id=id_) then
               reason := reason || '   z_ground is not null   ';
               end if;

if not (select area is not null from model1.river_node as new where id=id_) then
               reason := reason || '   area is not null   ';
               end if;

if not (select area>0 from model1.river_node as new where id=id_) then
               reason := reason || '   area>0   ';
               end if;

if not (select reach is not null from model1.river_node as new where id=id_) then
               reason := reason || '   reach is not null   ';
               end if;

if not (select (select not exists(select 1 from model1.station where st_intersects(geom, new.geom))) from model1.river_node as new where id=id_) then
               reason := reason || '   (select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))   ';
               end if;
            return reason;
        end;]]></definition>
         <parameters>
            <parameter mode="IN" name="id_" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="node_update_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        update model1._link set geom=ST_SetPoint(geom, 0, new.geom) where up=new.id;
        update model1._link set geom=ST_SetPoint(geom, ST_NumPoints(geom)-1, new.geom) where down=new.id;
        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="op_geometric_calc_p_fct(real[])" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="sql"><![CDATA[select $1[1][2] + sum(2*sqrt(($1[i+1][1]-$1[i][1])^2 + (0.5*($1[i+1][2]-$1[i][2]))^2 )) 
    from generate_series(1, array_length($1,1) - 1) i;]]></definition>
         <parameters>
            <parameter mode="IN" type="real[]"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="open_parametric_geometry_before_del_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config record;
    begin
        for config in select name from model1.configuration loop
            update model1._link
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', op_geom}')::text[], 'null'::jsonb))::json
            where link_type='pipe' and (configuration->config.name->'op_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', up_op_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'up_op_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', down_op_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'down_op_geom')::text=old.id::text;
        end loop;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="overflow_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'overflow' = 'routing_hydrology' or 'overflow' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('overflow', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'overflow') where name = 'define_later' and id = id_;
            insert into model1._overflow_link(id, link_type, z_crest1, width1, z_crest2, width2, cc, lateral_contraction_coef, break_mode, z_break, t_break, z_invert, width_breach, grp, dt_fracw_array, border)
                values (id_, 'overflow', new.z_crest1, new.width1, coalesce(new.z_crest2, new.z_crest1), coalesce(new.width2, 0), coalesce(new.cc, .6), coalesce(new.lateral_contraction_coef, 1), coalesce(new.break_mode, 'none'), new.z_break, new.t_break, new.z_invert, new.width_breach, coalesce(new.grp, 1), new.dt_fracw_array, new.border);
            if 'overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'overflow_link');
            update model1._link set validity = (select (z_crest1 is not null) and (width1 is not null) and (width1>=0) and (z_crest2 is not null) and (z_crest2>=z_crest1) and (width2 is not null) and (width2>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (lateral_contraction_coef is not null) and (lateral_contraction_coef<=1) and (lateral_contraction_coef>=0) and (break_mode is not null) and (break_mode!='zw_critical' or z_break is not null) and (break_mode!='time_critical' or t_break is not null) and (break_mode='none' or width_breach is not null) and (break_mode='none' or z_invert is not null) and (break_mode='none' or grp is not null) and (break_mode='none' or grp>0) and (break_mode='none' or grp<100) and (break_mode='none' or dt_fracw_array is not null) and (break_mode='none' or array_length(dt_fracw_array, 1)<=10) and (break_mode='none' or array_length(dt_fracw_array, 1)>=1) and (break_mode='none' or array_length(dt_fracw_array, 2)=2) from  model1._overflow_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'overflow' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_crest1, new.width1, new.z_crest2, new.width2, new.cc, new.lateral_contraction_coef, new.break_mode, new.z_break, new.t_break, new.z_invert, new.width_breach, new.grp, new.dt_fracw_array) is distinct from (old.z_crest1, old.width1, old.z_crest2, old.width2, old.cc, old.lateral_contraction_coef, old.break_mode, old.z_break, old.t_break, old.z_invert, old.width_breach, old.grp, old.dt_fracw_array)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_crest1, old.width1, old.z_crest2, old.width2, old.cc, old.lateral_contraction_coef, old.break_mode, old.z_break, old.t_break, old.z_invert, old.width_breach, old.grp, old.dt_fracw_array) as o, (select new.z_crest1, new.width1, new.z_crest2, new.width2, new.cc, new.lateral_contraction_coef, new.break_mode, new.z_break, new.t_break, new.z_invert, new.width_breach, new.grp, new.dt_fracw_array) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_crest1, new.width1, new.z_crest2, new.width2, new.cc, new.lateral_contraction_coef, new.break_mode, new.z_break, new.t_break, new.z_invert, new.width_breach, new.grp, new.dt_fracw_array) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._overflow_link set z_crest1=new.z_crest1, width1=new.width1, z_crest2=new.z_crest2, width2=new.width2, cc=new.cc, lateral_contraction_coef=new.lateral_contraction_coef, break_mode=new.break_mode, z_break=new.z_break, t_break=new.t_break, z_invert=new.z_invert, width_breach=new.width_breach, grp=new.grp, dt_fracw_array=new.dt_fracw_array, border=new.border where id=old.id;

            if 'overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'overflow_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'overflow' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_crest1 is not null) and (width1 is not null) and (width1>=0) and (z_crest2 is not null) and (z_crest2>=z_crest1) and (width2 is not null) and (width2>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (lateral_contraction_coef is not null) and (lateral_contraction_coef<=1) and (lateral_contraction_coef>=0) and (break_mode is not null) and (break_mode!='zw_critical' or z_break is not null) and (break_mode!='time_critical' or t_break is not null) and (break_mode='none' or width_breach is not null) and (break_mode='none' or z_invert is not null) and (break_mode='none' or grp is not null) and (break_mode='none' or grp>0) and (break_mode='none' or grp<100) and (break_mode='none' or dt_fracw_array is not null) and (break_mode='none' or array_length(dt_fracw_array, 1)<=10) and (break_mode='none' or array_length(dt_fracw_array, 1)>=1) and (break_mode='none' or array_length(dt_fracw_array, 2)=2) from  model1._overflow_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._overflow_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'overflow' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'overflow' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="param_headloss_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'param_headloss', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'param_headloss') where name = 'define_later' and id = id_;

            insert into model1._param_headloss_singularity(id, singularity_type, q_dz_array, full_section_discharge_for_headloss)
                values (id_, 'param_headloss', coalesce(new.q_dz_array, '{{0, 0}}'::real[]), coalesce(new.full_section_discharge_for_headloss, 't'));
            if 'param_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'param_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'param_headloss_singularity');
            update model1._singularity set validity = (select (q_dz_array is not null) and (array_length(q_dz_array, 1)<=10) and (array_length(q_dz_array, 1)>=1) and (array_length(q_dz_array, 2)=2) and (q_dz_array[1][1]=0) and (q_dz_array[1][2]=0) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._param_headloss_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.q_dz_array, new.full_section_discharge_for_headloss) is distinct from (old.q_dz_array, old.full_section_discharge_for_headloss)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.q_dz_array, old.full_section_discharge_for_headloss) as o, (select new.q_dz_array, new.full_section_discharge_for_headloss) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.q_dz_array, new.full_section_discharge_for_headloss) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._param_headloss_singularity set q_dz_array=new.q_dz_array, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss where id=old.id;
            if 'param_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'param_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'param_headloss_singularity');
            update model1._singularity set validity = (select (q_dz_array is not null) and (array_length(q_dz_array, 1)<=10) and (array_length(q_dz_array, 1)>=1) and (array_length(q_dz_array, 2)=2) and (q_dz_array[1][1]=0) and (q_dz_array[1][2]=0) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._param_headloss_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'param_headloss' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._param_headloss_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'param_headloss' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pipe_branch_marker_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'pipe_branch_marker', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'pipe_branch_marker') where name = 'define_later' and id = id_;

            insert into model1._pipe_branch_marker_singularity(id, singularity_type, pk0_km, dx)
                values (id_, 'pipe_branch_marker', coalesce(new.pk0_km, 0), coalesce(new.dx, 50));
            if 'pipe_branch_marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'pipe_branch_marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'pipe_branch_marker_singularity');
            update model1._singularity set validity = (select (pk0_km is not null) and (dx is not null) and (dx>=0.1) from  model1._pipe_branch_marker_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.pk0_km, new.dx) is distinct from (old.pk0_km, old.dx)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.pk0_km, old.dx) as o, (select new.pk0_km, new.dx) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.pk0_km, new.dx) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._pipe_branch_marker_singularity set pk0_km=new.pk0_km, dx=new.dx where id=old.id;
            if 'pipe_branch_marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'pipe_branch_marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'pipe_branch_marker_singularity');
            update model1._singularity set validity = (select (pk0_km is not null) and (dx is not null) and (dx>=0.1) from  model1._pipe_branch_marker_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'pipe_branch_marker' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._pipe_branch_marker_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'pipe_branch_marker' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pipe_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'pipe' = 'routing_hydrology' or 'pipe' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('pipe', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'pipe') where name = 'define_later' and id = id_;
            insert into model1._pipe_link(id, link_type, z_invert_up, z_invert_down, cross_section_type, h_sable, branch, exclude_from_branch, rk, custom_length, circular_diameter, ovoid_height, ovoid_top_diameter, ovoid_invert_diameter, cp_geom, op_geom, rk_maj)
                values (id_, 'pipe', new.z_invert_up, new.z_invert_down, coalesce(new.cross_section_type, 'circular'), coalesce(new.h_sable, 0), new.branch, coalesce(new.exclude_from_branch, False), new.rk, coalesce(new.custom_length, null), new.circular_diameter, new.ovoid_height, new.ovoid_top_diameter, new.ovoid_invert_diameter, new.cp_geom, new.op_geom, coalesce(new.rk_maj, 0));
            if 'pipe' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'pipe_link');
            update model1._link set validity = (select (z_invert_up is not null) and (z_invert_down is not null) and (h_sable is not null) and (cross_section_type is not null) and (cross_section_type not in ('valley')) and (rk is not null) and (rk >0) and (cross_section_type!='circular' or (circular_diameter is not null and circular_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_top_diameter is not null and ovoid_top_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_invert_diameter is not null and ovoid_invert_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_height is not null and ovoid_height >0 )) and (cross_section_type!='ovoid' or (ovoid_height > (ovoid_top_diameter+ovoid_invert_diameter)/2)) and (cross_section_type!='pipe' or cp_geom is not null) and (cross_section_type!='channel' or op_geom is not null) and (rk_maj is not null) and (rk_maj >=0) from  model1._pipe_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'pipe' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert_up, new.z_invert_down, new.cross_section_type, new.h_sable, new.exclude_from_branch, new.rk, new.custom_length, new.circular_diameter, new.ovoid_height, new.ovoid_top_diameter, new.ovoid_invert_diameter, new.cp_geom, new.op_geom, new.rk_maj) is distinct from (old.z_invert_up, old.z_invert_down, old.cross_section_type, old.h_sable, old.exclude_from_branch, old.rk, old.custom_length, old.circular_diameter, old.ovoid_height, old.ovoid_top_diameter, old.ovoid_invert_diameter, old.cp_geom, old.op_geom, old.rk_maj)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert_up, old.z_invert_down, old.cross_section_type, old.h_sable, old.exclude_from_branch, old.rk, old.custom_length, old.circular_diameter, old.ovoid_height, old.ovoid_top_diameter, old.ovoid_invert_diameter, old.cp_geom, old.op_geom, old.rk_maj) as o, (select new.z_invert_up, new.z_invert_down, new.cross_section_type, new.h_sable, new.exclude_from_branch, new.rk, new.custom_length, new.circular_diameter, new.ovoid_height, new.ovoid_top_diameter, new.ovoid_invert_diameter, new.cp_geom, new.op_geom, new.rk_maj) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert_up, new.z_invert_down, new.cross_section_type, new.h_sable, new.exclude_from_branch, new.rk, new.custom_length, new.circular_diameter, new.ovoid_height, new.ovoid_top_diameter, new.ovoid_invert_diameter, new.cp_geom, new.op_geom, new.rk_maj) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._pipe_link set z_invert_up=new.z_invert_up, z_invert_down=new.z_invert_down, cross_section_type=new.cross_section_type, h_sable=new.h_sable, branch=new.branch, exclude_from_branch=new.exclude_from_branch, rk=new.rk, custom_length=new.custom_length, circular_diameter=new.circular_diameter, ovoid_height=new.ovoid_height, ovoid_top_diameter=new.ovoid_top_diameter, ovoid_invert_diameter=new.ovoid_invert_diameter, cp_geom=new.cp_geom, op_geom=new.op_geom, rk_maj=new.rk_maj where id=old.id;

            if 'pipe' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'pipe_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'pipe' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert_up is not null) and (z_invert_down is not null) and (h_sable is not null) and (cross_section_type is not null) and (cross_section_type not in ('valley')) and (rk is not null) and (rk >0) and (cross_section_type!='circular' or (circular_diameter is not null and circular_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_top_diameter is not null and ovoid_top_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_invert_diameter is not null and ovoid_invert_diameter > 0)) and (cross_section_type!='ovoid' or (ovoid_height is not null and ovoid_height >0 )) and (cross_section_type!='ovoid' or (ovoid_height > (ovoid_top_diameter+ovoid_invert_diameter)/2)) and (cross_section_type!='pipe' or cp_geom is not null) and (cross_section_type!='channel' or op_geom is not null) and (rk_maj is not null) and (rk_maj >=0) from  model1._pipe_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._pipe_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'pipe' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'pipe' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="porous_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'porous' = 'routing_hydrology' or 'porous' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('porous', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'porous') where name = 'define_later' and id = id_;
            insert into model1._porous_link(id, link_type, z_invert, width, transmitivity, border)
                values (id_, 'porous', new.z_invert, new.width, new.transmitivity, new.border);
            if 'porous' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'porous_link');
            update model1._link set validity = (select (z_invert is not null) and (width is not null) and (width>=0) and (transmitivity is not null) and (transmitivity>=0) from  model1._porous_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'porous' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.width, new.transmitivity) is distinct from (old.z_invert, old.width, old.transmitivity)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.width, old.transmitivity) as o, (select new.z_invert, new.width, new.transmitivity) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.width, new.transmitivity) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._porous_link set z_invert=new.z_invert, width=new.width, transmitivity=new.transmitivity, border=new.border where id=old.id;

            if 'porous' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'porous_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'porous' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null) and (width is not null) and (width>=0) and (transmitivity is not null) and (transmitivity>=0) from  model1._porous_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._porous_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'porous' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'porous' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="profile_from_transect(flood_plain_transect geometry, interpolate boolean DEFAULT false, discretization integer DEFAULT 150, ignore_points boolean DEFAULT false, distance_point integer DEFAULT 100)" returnType="real[]" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        return model1._str_profile_from_transect(flood_plain_transect, interpolate, discretization, ignore_points, distance_point)::real[][];
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="flood_plain_transect" type="geometry"/>
            <parameter mode="IN" name="interpolate" type="boolean"/>
            <parameter mode="IN" name="discretization" type="integer"/>
            <parameter mode="IN" name="ignore_points" type="boolean"/>
            <parameter mode="IN" name="distance_point" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="pump_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'pump' = 'routing_hydrology' or 'pump' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('pump', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'pump') where name = 'define_later' and id = id_;
            insert into model1._pump_link(id, link_type, npump, zregul_array, hq_array, response_time_sec)
                values (id_, 'pump', new.npump, new.zregul_array, new.hq_array, coalesce(new.response_time_sec, 300));
            if 'pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'pump_link');
            update model1._link set validity = (select (npump is not null) and (npump<=10) and (npump>=1) and (zregul_array is not null) and (hq_array is not null) and (array_length(zregul_array, 1)=npump) and (array_length(zregul_array, 2)=2) and (array_length(hq_array, 1)=npump) and (array_length(hq_array, 2)<=10) and (array_length(hq_array, 2)>=1) and (array_length(hq_array, 3)=2) from  model1._pump_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'pump' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.npump, new.zregul_array, new.hq_array, new.response_time_sec) is distinct from (old.npump, old.zregul_array, old.hq_array, old.response_time_sec)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.npump, old.zregul_array, old.hq_array, old.response_time_sec) as o, (select new.npump, new.zregul_array, new.hq_array, new.response_time_sec) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.npump, new.zregul_array, new.hq_array, new.response_time_sec) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._pump_link set npump=new.npump, zregul_array=new.zregul_array, hq_array=new.hq_array, response_time_sec=new.response_time_sec where id=old.id;

            if 'pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'pump_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'pump' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (npump is not null) and (npump<=10) and (npump>=1) and (zregul_array is not null) and (hq_array is not null) and (array_length(zregul_array, 1)=npump) and (array_length(zregul_array, 2)=2) and (array_length(hq_array, 1)=npump) and (array_length(hq_array, 2)<=10) and (array_length(hq_array, 2)>=1) and (array_length(hq_array, 3)=2) from  model1._pump_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._pump_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'pump' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'pump' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="qq_split_hydrology_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'qq_split_hydrology', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'qq_split_hydrology') where name = 'define_later' and id = id_;

            insert into model1._qq_split_hydrology_singularity(id, singularity_type, qq_array, downstream, downstream_type, split1, split1_type, split2, split2_type)
                values (id_, 'qq_split_hydrology', new.qq_array, new.downstream, coalesce(new.downstream_type, (select link_type from model1._link where id=new.downstream)), new.split1, coalesce(new.split1_type, (select link_type from model1._link where id=new.split1)), new.split2, coalesce(new.split2_type, (select link_type from model1._link where id=new.split2)));
            if 'qq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'qq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'qq_split_hydrology_singularity');
            update model1._singularity set validity = (select (qq_array is not null) and (downstream is not null) and (split1 is not null) and (array_length(qq_array, 1)<=10) and (array_length(qq_array, 1)>=1) and ((split2 is not null and array_length(qq_array, 2)=3) or (split2 is null and array_length(qq_array, 2)=2)) from  model1._qq_split_hydrology_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.qq_array, new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type) is distinct from (old.qq_array, old.downstream, old.downstream_type, old.split1, old.split1_type, old.split2, old.split2_type)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.qq_array, old.downstream, old.downstream_type, old.split1, old.split1_type, old.split2, old.split2_type) as o, (select new.qq_array, new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.qq_array, new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._qq_split_hydrology_singularity set qq_array=new.qq_array, downstream=new.downstream, downstream_type=new.downstream_type, split1=new.split1, split1_type=new.split1_type, split2=new.split2, split2_type=new.split2_type where id=old.id;
            if 'qq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'qq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'qq_split_hydrology_singularity');
            update model1._singularity set validity = (select (qq_array is not null) and (downstream is not null) and (split1 is not null) and (array_length(qq_array, 1)<=10) and (array_length(qq_array, 1)>=1) and ((split2 is not null and array_length(qq_array, 2)=3) or (split2 is null and array_length(qq_array, 2)=2)) from  model1._qq_split_hydrology_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'qq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._qq_split_hydrology_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'qq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reach_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        if tg_op = 'INSERT' then
            update model1.bradley_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.bridge_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.hydraulic_cut_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.zregul_weir_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.param_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.regul_sluice_gate_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.gate_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            update model1.borda_headloss_singularity
                set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom));
            return new;
        else
            if tg_op = 'UPDATE' then
                update model1.bradley_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.bridge_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.hydraulic_cut_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.zregul_weir_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.param_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.regul_sluice_gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.borda_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(new.geom)) or st_intersects(geom, st_endpoint(new.geom))
                    or st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                return new;
            else
                update model1.bradley_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.bridge_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.hydraulic_cut_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.zregul_weir_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.param_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.regul_sluice_gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.gate_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                update model1.borda_headloss_singularity
                    set geom=geom
                where st_intersects(geom, st_startpoint(old.geom)) or st_intersects(geom, st_endpoint(old.geom));
                return old;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reach_after_insert_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _up boolean;
        _down boolean;
    begin
        select exists(select 1 from model1.river_node as n where ST_Intersects(n.geom, ST_Buffer(ST_StartPoint(new.geom), 0.1))) into _up;
        select exists(select 1 from model1.river_node as n where ST_Intersects(n.geom, ST_Buffer(ST_EndPoint(new.geom), 0.1))) into _down;

        if not _up then
            insert into model1.river_node(geom) values(ST_StartPoint(new.geom));
        end if;
        if not _down then
            insert into model1.river_node(geom) values(ST_EndPoint(new.geom));
        end if;
        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reach_after_update_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        update model1.river_node set
                -- il faut valider cette mise  jour du pk
                geom = (select ST_LineInterpolatePoint(new.geom, ST_LineLocatePoint(new.geom, geom)))
                where reach=new.id
                    and id not in (select id from model1.river_node as n where ST_Intersects(n.geom, ST_LineInterpolatePoint(new.geom, ST_LineLocatePoint(new.geom, n.geom))));
        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="regul_gate_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'regul_gate' = 'routing_hydrology' or 'regul_gate' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('regul_gate', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'regul_gate') where name = 'define_later' and id = id_;
            insert into model1._regul_gate_link(id, link_type, z_invert, z_ceiling, width, cc, action_gate_type, z_invert_stop, z_ceiling_stop, v_max_cms, dt_regul_hr, mode_regul, z_control_node, z_pid_array, z_tz_array, q_z_crit, q_tq_array, hq_array, nr_z_gate, cc_submerged, h_open, h_close)
                values (id_, 'regul_gate', new.z_invert, new.z_ceiling, new.width, coalesce(new.cc, .6), coalesce(new.action_gate_type, 'upward_opening'), coalesce(new.z_invert_stop, new.z_invert), coalesce(new.z_ceiling_stop, new.z_ceiling), coalesce(new.v_max_cms, .5), coalesce(new.dt_regul_hr, 0), coalesce(new.mode_regul, 'elevation'), new.z_control_node, coalesce(new.z_pid_array, '{1, 0, 0}'::real[]), new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, coalesce(new.nr_z_gate, new.z_ceiling), new.cc_submerged, new.h_open, new.h_close);
            if 'regul_gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'regul_gate_link');
            update model1._link set validity = (select (z_invert is not null) and (z_ceiling is not null) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (action_gate_type is not null) and (z_invert_stop is not null) and (z_ceiling_stop is not null) and (v_max_cms is not null) and (v_max_cms>=0) and (dt_regul_hr is not null) and (mode_regul!='elevation' or z_control_node is not null) and (mode_regul!='elevation' or z_pid_array is not null) and (mode_regul!='elevation' or z_tz_array is not null) and (mode_regul!='elevation' or array_length(z_tz_array, 1)<=10) and (mode_regul!='elevation' or array_length(z_tz_array, 1)>=1) and (mode_regul!='elevation' or array_length(z_tz_array, 2)=2) and (mode_regul!='discharge' or q_z_crit is not null) and (mode_regul!='discharge' or array_length(q_tq_array, 1)<=10) and (mode_regul!='discharge' or array_length(q_tq_array, 1)>=1) and (mode_regul!='discharge' or array_length(q_tq_array, 2)=2) and (mode_regul!='no_regulation' or nr_z_gate is not null) and (mode_regul!='relief' or h_open is not null) and (mode_regul!='relief' or h_close is not null) and (mode_regul!='head' or h_open is not null) and (mode_regul!='head' or h_close is not null) and (mode_regul!='q(h)' or array_length(hq_array, 1)<=10) and (mode_regul!='q(h)' or array_length(hq_array, 1)>=1) and (mode_regul!='q(h)' or array_length(hq_array, 2)=2) and (cc_submerged >0) from  model1._regul_gate_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'regul_gate' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.cc_submerged, new.h_open, new.h_close) is distinct from (old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.z_invert_stop, old.z_ceiling_stop, old.v_max_cms, old.dt_regul_hr, old.mode_regul, old.z_control_node, old.z_pid_array, old.z_tz_array, old.q_z_crit, old.q_tq_array, old.hq_array, old.nr_z_gate, old.cc_submerged, old.h_open, old.h_close)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.z_invert_stop, old.z_ceiling_stop, old.v_max_cms, old.dt_regul_hr, old.mode_regul, old.z_control_node, old.z_pid_array, old.z_tz_array, old.q_z_crit, old.q_tq_array, old.hq_array, old.nr_z_gate, old.cc_submerged, old.h_open, old.h_close) as o, (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.cc_submerged, new.h_open, new.h_close) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.cc_submerged, new.h_open, new.h_close) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._regul_gate_link set z_invert=new.z_invert, z_ceiling=new.z_ceiling, width=new.width, cc=new.cc, action_gate_type=new.action_gate_type, z_invert_stop=new.z_invert_stop, z_ceiling_stop=new.z_ceiling_stop, v_max_cms=new.v_max_cms, dt_regul_hr=new.dt_regul_hr, mode_regul=new.mode_regul, z_control_node=new.z_control_node, z_pid_array=new.z_pid_array, z_tz_array=new.z_tz_array, q_z_crit=new.q_z_crit, q_tq_array=new.q_tq_array, hq_array=new.hq_array, nr_z_gate=new.nr_z_gate, cc_submerged=new.cc_submerged, h_open=new.h_open, h_close=new.h_close where id=old.id;

            if 'regul_gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'regul_gate_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'regul_gate' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null) and (z_ceiling is not null) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (action_gate_type is not null) and (z_invert_stop is not null) and (z_ceiling_stop is not null) and (v_max_cms is not null) and (v_max_cms>=0) and (dt_regul_hr is not null) and (mode_regul!='elevation' or z_control_node is not null) and (mode_regul!='elevation' or z_pid_array is not null) and (mode_regul!='elevation' or z_tz_array is not null) and (mode_regul!='elevation' or array_length(z_tz_array, 1)<=10) and (mode_regul!='elevation' or array_length(z_tz_array, 1)>=1) and (mode_regul!='elevation' or array_length(z_tz_array, 2)=2) and (mode_regul!='discharge' or q_z_crit is not null) and (mode_regul!='discharge' or array_length(q_tq_array, 1)<=10) and (mode_regul!='discharge' or array_length(q_tq_array, 1)>=1) and (mode_regul!='discharge' or array_length(q_tq_array, 2)=2) and (mode_regul!='no_regulation' or nr_z_gate is not null) and (mode_regul!='relief' or h_open is not null) and (mode_regul!='relief' or h_close is not null) and (mode_regul!='head' or h_open is not null) and (mode_regul!='head' or h_close is not null) and (mode_regul!='q(h)' or array_length(hq_array, 1)<=10) and (mode_regul!='q(h)' or array_length(hq_array, 1)>=1) and (mode_regul!='q(h)' or array_length(hq_array, 2)=2) and (cc_submerged >0) from  model1._regul_gate_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._regul_gate_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'regul_gate' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'regul_gate' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="regul_sluice_gate_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'regul_sluice_gate', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'regul_sluice_gate') where name = 'define_later' and id = id_;

            insert into model1._regul_sluice_gate_singularity(id, singularity_type, z_invert, z_ceiling, width, cc, action_gate_type, z_invert_stop, z_ceiling_stop, v_max_cms, dt_regul_hr, mode_regul, z_control_node, z_pid_array, z_tz_array, q_z_crit, q_tq_array, hq_array, nr_z_gate, full_section_discharge_for_headloss, cc_submerged, h_open, h_close)
                values (id_, 'regul_sluice_gate', new.z_invert, new.z_ceiling, new.width, coalesce(new.cc, .6), coalesce(new.action_gate_type, 'upward_opening'), coalesce(new.z_invert_stop, new.z_invert), coalesce(new.z_ceiling_stop, new.z_ceiling), coalesce(new.v_max_cms, .5), coalesce(new.dt_regul_hr, 0), coalesce(new.mode_regul, 'elevation'), new.z_control_node, coalesce(new.z_pid_array, '{1, 0, 0}'::real[]), new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, coalesce(new.nr_z_gate, new.z_ceiling), coalesce(new.full_section_discharge_for_headloss, 't'), new.cc_submerged, new.h_open, new.h_close);
            if 'regul_sluice_gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'regul_sluice_gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'regul_sluice_gate_singularity');
            update model1._singularity set validity = (select (z_invert is not null) and (z_ceiling is not null) and (width is not null) and (width >=0) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (z_invert_stop is not null) and (z_ceiling_stop is not null) and (v_max_cms is not null) and (v_max_cms>=0) and (dt_regul_hr is not null) and (mode_regul!='elevation' or z_control_node is not null) and (mode_regul!='elevation' or z_pid_array is not null) and (mode_regul!='elevation' or z_tz_array is not null) and (mode_regul!='elevation' or array_length(z_tz_array, 1)<=10) and (mode_regul!='elevation' or array_length(z_tz_array, 1)>=1) and (mode_regul!='elevation' or array_length(z_tz_array, 2)=2) and (mode_regul!='discharge' or q_z_crit is not null) and (mode_regul!='discharge' or array_length(q_tq_array, 1)<=10) and (mode_regul!='discharge' or array_length(q_tq_array, 1)>=1) and (mode_regul!='discharge' or array_length(q_tq_array, 2)=2) and (mode_regul!='no_regulation' or nr_z_gate is not null) and (mode_regul!='relief' or h_open is not null) and (mode_regul!='relief' or h_close is not null) and (mode_regul!='q(h)' or array_length(hq_array, 1)<=10) and (mode_regul!='q(h)' or array_length(hq_array, 1)>=1) and (mode_regul!='q(h)' or array_length(hq_array, 2)=2) and (cc_submerged >0) from  model1._regul_sluice_gate_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.full_section_discharge_for_headloss, new.cc_submerged, new.h_open, new.h_close) is distinct from (old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.z_invert_stop, old.z_ceiling_stop, old.v_max_cms, old.dt_regul_hr, old.mode_regul, old.z_control_node, old.z_pid_array, old.z_tz_array, old.q_z_crit, old.q_tq_array, old.hq_array, old.nr_z_gate, old.full_section_discharge_for_headloss, old.cc_submerged, old.h_open, old.h_close)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.z_ceiling, old.width, old.cc, old.action_gate_type, old.z_invert_stop, old.z_ceiling_stop, old.v_max_cms, old.dt_regul_hr, old.mode_regul, old.z_control_node, old.z_pid_array, old.z_tz_array, old.q_z_crit, old.q_tq_array, old.hq_array, old.nr_z_gate, old.full_section_discharge_for_headloss, old.cc_submerged, old.h_open, old.h_close) as o, (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.full_section_discharge_for_headloss, new.cc_submerged, new.h_open, new.h_close) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.z_ceiling, new.width, new.cc, new.action_gate_type, new.z_invert_stop, new.z_ceiling_stop, new.v_max_cms, new.dt_regul_hr, new.mode_regul, new.z_control_node, new.z_pid_array, new.z_tz_array, new.q_z_crit, new.q_tq_array, new.hq_array, new.nr_z_gate, new.full_section_discharge_for_headloss, new.cc_submerged, new.h_open, new.h_close) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._regul_sluice_gate_singularity set z_invert=new.z_invert, z_ceiling=new.z_ceiling, width=new.width, cc=new.cc, action_gate_type=new.action_gate_type, z_invert_stop=new.z_invert_stop, z_ceiling_stop=new.z_ceiling_stop, v_max_cms=new.v_max_cms, dt_regul_hr=new.dt_regul_hr, mode_regul=new.mode_regul, z_control_node=new.z_control_node, z_pid_array=new.z_pid_array, z_tz_array=new.z_tz_array, q_z_crit=new.q_z_crit, q_tq_array=new.q_tq_array, hq_array=new.hq_array, nr_z_gate=new.nr_z_gate, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss, cc_submerged=new.cc_submerged, h_open=new.h_open, h_close=new.h_close where id=old.id;
            if 'regul_sluice_gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'regul_sluice_gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'regul_sluice_gate_singularity');
            update model1._singularity set validity = (select (z_invert is not null) and (z_ceiling is not null) and (width is not null) and (width >=0) and (cc is not null) and (cc <=1) and (cc >=0) and (action_gate_type is not null) and (z_invert_stop is not null) and (z_ceiling_stop is not null) and (v_max_cms is not null) and (v_max_cms>=0) and (dt_regul_hr is not null) and (mode_regul!='elevation' or z_control_node is not null) and (mode_regul!='elevation' or z_pid_array is not null) and (mode_regul!='elevation' or z_tz_array is not null) and (mode_regul!='elevation' or array_length(z_tz_array, 1)<=10) and (mode_regul!='elevation' or array_length(z_tz_array, 1)>=1) and (mode_regul!='elevation' or array_length(z_tz_array, 2)=2) and (mode_regul!='discharge' or q_z_crit is not null) and (mode_regul!='discharge' or array_length(q_tq_array, 1)<=10) and (mode_regul!='discharge' or array_length(q_tq_array, 1)>=1) and (mode_regul!='discharge' or array_length(q_tq_array, 2)=2) and (mode_regul!='no_regulation' or nr_z_gate is not null) and (mode_regul!='relief' or h_open is not null) and (mode_regul!='relief' or h_close is not null) and (mode_regul!='q(h)' or array_length(hq_array, 1)<=10) and (mode_regul!='q(h)' or array_length(hq_array, 1)>=1) and (mode_regul!='q(h)' or array_length(hq_array, 2)=2) and (cc_submerged >0) from  model1._regul_sluice_gate_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'regul_sluice_gate' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._regul_sluice_gate_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'regul_sluice_gate' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reservoir_rs_hydrology_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'reservoir_rs_hydrology', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'reservoir_rs_hydrology') where name = 'define_later' and id = id_;

            insert into model1._reservoir_rs_hydrology_singularity(id, singularity_type, drainage, drainage_type, overflow, overflow_type, q_drainage, z_ini, zs_array, treatment_mode, treatment_param)
                values (id_, 'reservoir_rs_hydrology', new.drainage, coalesce(new.drainage_type, (select link_type from model1._link where id=new.drainage)), new.overflow, coalesce(new.overflow_type, (select link_type from model1._link where id=new.overflow)), new.q_drainage, coalesce(new.z_ini, new.zs_array[1][1]), new.zs_array, coalesce(new.treatment_mode, 'residual_concentration'), new.treatment_param::json);
            if 'reservoir_rs_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'reservoir_rs_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'reservoir_rs_hydrology_singularity');
            update model1._singularity set validity = (select (drainage is not null) and (overflow is not null) and (q_drainage is not null) and (q_drainage>=0) and (z_ini is not null) and (zs_array is not null ) and (treatment_mode is not null) and (array_length(zs_array, 1)<=10) and (array_length(zs_array, 1)>=1) and (array_length(zs_array, 2)=2) from  model1._reservoir_rs_hydrology_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.q_drainage, new.z_ini, new.zs_array, new.treatment_mode, new.treatment_param) is distinct from (old.drainage, old.drainage_type, old.overflow, old.overflow_type, old.q_drainage, old.z_ini, old.zs_array, old.treatment_mode, old.treatment_param)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.drainage, old.drainage_type, old.overflow, old.overflow_type, old.q_drainage, old.z_ini, old.zs_array, old.treatment_mode, old.treatment_param) as o, (select new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.q_drainage, new.z_ini, new.zs_array, new.treatment_mode, new.treatment_param) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.q_drainage, new.z_ini, new.zs_array, new.treatment_mode, new.treatment_param) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._reservoir_rs_hydrology_singularity set drainage=new.drainage, drainage_type=new.drainage_type, overflow=new.overflow, overflow_type=new.overflow_type, q_drainage=new.q_drainage, z_ini=new.z_ini, zs_array=new.zs_array, treatment_mode=new.treatment_mode, treatment_param=new.treatment_param::json where id=old.id;
            if 'reservoir_rs_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'reservoir_rs_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'reservoir_rs_hydrology_singularity');
            update model1._singularity set validity = (select (drainage is not null) and (overflow is not null) and (q_drainage is not null) and (q_drainage>=0) and (z_ini is not null) and (zs_array is not null ) and (treatment_mode is not null) and (array_length(zs_array, 1)<=10) and (array_length(zs_array, 1)>=1) and (array_length(zs_array, 2)=2) from  model1._reservoir_rs_hydrology_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'reservoir_rs_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._reservoir_rs_hydrology_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'reservoir_rs_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="reservoir_rsp_hydrology_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'reservoir_rsp_hydrology', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'reservoir_rsp_hydrology') where name = 'define_later' and id = id_;

            insert into model1._reservoir_rsp_hydrology_singularity(id, singularity_type, drainage, drainage_type, overflow, overflow_type, z_ini, zr_sr_qf_qs_array, treatment_mode, treatment_param)
                values (id_, 'reservoir_rsp_hydrology', new.drainage, coalesce(new.drainage_type, (select link_type from model1._link where id=new.drainage)), new.overflow, coalesce(new.overflow_type, (select link_type from model1._link where id=new.overflow)), coalesce(new.z_ini, new.zr_sr_qf_qs_array[1][1]), new.zr_sr_qf_qs_array, coalesce(new.treatment_mode, 'residual_concentration'), new.treatment_param::json);
            if 'reservoir_rsp_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'reservoir_rsp_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'reservoir_rsp_hydrology_singularity');
            update model1._singularity set validity = (select (drainage is not null) and (overflow is not null) and (z_ini is not null) and (zr_sr_qf_qs_array is not null ) and (treatment_mode is not null) and (treatment_param is not null) and (array_length(zr_sr_qf_qs_array, 1)<=10) and (array_length(zr_sr_qf_qs_array, 1)>=1) and (array_length(zr_sr_qf_qs_array, 2)=4) from  model1._reservoir_rsp_hydrology_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.z_ini, new.zr_sr_qf_qs_array, new.treatment_mode, new.treatment_param) is distinct from (old.drainage, old.drainage_type, old.overflow, old.overflow_type, old.z_ini, old.zr_sr_qf_qs_array, old.treatment_mode, old.treatment_param)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.drainage, old.drainage_type, old.overflow, old.overflow_type, old.z_ini, old.zr_sr_qf_qs_array, old.treatment_mode, old.treatment_param) as o, (select new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.z_ini, new.zr_sr_qf_qs_array, new.treatment_mode, new.treatment_param) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.drainage, new.drainage_type, new.overflow, new.overflow_type, new.z_ini, new.zr_sr_qf_qs_array, new.treatment_mode, new.treatment_param) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._reservoir_rsp_hydrology_singularity set drainage=new.drainage, drainage_type=new.drainage_type, overflow=new.overflow, overflow_type=new.overflow_type, z_ini=new.z_ini, zr_sr_qf_qs_array=new.zr_sr_qf_qs_array, treatment_mode=new.treatment_mode, treatment_param=new.treatment_param::json where id=old.id;
            if 'reservoir_rsp_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'reservoir_rsp_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'reservoir_rsp_hydrology_singularity');
            update model1._singularity set validity = (select (drainage is not null) and (overflow is not null) and (z_ini is not null) and (zr_sr_qf_qs_array is not null ) and (treatment_mode is not null) and (treatment_param is not null) and (array_length(zr_sr_qf_qs_array, 1)<=10) and (array_length(zr_sr_qf_qs_array, 1)>=1) and (array_length(zr_sr_qf_qs_array, 2)=4) from  model1._reservoir_rsp_hydrology_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'reservoir_rsp_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._reservoir_rsp_hydrology_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'reservoir_rsp_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_cross_section_pl1d_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id from model1.river_node where ST_DWithin(new.profile, geom, .1) into id_;
            if id_ is null then
                raise exception 'no river node nearby river_cross_section_pl1d %', st_astext(new.geom);
            end if;
            insert into model1._river_cross_section_pl1d
                values (id_, coalesce(new.name, 'PL1D'||id_::varchar), new.profile, new.generated);
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            update model1._river_cross_section_pl1d set name=new.name, profile=new.profile, generated=new.generated where id=old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._river_cross_section_pl1d where id=old.id;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_cross_section_profile_del_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        delete from model1._river_cross_section_profile where id=old.id;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_cross_section_profile_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        select (
            (new.type_cross_section_up is null or (
                new.z_invert_up is not null
                and new.up_rk is not null
                and (new.type_cross_section_up!='circular' or (new.up_circular_diameter is not null and new.up_circular_diameter > 0))
                and (new.type_cross_section_up!='ovoid' or (new.up_ovoid_top_diameter is not null and new.up_ovoid_top_diameter > 0))
                and (new.type_cross_section_up!='ovoid' or (new.up_ovoid_invert_diameter is not null and new.up_ovoid_invert_diameter > 0))
                and (new.type_cross_section_up!='ovoid' or (new.up_ovoid_height is not null and new.up_ovoid_height >0 ))
                and (new.type_cross_section_up!='ovoid' or (new.up_ovoid_height > (new.up_ovoid_top_diameter+new.up_ovoid_invert_diameter)/2))
                and (new.type_cross_section_up!='pipe' or new.up_cp_geom is not null)
                and (new.type_cross_section_up!='channel' or new.up_op_geom is not null)
                and (new.type_cross_section_up!='valley'
                        or (new.up_rk = 0 and new.up_rk_maj = 0 and new.up_sinuosity = 0)
                        or (new.up_rk >0 and new.up_rk_maj is not null and new.up_rk_maj > 0 and new.up_sinuosity is not null and new.up_sinuosity > 0))
                and (new.type_cross_section_up!='valley' or new.up_vcs_geom is not null)
                )
            )
            and
            (new.type_cross_section_down is null or (
                new.z_invert_down is not null
                and new.down_rk is not null
                and (new.type_cross_section_down!='circular' or (new.down_circular_diameter is not null and new.down_circular_diameter > 0))
                and (new.type_cross_section_down!='ovoid' or (new.down_ovoid_top_diameter is not null and new.down_ovoid_top_diameter > 0))
                and (new.type_cross_section_down!='ovoid' or (new.down_ovoid_invert_diameter is not null and new.down_ovoid_invert_diameter > 0))
                and (new.type_cross_section_down!='ovoid' or (new.down_ovoid_height is not null and new.down_ovoid_height >0 ))
                and (new.type_cross_section_down!='ovoid' or (new.down_ovoid_height > (new.down_ovoid_top_diameter+new.down_ovoid_invert_diameter)/2))
                and (new.type_cross_section_down!='pipe' or new.down_cp_geom is not null)
                and (new.type_cross_section_down!='channel' or new.down_op_geom is not null)
                and (new.type_cross_section_down!='valley'
                        or (new.down_rk = 0 and new.down_rk_maj = 0 and new.down_sinuosity = 0)
                        or (new.down_rk >0 and new.down_rk_maj is not null and new.down_rk_maj > 0 and new.down_sinuosity is not null and new.down_sinuosity > 0))
                and (new.type_cross_section_down!='valley' or new.down_vcs_geom is not null)
                )
            )
            and
            (new.type_cross_section_up is null or new.type_cross_section_down is null or (
                new.z_invert_up is not null and new.z_invert_down is not null
                )
            )
        ) into new.validity;

        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id from model1.river_node where ST_DWithin(new.geom, geom, .1) into new.id;
            select coalesce(new.name, 'CP'||new.id::varchar) into new.name;
            if new.id is null then
                raise exception 'no river node nearby river_cross_section_profile %', st_astext(new.geom);
            end if;

            insert into model1._river_cross_section_profile (
                    id,
                    name,
                    z_invert_up,
                    z_invert_down,
                    type_cross_section_up,
                    type_cross_section_down,
                    up_rk,
                    up_rk_maj,
                    up_sinuosity,
                    up_circular_diameter,
                    up_ovoid_height,
                    up_ovoid_top_diameter,
                    up_ovoid_invert_diameter,
                    up_cp_geom,
                    up_op_geom,
                    up_vcs_geom,
                    up_vcs_topo_geom,
                    down_rk,
                    down_rk_maj,
                    down_sinuosity,
                    down_circular_diameter,
                    down_ovoid_height,
                    down_ovoid_top_diameter,
                    down_ovoid_invert_diameter,
                    down_cp_geom,
                    down_op_geom,
                    down_vcs_geom,
                    down_vcs_topo_geom,
                    configuration,
                    validity,
                    comment
                )
                values (
                    new.id,
                    new.name,
                    new.z_invert_up,
                    new.z_invert_down,
                    new.type_cross_section_up,
                    new.type_cross_section_down,
                    new.up_rk,
                    new.up_rk_maj,
                    new.up_sinuosity,
                    new.up_circular_diameter,
                    new.up_ovoid_height,
                    new.up_ovoid_top_diameter,
                    new.up_ovoid_invert_diameter,
                    new.up_cp_geom,
                    new.up_op_geom,
                    new.up_vcs_geom,
                    new.up_vcs_topo_geom,
                    new.down_rk,
                    new.down_rk_maj,
                    new.down_sinuosity,
                    new.down_circular_diameter,
                    new.down_ovoid_height,
                    new.down_ovoid_top_diameter,
                    new.down_ovoid_invert_diameter,
                    new.down_cp_geom,
                    new.down_op_geom,
                    new.down_vcs_geom,
                    new.down_vcs_topo_geom,
                    new.configuration::json,
                    new.validity,
                    new.comment
                );
            if new.z_invert_up is not null or new.z_invert_down is not null then
                update model1.river_node
                    set geom=ST_SetSRID(ST_MakePoint(ST_X(geom), ST_Y(geom), coalesce(model1.river_node_z_invert(geom), project.altitude(geom))), 2154)
                    where reach=(select reach from model1.river_node where id=new.id);
            end if;

            perform model1.add_configuration_fct(new.configuration::json, new.id, 'river_cross_section_profile');

            return new;
        elsif tg_op = 'UPDATE' then
            /* find the node if not specified */
            select id from model1.river_node where ST_DWithin(new.geom, geom, .1) into new.id;
            select coalesce(new.name, 'CP'||new.id::varchar) into new.name;
            if new.id is null then
                raise exception 'no river node nearby river_cross_section_profile %', st_astext(new.geom);
            end if;

            -- Handle configurations
            if ((new.z_invert_up, new.z_invert_down,
                    new.type_cross_section_up, new.type_cross_section_down,
                    new.up_rk, new.up_rk_maj, new.up_sinuosity, new.up_circular_diameter,
                    new.up_ovoid_height, new.up_ovoid_top_diameter, new.up_ovoid_invert_diameter,
                    new.up_cp_geom, new.up_op_geom, new.up_vcs_geom, new.up_vcs_topo_geom,
                    new.down_rk, new.down_rk_maj, new.down_sinuosity, new.down_circular_diameter,
                    new.down_ovoid_height, new.down_ovoid_top_diameter, new.down_ovoid_invert_diameter,
                    new.down_cp_geom, new.down_op_geom, new.down_vcs_geom, new.down_vcs_topo_geom)
            is distinct from (old.z_invert_up, old.z_invert_down,
                    old.type_cross_section_up, old.type_cross_section_down,
                    old.up_rk, old.up_rk_maj, old.up_sinuosity, old.up_circular_diameter,
                    old.up_ovoid_height, old.up_ovoid_top_diameter, old.up_ovoid_invert_diameter,
                    old.up_cp_geom, old.up_op_geom, old.up_vcs_geom, old.up_vcs_topo_geom,
                    old.down_rk, old.down_rk_maj, old.down_sinuosity, old.down_circular_diameter,
                    old.down_ovoid_height, old.down_ovoid_top_diameter, old.down_ovoid_invert_diameter,
                    old.down_cp_geom, old.down_op_geom, old.down_vcs_geom, old.down_vcs_topo_geom))
            then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}'
                            from (select old.z_invert_up, old.z_invert_down,
                                old.type_cross_section_up, old.type_cross_section_down,
                                old.up_rk, old.up_rk_maj, old.up_sinuosity, old.up_circular_diameter,
                                old.up_ovoid_height, old.up_ovoid_top_diameter, old.up_ovoid_invert_diameter,
                                old.up_cp_geom, old.up_op_geom, old.up_vcs_geom, old.up_vcs_topo_geom,
                                old.down_rk, old.down_rk_maj, old.down_sinuosity, old.down_circular_diameter,
                                old.down_ovoid_height, old.down_ovoid_top_diameter, old.down_ovoid_invert_diameter,
                                old.down_cp_geom, old.down_op_geom, old.down_vcs_geom, old.down_vcs_topo_geom) as o,
                                (select new.z_invert_up, new.z_invert_down,
                                new.type_cross_section_up, new.type_cross_section_down,
                                new.up_rk, new.up_rk_maj, new.up_sinuosity, new.up_circular_diameter,
                                new.up_ovoid_height, new.up_ovoid_top_diameter, new.up_ovoid_invert_diameter,
                                new.up_cp_geom, new.up_op_geom, new.up_vcs_geom, new.up_vcs_topo_geom,
                                new.down_rk, new.down_rk_maj, new.down_sinuosity, new.down_circular_diameter,
                                new.down_ovoid_height, new.down_ovoid_top_diameter, new.down_ovoid_invert_diameter,
                                new.down_cp_geom, new.down_op_geom, new.down_vcs_geom, new.down_vcs_topo_geom) as n
                            into new_config;
                        update model1._river_cross_section_profile set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}'
                            from (select new.z_invert_up, new.z_invert_down,
                                new.type_cross_section_up, new.type_cross_section_down,
                                new.up_rk, new.up_rk_maj, new.up_sinuosity, new.up_circular_diameter,
                                new.up_ovoid_height, new.up_ovoid_top_diameter, new.up_ovoid_invert_diameter,
                                new.up_cp_geom, new.up_op_geom, new.up_vcs_geom, new.up_vcs_topo_geom,
                                new.down_rk, new.down_rk_maj, new.down_sinuosity, new.down_circular_diameter,
                                new.down_ovoid_height, new.down_ovoid_top_diameter, new.down_ovoid_invert_diameter,
                                new.down_cp_geom, new.down_op_geom, new.down_vcs_geom, new.down_vcs_topo_geom) n
                            into new_config;
                        update model1._river_cross_section_profile set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._river_cross_section_profile set
                id=new.id,
                name=new.name,
                z_invert_up=new.z_invert_up,
                z_invert_down=new.z_invert_down,
                type_cross_section_up=new.type_cross_section_up,
                type_cross_section_down=new.type_cross_section_down,
                up_rk=new.up_rk,
                up_rk_maj=new.up_rk_maj,
                up_sinuosity=new.up_sinuosity,
                up_circular_diameter=new.up_circular_diameter,
                up_ovoid_height=new.up_ovoid_height,
                up_ovoid_top_diameter=new.up_ovoid_top_diameter,
                up_ovoid_invert_diameter=new.up_ovoid_invert_diameter,
                up_cp_geom=new.up_cp_geom,
                up_op_geom=new.up_op_geom,
                up_vcs_geom=new.up_vcs_geom,
                up_vcs_topo_geom=new.up_vcs_topo_geom,
                down_rk=new.down_rk,
                down_rk_maj=new.down_rk_maj,
                down_sinuosity=new.down_sinuosity,
                down_circular_diameter=new.down_circular_diameter,
                down_ovoid_height=new.down_ovoid_height,
                down_ovoid_top_diameter=new.down_ovoid_top_diameter,
                down_ovoid_invert_diameter=new.down_ovoid_invert_diameter,
                down_cp_geom=new.down_cp_geom,
                down_op_geom=new.down_op_geom,
                down_vcs_geom=new.down_vcs_geom,
                down_vcs_topo_geom=new.down_vcs_topo_geom,
                validity=new.validity,
                comment=new.comment
            where id=old.id;

            if new.z_invert_up != old.z_invert_down or new.z_invert_down != old.z_invert_down then
                update model1.river_node
                    set geom=ST_SetSRID(ST_MakePoint(ST_X(geom), ST_Y(geom), coalesce(model1.river_node_z_invert(geom), project.altitude(geom))), 2154)
                    where reach=(select reach from model1.river_node where id=new.id);
            end if;

            perform model1.add_configuration_fct(new.configuration::json, new.id, 'river_cross_section_profile');

            return new;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('river', coalesce(new.name, 'define_later'), (ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(model1.river_node_z_invert(new.geom), project.altitude(new.geom))), 2154)), new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'river') where name = 'define_later' and id = new.id;
            insert into model1._river_node(id, node_type, reach, z_ground, area)
                values (new.id, 'river', coalesce(new.reach, (select id from model1.reach where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) asc limit 1)), coalesce(new.z_ground, (project.altitude(new.geom))), coalesce(new.area, 1))
                returning reach, z_ground, area into new.reach, new.z_ground, new.area;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'river_node');

            -- Lines to update specific nodes that works with associated contours
            if 'river' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (z_ground is not null) and (area is not null) and (area>0) and (reach is not null) and ((select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))) from  model1._river_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_ground, new.area) is distinct from (old.z_ground, old.area)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_ground, old.area) as o, (select new.z_ground, new.area) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_ground, new.area) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=(ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(model1.river_node_z_invert(new.geom), project.altitude(new.geom))), 2154)), generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._river_node set reach=new.reach, z_ground=new.z_ground, area=new.area where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'river_node');

            -- Lines to update specific nodes that works with associated contours
            if 'river' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'river' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'river' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (z_ground is not null) and (area is not null) and (area>0) and (reach is not null) and ((select not exists(select 1 from model1.station where st_intersects(geom, new.geom)))) from  model1._river_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'river' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._river_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_node_pk(node_geom geometry)" returnType="double precision" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _res real;
    begin
        select st_linelocatepoint(r.geom, node_geom) * st_length(r.geom) / 1000::double precision + r.pk0_km
            from model1.reach as r
            where ST_DWithin(r.geom, node_geom, .1) order by ST_Distance(r.geom, node_geom) asc limit 1
            into _res;
        return _res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="node_geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="river_node_z_invert(node_geom geometry)" returnType="real" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _res real;
    begin
        with node as (
                select model1.river_node_pk(node_geom) as pk_km, id as reach from model1.reach as r
                where ST_DWithin(r.geom, node_geom, .1) order by ST_Distance(r.geom, node_geom) asc limit 1
            ),
            pts_up as (
                select p.id, model1.river_node_pk(p.geom) as pk_km, COALESCE(z_invert_down, z_invert_up) as z_invert
                from model1._river_node as n, node, model1.river_cross_section_profile as p
                where n.reach=node.reach and p.id=n.id and model1.river_node_pk(p.geom) <= node.pk_km
                ),
            pts_down as (
                select p.id, model1.river_node_pk(p.geom) as pk_km, COALESCE(z_invert_up, z_invert_down) as z_invert
                from model1._river_node as n, node, model1.river_cross_section_profile as p
                where n.reach=node.reach and p.id=n.id and node.pk_km <= model1.river_node_pk(p.geom)
                ),
            up as (
                select z_invert, pk_km, id from pts_up
                where z_invert is not null
                order by pk_km desc limit 1
                ),
            down as (
                select z_invert, pk_km, id from pts_down
                where z_invert is not null
                order by pk_km asc limit 1
                ),
            cote_minmax as (
                select up.z_invert as cote, COALESCE(NULLIF(down.pk_km - node.pk_km, 0), 1) as weight from up, down, node
                union all
                select down.z_invert as cote, COALESCE(NULLIF(node.pk_km - up.pk_km, 0), 1) as weight from up, down, node
            ),
            z_invert as (
                select SUM(cote * weight)/SUM(weight) as z
                from cote_minmax
                having bool_and(cote is not null)
            )
            select case
                when not exists (select 1 from z_invert) then null
                else (select z from z_invert) end
            into _res;
        return _res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="node_geom" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="routing_hydrology_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'routing_hydrology' = 'routing_hydrology' or 'routing_hydrology' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('routing_hydrology', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'routing_hydrology') where name = 'define_later' and id = id_;
            insert into model1._routing_hydrology_link(id, link_type, cross_section, length, slope, hydrograph, split_coef)
                values (id_, 'routing_hydrology', coalesce(new.cross_section, 1), coalesce(new.length, 0.1), coalesce(new.slope, .01), coalesce(new.hydrograph, (select hbc.id from model1.hydrograph_bc_singularity as hbc where ST_DWithin(ST_EndPoint(new.geom), hbc.geom, .1))), coalesce(new.split_coef, 1));
            if 'routing_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'routing_hydrology_link');
            update model1._link set validity = (select (cross_section is not null) and (cross_section>=0) and (length is not null) and (length>=0) and (slope is not null) and (down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'crossroad', 'storage', 'elem_2d') and (hydrograph is not null))) and (split_coef is not null) and (split_coef>=0) from  model1._routing_hydrology_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'routing_hydrology' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.cross_section, new.length, new.slope, new.split_coef) is distinct from (old.cross_section, old.length, old.slope, old.split_coef)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.cross_section, old.length, old.slope, old.split_coef) as o, (select new.cross_section, new.length, new.slope, new.split_coef) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.cross_section, new.length, new.slope, new.split_coef) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._routing_hydrology_link set cross_section=new.cross_section, length=new.length, slope=new.slope, hydrograph=new.hydrograph, split_coef=new.split_coef where id=old.id;

            if 'routing_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'routing_hydrology_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'routing_hydrology' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (cross_section is not null) and (cross_section>=0) and (length is not null) and (length>=0) and (slope is not null) and (down_type='manhole_hydrology' or (down_type in ('manhole', 'river', 'station', 'crossroad', 'storage', 'elem_2d') and (hydrograph is not null))) and (split_coef is not null) and (split_coef>=0) from  model1._routing_hydrology_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._routing_hydrology_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'routing_hydrology' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'routing_hydrology' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="section_interpolate_point(line geometry, section real[], fraction real, side character varying DEFAULT NULL::character varying)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
    l_ real;
    s_ real[];
    z_ real;
    p_ geometry;
    idx integer;
    alp real;
begin
    if side = 'left' then
        l_ := section[4][2] + section[10][2]/2.;
        s_ = array[array[0                                     , section[4][1]],
                   array[l_ - section[3][2] - section[10][2]/2., section[3][1]],
                   array[l_ - section[2][2] - section[10][2]/2., section[2][1]],
                   array[l_ - section[1][2] - section[10][2]/2., section[1][1]],
                   array[l_ - .5*section[10][2], section[10][1]],
                   array[l_ -  .5*section[9][2],  section[9][1]],
                   array[l_ -  .5*section[8][2],  section[8][1]],
                   array[l_ -  .5*section[7][2],  section[7][1]],
                   array[l_ -  .5*section[6][2],  section[6][1]],
                   array[l_ -  .5*section[5][2],  section[5][1]],
                   array[l_ , section[5][1]]
                ];
        p_ := ST_LineInterpolatePoint(ST_MakeLine(ST_StartPoint(line), st_pointn(line, 2)), fraction);
    elsif side = 'right' then
        l_ := section[14][2] + section[10][2]/2.;
        s_ = array[array[0                                      , section[14][1]],
                   array[l_ - section[13][2] - section[10][2]/2., section[13][1]],
                   array[l_ - section[12][2] - section[10][2]/2., section[12][1]],
                   array[l_ - section[11][2] - section[10][2]/2., section[11][1]],
                   array[l_ - .5*section[10][2], section[10][1]],
                   array[l_ -  .5*section[9][2],  section[9][1]],
                   array[l_ -  .5*section[8][2],  section[8][1]],
                   array[l_ -  .5*section[7][2],  section[7][1]],
                   array[l_ -  .5*section[6][2],  section[6][1]],
                   array[l_ -  .5*section[5][2],  section[5][1]],
                   array[l_ , section[5][1]]
                ];
        p_ := ST_LineInterpolatePoint(ST_MakeLine(ST_EndPoint(line), st_pointn(line, 2)), fraction);
    else
        l_ := section[4][2] + section[14][2] + section[10][2];
        s_ = array[array[0                                                   , section[4][1]],
                   array[l_ - section[3][2] - section[10][2] - section[14][2], section[3][1]],
                   array[l_ - section[2][2] - section[10][2] - section[14][2], section[2][1]],
                   array[l_ - section[1][2] - section[10][2] - section[14][2], section[1][1]],
                   array[l_ - section[10][2] - section[14][2], section[10][1]],
                   array[l_ - section[9][2] - section[14][2],  section[9][1]],
                   array[l_ - section[8][2] - section[14][2],  section[8][1]],
                   array[l_ - section[7][2] - section[14][2],  section[7][1]],
                   array[l_ - section[6][2] - section[14][2],  section[6][1]],
                   array[l_ - section[5][2] - section[14][2],  section[5][1]],
                   array[l_ - .5*section[5][2] - section[14][2], section[5][1]],
                   array[l_ - .5*section[6][2] - section[14][2], section[6][1]],
                   array[l_ - .5*section[7][2] - section[14][2], section[7][1]],
                   array[l_ - .5*section[8][2] - section[14][2], section[8][1]],
                   array[l_ - .5*section[9][2] - section[14][2], section[9][1]],
                   array[l_ - .5*section[10][2] - section[14][2], section[10][1]],
                   array[l_ - section[14][2],  section[11][1]],
                   array[l_ - section[14][2] + section[12][2],  section[12][1]],
                   array[l_ - section[14][2] + section[13][2],  section[13][1]],
                   array[l_ ,  section[14][1]]
                ];
        p_ := ST_LineInterpolatePoint(line, fraction);
    end if;

    if l_*fraction = s_[array_length(s_,1)][1] then
        return ST_SetSRID(ST_MakePoint(ST_X(p_), ST_Y(p_), s_[array_length(s_,1)][2]), ST_SRID(line));
    end if;

    select s_[i-1][2]*(1. - (l_*fraction - s_[i-1][1])/(s_[i][1] - s_[i-1][1])) + s_[i][2]*(l_*fraction - s_[i-1][1])/(s_[i][1] - s_[i-1][1]), i, (l_*fraction - s_[i-1][1])/(s_[i][1] - s_[i-1][1])
    from generate_subscripts(s_, 1) as i
    where i > 1
    and s_[i-1][1] <= l_*fraction
    and s_[i][1] > l_*fraction
    into z_, idx, alp;

    if z_ is null then
        raise 'we have a problem % %/% % % % % %', side, l_*fraction, l_, idx, alp, z_, s_, line;
    end if;
    --raise notice 's_ % %', l_*fraction, s_;
    --raise notice 'z_ % % %', z_, idx, alp;
    return ST_SetSRID(ST_MakePoint(ST_X(p_), ST_Y(p_), z_) ,ST_SRID(line));
end]]></definition>
         <parameters>
            <parameter mode="IN" name="line" type="geometry"/>
            <parameter mode="IN" name="section" type="real[]"/>
            <parameter mode="IN" name="fraction" type="real"/>
            <parameter mode="IN" name="side" type="character varying"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_link_altitude(link_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import set_link_altitude
    return set_link_altitude(plpy, link_id, 'model1', 2154)]]></definition>
         <parameters>
            <parameter mode="IN" name="link_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_link_altitude_topo(link_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpython3u"><![CDATA[import plpy
    from hydra_3_10_10 import set_link_altitude_topo
    return set_link_altitude_topo(plpy, link_id, 'model1', 2154)]]></definition>
         <parameters>
            <parameter mode="IN" name="link_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_link_ext_z(link_id integer)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin

        update model1._link as l
        set geom=ST_SetPoint(
                    ST_SetPoint(
                        l.geom,
                        0,
                        ST_MakePoint(
                            ST_X(ST_StartPoint(l.geom)),
                            ST_Y(ST_StartPoint(l.geom)),
                            ST_Z(nup.geom)
                            )
                        ),
                    -1,
                    ST_MakePoint(
                        ST_X(ST_EndPoint(l.geom)),
                        ST_Y(ST_EndPoint(l.geom)),
                        ST_Z(ndown.geom)
                        )
                    )
        from model1._node as nup, model1._node as ndown
        where l.id=link_id and nup.id=l.up and ndown.id=l.down;

        return 't';
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="link_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_link_z_and_altitude(link_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _res integer;
    begin
        perform model1.set_link_ext_z(link_id);

        select model1.set_link_altitude(link_id) into _res;

        return _res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="link_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="set_reach_point_altitude(point geometry)" returnType="geometry" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        transect geometry;
        section real[];
        reach geometry;
    begin
        transect :=  model1.interpolate_transect_at(point);
        select geom from model1.reach order by ST_Distance(transect, geom) limit 1 into reach;
        section := (model1.valley_section_at(ST_ClosestPoint(reach, transect))).section;
        return ST_SetSRID(
            ST_MakePoint(
                ST_X(point),
                ST_Y(point),
                ST_Z(model1.section_interpolate_point(transect, section, ST_LineLocatePoint(transect, point)::real))
            ),
            ST_SRID(point)
        );
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="point" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="singularity_invalidity_reason(id_ integer)" returnType="character varying" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
            reason varchar;
        begin
            reason := '';
            if not (select flow >= 0 from model1.air_flow_bc_singularity as new where id=id_) then
               reason := reason || '   flow >= 0   ';
               end if;

if not (select is_inwards is not null from model1.air_flow_bc_singularity as new where id=id_) then
               reason := reason || '   is_inwards is not null   ';
               end if;

if not (select relative_pressure is not null from model1.air_pressure_bc_singularity as new where id=id_) then
               reason := reason || '   relative_pressure is not null   ';
               end if;

if not (select zq_array is not null from model1.zq_bc_singularity as new where id=id_) then
               reason := reason || '   zq_array is not null   ';
               end if;

if not (select array_length(zq_array, 1)<=20 from model1.zq_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 1)<=20   ';
               end if;

if not (select array_length(zq_array, 1)>=1 from model1.zq_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 1)>=1   ';
               end if;

if not (select array_length(zq_array, 2)=2 from model1.zq_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 2)=2   ';
               end if;

if not (select downstream is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   downstream is not null   ';
               end if;

if not (select split1 is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split1 is not null   ';
               end if;

if not (select downstream_param is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   downstream_param is not null   ';
               end if;

if not (select split1_law is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split1_law is not null   ';
               end if;

if not (select split1_param is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split1_param is not null   ';
               end if;

if not (select split2 is null or split2_law is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split2 is null or split2_law is not null   ';
               end if;

if not (select split2 is null or split2_param is not null from model1.zq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split2 is null or split2_param is not null   ';
               end if;

if not (select pk0_km is not null from model1.pipe_branch_marker_singularity as new where id=id_) then
               reason := reason || '   pk0_km is not null   ';
               end if;

if not (select dx is not null from model1.pipe_branch_marker_singularity as new where id=id_) then
               reason := reason || '   dx is not null   ';
               end if;

if not (select dx>=0.1 from model1.pipe_branch_marker_singularity as new where id=id_) then
               reason := reason || '   dx>=0.1   ';
               end if;

if not (select slope is not null from model1.strickler_bc_singularity as new where id=id_) then
               reason := reason || '   slope is not null   ';
               end if;

if not (select k is not null from model1.strickler_bc_singularity as new where id=id_) then
               reason := reason || '   k is not null   ';
               end if;

if not (select k>0 from model1.strickler_bc_singularity as new where id=id_) then
               reason := reason || '   k>0   ';
               end if;

if not (select width is not null from model1.strickler_bc_singularity as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.strickler_bc_singularity as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select cascade_mode is not null from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   cascade_mode is not null   ';
               end if;

if not (select cascade_mode='hydrograph' or zq_array is not null or tz_array is not null from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   cascade_mode=''hydrograph'' or zq_array is not null or tz_array is not null   ';
               end if;

if not (select array_length(zq_array, 1)<=20 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 1)<=20   ';
               end if;

if not (select array_length(zq_array, 1)>=1 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 1)>=1   ';
               end if;

if not (select array_length(zq_array, 2)=2 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zq_array, 2)=2   ';
               end if;

if not (select array_length(tz_array, 1)<=20 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(tz_array, 1)<=20   ';
               end if;

if not (select array_length(tz_array, 1)>=1 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(tz_array, 1)>=1   ';
               end if;

if not (select array_length(tz_array, 2)=2 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(tz_array, 2)=2   ';
               end if;

if not (select array_length(quality, 1)=9 from model1.model_connect_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(quality, 1)=9   ';
               end if;

if not (select d_abutment_l is not null from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   d_abutment_l is not null   ';
               end if;

if not (select d_abutment_r is not null from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   d_abutment_r is not null   ';
               end if;

if not (select abutment_type is not null from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   abutment_type is not null   ';
               end if;

if not (select zw_array is not null  from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   zw_array is not null    ';
               end if;

if not (select z_ceiling is not null from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   z_ceiling is not null   ';
               end if;

if not (select array_length(zw_array, 1)<=10 from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 1)<=10   ';
               end if;

if not (select array_length(zw_array, 1)>=1 from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 1)>=1   ';
               end if;

if not (select array_length(zw_array, 2)=2 from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 2)=2   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.bradley_headloss_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select l_road is not null from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   l_road is not null   ';
               end if;

if not (select l_road>=0 from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   l_road>=0   ';
               end if;

if not (select z_road is not null from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   z_road is not null   ';
               end if;

if not (select zw_array is not null  from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   zw_array is not null    ';
               end if;

if not (select array_length(zw_array, 1)<=10 from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 1)<=10   ';
               end if;

if not (select array_length(zw_array, 1)>=1 from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 1)>=1   ';
               end if;

if not (select array_length(zw_array, 2)=2 from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(zw_array, 2)=2   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.bridge_headloss_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select qz_array is not null from model1.hydraulic_cut_singularity as new where id=id_) then
               reason := reason || '   qz_array is not null   ';
               end if;

if not (select array_length(qz_array, 1)<=10 from model1.hydraulic_cut_singularity as new where id=id_) then
               reason := reason || '   array_length(qz_array, 1)<=10   ';
               end if;

if not (select array_length(qz_array, 1)>=1 from model1.hydraulic_cut_singularity as new where id=id_) then
               reason := reason || '   array_length(qz_array, 1)>=1   ';
               end if;

if not (select array_length(qz_array, 2)=2 from model1.hydraulic_cut_singularity as new where id=id_) then
               reason := reason || '   array_length(qz_array, 2)=2   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.hydraulic_cut_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select drainage is not null from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   drainage is not null   ';
               end if;

if not (select overflow is not null from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   overflow is not null   ';
               end if;

if not (select z_ini is not null from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   z_ini is not null   ';
               end if;

if not (select zr_sr_qf_qs_array is not null  from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   zr_sr_qf_qs_array is not null    ';
               end if;

if not (select treatment_mode is not null from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   treatment_mode is not null   ';
               end if;

if not (select treatment_param is not null from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   treatment_param is not null   ';
               end if;

if not (select array_length(zr_sr_qf_qs_array, 1)<=10 from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zr_sr_qf_qs_array, 1)<=10   ';
               end if;

if not (select array_length(zr_sr_qf_qs_array, 1)>=1 from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zr_sr_qf_qs_array, 1)>=1   ';
               end if;

if not (select array_length(zr_sr_qf_qs_array, 2)=4 from model1.reservoir_rsp_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zr_sr_qf_qs_array, 2)=4   ';
               end if;

if not (select storage_area is not null from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   storage_area is not null   ';
               end if;

if not (select storage_area>=0 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   storage_area>=0   ';
               end if;

if not (select constant_dry_flow is not null from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   constant_dry_flow is not null   ';
               end if;

if not (select constant_dry_flow>=0 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   constant_dry_flow>=0   ';
               end if;

if not (select distrib_coef is null or distrib_coef>=0 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   distrib_coef is null or distrib_coef>=0   ';
               end if;

if not (select lag_time_hr is null or (lag_time_hr>=0) from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   lag_time_hr is null or (lag_time_hr>=0)   ';
               end if;

if not (select sector is null or (distrib_coef is not null and lag_time_hr is not null) from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   sector is null or (distrib_coef is not null and lag_time_hr is not null)   ';
               end if;

if not (select array_length(pollution_dryweather_runoff, 1)=2 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(pollution_dryweather_runoff, 1)=2   ';
               end if;

if not (select array_length(pollution_dryweather_runoff, 2)=4 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(pollution_dryweather_runoff, 2)=4   ';
               end if;

if not (select array_length(quality_dryweather_runoff, 1)=2 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(quality_dryweather_runoff, 1)=2   ';
               end if;

if not (select array_length(quality_dryweather_runoff, 2)=9 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(quality_dryweather_runoff, 2)=9   ';
               end if;

if not (select external_file_data or tq_array is not null from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or tq_array is not null   ';
               end if;

if not (select external_file_data or array_length(tq_array, 1)<=10 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tq_array, 1)<=10   ';
               end if;

if not (select external_file_data or array_length(tq_array, 1)>=1 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tq_array, 1)>=1   ';
               end if;

if not (select external_file_data or array_length(tq_array, 2)=2 from model1.hydrograph_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tq_array, 2)=2   ';
               end if;

if not (select z_invert is not null  from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   z_invert is not null    ';
               end if;

if not (select z_regul is not null  from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   z_regul is not null    ';
               end if;

if not (select width is not null from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select cc is not null from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0 from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   cc>=0   ';
               end if;

if not (select mode_regul is not null from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   mode_regul is not null   ';
               end if;

if not (select reoxy_law is not null from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   reoxy_law is not null   ';
               end if;

if not (select reoxy_param is not null from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   reoxy_param is not null   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.zregul_weir_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select qq_array is not null from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   qq_array is not null   ';
               end if;

if not (select downstream is not null from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   downstream is not null   ';
               end if;

if not (select split1 is not null from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   split1 is not null   ';
               end if;

if not (select array_length(qq_array, 1)<=10 from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(qq_array, 1)<=10   ';
               end if;

if not (select array_length(qq_array, 1)>=1 from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(qq_array, 1)>=1   ';
               end if;

if not (select (split2 is not null and array_length(qq_array, 2)=3) or (split2 is null and array_length(qq_array, 2)=2) from model1.qq_split_hydrology_singularity as new where id=id_) then
               reason := reason || '   (split2 is not null and array_length(qq_array, 2)=3) or (split2 is null and array_length(qq_array, 2)=2)   ';
               end if;

if not (select zs_array is not null  from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   zs_array is not null    ';
               end if;

if not (select zini is not null from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   zini is not null   ';
               end if;

if not (select array_length(zs_array, 1)<=10 from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1)<=10   ';
               end if;

if not (select array_length(zs_array, 1)>=1 from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1)>=1   ';
               end if;

if not (select array_length(zs_array, 2)=2 from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 2)=2   ';
               end if;

if not (select treatment_mode is not null from model1.tank_bc_singularity as new where id=id_) then
               reason := reason || '   treatment_mode is not null   ';
               end if;

if not (select drainage is not null from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   drainage is not null   ';
               end if;

if not (select overflow is not null from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   overflow is not null   ';
               end if;

if not (select q_drainage is not null from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   q_drainage is not null   ';
               end if;

if not (select q_drainage>=0 from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   q_drainage>=0   ';
               end if;

if not (select z_ini is not null from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   z_ini is not null   ';
               end if;

if not (select zs_array is not null  from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   zs_array is not null    ';
               end if;

if not (select treatment_mode is not null from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   treatment_mode is not null   ';
               end if;

if not (select array_length(zs_array, 1)<=10 from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1)<=10   ';
               end if;

if not (select array_length(zs_array, 1)>=1 from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 1)>=1   ';
               end if;

if not (select array_length(zs_array, 2)=2 from model1.reservoir_rs_hydrology_singularity as new where id=id_) then
               reason := reason || '   array_length(zs_array, 2)=2   ';
               end if;

if not (select q_dz_array is not null from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   q_dz_array is not null   ';
               end if;

if not (select array_length(q_dz_array, 1)<=10 from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(q_dz_array, 1)<=10   ';
               end if;

if not (select array_length(q_dz_array, 1)>=1 from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(q_dz_array, 1)>=1   ';
               end if;

if not (select array_length(q_dz_array, 2)=2 from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   array_length(q_dz_array, 2)=2   ';
               end if;

if not (select q_dz_array[1][1]=0 from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   q_dz_array[1][1]=0   ';
               end if;

if not (select q_dz_array[1][2]=0 from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   q_dz_array[1][2]=0   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.param_headloss_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select external_file_data or tz_array is not null from model1.tz_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or tz_array is not null   ';
               end if;

if not (select external_file_data or array_length(tz_array, 1)<=10 from model1.tz_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tz_array, 1)<=10   ';
               end if;

if not (select external_file_data or array_length(tz_array, 1)>=1 from model1.tz_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tz_array, 1)>=1   ';
               end if;

if not (select external_file_data or array_length(tz_array, 2)=2 from model1.tz_bc_singularity as new where id=id_) then
               reason := reason || '   external_file_data or array_length(tz_array, 2)=2   ';
               end if;

if not (select z_invert is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select z_ceiling is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   z_ceiling is not null   ';
               end if;

if not (select width is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width >=0 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   width >=0   ';
               end if;

if not (select cc is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc <=1 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   cc <=1   ';
               end if;

if not (select cc >=0 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   cc >=0   ';
               end if;

if not (select action_gate_type is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   action_gate_type is not null   ';
               end if;

if not (select z_invert_stop is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   z_invert_stop is not null   ';
               end if;

if not (select z_ceiling_stop is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   z_ceiling_stop is not null   ';
               end if;

if not (select v_max_cms is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   v_max_cms is not null   ';
               end if;

if not (select v_max_cms>=0 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   v_max_cms>=0   ';
               end if;

if not (select dt_regul_hr is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   dt_regul_hr is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_control_node is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_control_node is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_pid_array is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_pid_array is not null   ';
               end if;

if not (select mode_regul!='elevation' or z_tz_array is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or z_tz_array is not null   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 1)<=10 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 1)<=10   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 1)>=1 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 1)>=1   ';
               end if;

if not (select mode_regul!='elevation' or array_length(z_tz_array, 2)=2 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''elevation'' or array_length(z_tz_array, 2)=2   ';
               end if;

if not (select mode_regul!='discharge' or q_z_crit is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or q_z_crit is not null   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 1)<=10 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 1)<=10   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 1)>=1 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 1)>=1   ';
               end if;

if not (select mode_regul!='discharge' or array_length(q_tq_array, 2)=2 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''discharge'' or array_length(q_tq_array, 2)=2   ';
               end if;

if not (select mode_regul!='no_regulation' or nr_z_gate is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''no_regulation'' or nr_z_gate is not null   ';
               end if;

if not (select mode_regul!='relief' or h_open is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''relief'' or h_open is not null   ';
               end if;

if not (select mode_regul!='relief' or h_close is not null from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''relief'' or h_close is not null   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 1)<=10 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 1)<=10   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 1)>=1 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 1)>=1   ';
               end if;

if not (select mode_regul!='q(h)' or array_length(hq_array, 2)=2 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   mode_regul!=''q(h)'' or array_length(hq_array, 2)=2   ';
               end if;

if not (select cc_submerged >0 from model1.regul_sluice_gate_singularity as new where id=id_) then
               reason := reason || '   cc_submerged >0   ';
               end if;

if not (select z_invert is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_invert is not null   ';
               end if;

if not (select z_ceiling is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_ceiling is not null   ';
               end if;

if not (select z_ceiling>z_invert from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_ceiling>z_invert   ';
               end if;

if not (select width is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select cc is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc <=1 from model1.gate_singularity as new where id=id_) then
               reason := reason || '   cc <=1   ';
               end if;

if not (select cc >=0 from model1.gate_singularity as new where id=id_) then
               reason := reason || '   cc >=0   ';
               end if;

if not (select action_gate_type is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   action_gate_type is not null   ';
               end if;

if not (select mode_valve is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   mode_valve is not null   ';
               end if;

if not (select z_gate is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_gate is not null   ';
               end if;

if not (select z_gate>=z_invert from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_gate>=z_invert   ';
               end if;

if not (select z_gate<=z_ceiling from model1.gate_singularity as new where id=id_) then
               reason := reason || '   z_gate<=z_ceiling   ';
               end if;

if not (select v_max_cms is not null from model1.gate_singularity as new where id=id_) then
               reason := reason || '   v_max_cms is not null   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.gate_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select cc_submerged >0 from model1.gate_singularity as new where id=id_) then
               reason := reason || '   cc_submerged >0   ';
               end if;

if not (select law_type is not null from model1.borda_headloss_singularity as new where id=id_) then
               reason := reason || '   law_type is not null   ';
               end if;

if not (select param is not null from model1.borda_headloss_singularity as new where id=id_) then
               reason := reason || '   param is not null   ';
               end if;

if not (select not model1.check_on_branch_or_reach_endpoint(new.geom) from model1.borda_headloss_singularity as new where id=id_) then
               reason := reason || '   not model1.check_on_branch_or_reach_endpoint(new.geom)   ';
               end if;

if not (select q0 is not null from model1.constant_inflow_bc_singularity as new where id=id_) then
               reason := reason || '   q0 is not null   ';
               end if;

if not (select z_weir is not null from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   z_weir is not null   ';
               end if;

if not (select width is not null from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   width is not null   ';
               end if;

if not (select width>=0 from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   width>=0   ';
               end if;

if not (select cc is not null from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   cc is not null   ';
               end if;

if not (select cc<=1 from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   cc<=1   ';
               end if;

if not (select cc>=0. from model1.weir_bc_singularity as new where id=id_) then
               reason := reason || '   cc>=0.   ';
               end if;
            return reason;
        end;]]></definition>
         <parameters>
            <parameter mode="IN" name="id_" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="split_constrain(constrain_id integer, point geometry)" returnType="boolean" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _geom geometry('LINESTRINGZ', 2154);
        _elem_length real;
        _constrain_type hydra_constrain_type ;
        _link_attributes json;
    begin
        update model1.metadata set trigger_coverage=False;

        select geom, elem_length, constrain_type, link_attributes from model1.constrain where id=constrain_id into _geom, _elem_length, _constrain_type, _link_attributes;

        delete from model1.constrain where id=constrain_id;

        insert into model1.constrain(geom, elem_length, constrain_type, link_attributes)
            values (
                    ST_SetSRID((
                        ST_Dump(
                            ST_Split(
                                ST_SetSRID(ST_Snap(_geom, point,0.0001), 2154),
                                ST_SetSRID(point, 2154)
                                )
                            )
                        ).geom, 2154),
                    _elem_length,
                    _constrain_type,
                    _link_attributes
                    );

        update model1.metadata set trigger_coverage=True;
        perform model1.coverage_update();
    return true;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="constrain_id" type="integer"/>
            <parameter mode="IN" name="point" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="station_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        if tg_op = 'INSERT' then
            update model1.river_node
                set geom=geom
                where st_intersects(geom, new.geom);
            update model1.manhole_node
                set geom=geom
                where st_intersects(geom, new.geom);
            return new;
        else
            if tg_op = 'UPDATE' then
                update model1.river_node
                    set geom=geom
                    where st_intersects(geom, old.geom) or st_intersects(geom, new.geom);
                update model1.manhole_node
                    set geom=geom
                    where st_intersects(geom, old.geom) or st_intersects(geom, new.geom);
                return new;
            else
                update model1.river_node
                    set geom=geom
                    where st_intersects(geom, old.geom);
                update model1.manhole_node
                    set geom=geom
                    where st_intersects(geom, old.geom);
                return old;
            end if;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="station_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('station', coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'station') where name = 'define_later' and id = new.id;
            insert into model1._station_node(id, node_type, area, z_invert, station)
                values (new.id, 'station', coalesce(new.area, 1), coalesce(new.z_invert, (select project.altitude(new.geom))), coalesce(new.station, (select id from model1.station where ST_Intersects(new.geom, geom))))
                returning area, z_invert, station into new.area, new.z_invert, new.station;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'station_node');

            -- Lines to update specific nodes that works with associated contours
            if 'station' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and (area>0) and (z_invert is not null) and (station is not null ) and ((select st_intersects(new.geom, geom) from model1.station where id=new.station)) from  model1._station_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.area, new.z_invert) is distinct from (old.area, old.z_invert)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.area, old.z_invert) as o, (select new.area, new.z_invert) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.area, new.z_invert) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._station_node set area=new.area, z_invert=new.z_invert, station=new.station where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'station_node');

            -- Lines to update specific nodes that works with associated contours
            if 'station' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'station' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'station' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (area is not null) and (area>0) and (z_invert is not null) and (station is not null ) and ((select st_intersects(new.geom, geom) from model1.station where id=new.station)) from  model1._station_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'station' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._station_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="storage_node_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            insert into model1._node(node_type, name, geom, configuration, generated, comment)
                values ('storage', coalesce(new.name, 'define_later'), (ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.zs_array[1][1], project.altitude(new.geom))), 2154)), new.configuration::json, new.generated, new.comment)
                returning
                id, geom into new.id, new.geom;
            update model1._node set name = (select abbreviation||new.id::varchar
                from hydra.node_type where name = 'storage') where name = 'define_later' and id = new.id;
            insert into model1._storage_node(id, node_type, zs_array, zini, contour, contraction_coef)
                values (new.id, 'storage', new.zs_array, new.zini, coalesce(new.contour, (select id from model1.coverage where st_intersects(geom, new.geom))), coalesce(new.contraction_coef, 1))
                returning zs_array, zini, contour, contraction_coef into new.zs_array, new.zini, new.contour, new.contraction_coef;
            perform model1.add_configuration_fct(new.configuration::json, new.id, 'storage_node');

            -- Lines to update specific nodes that works with associated contours
            if 'storage' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=new.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (zs_array is not null ) and (zini is not null) and (array_length(zs_array, 1) <= 10 ) and (array_length(zs_array, 1) >= 1) and (array_length(zs_array, 2) = 2) and (contraction_coef is not null) and (contraction_coef<=1) and (contraction_coef>=0) from  model1._storage_node where id = new.id) where id = new.id;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.zs_array, new.zini, new.contraction_coef) is distinct from (old.zs_array, old.zini, old.contraction_coef)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.zs_array, old.zini, old.contraction_coef) as o, (select new.zs_array, new.zini, new.contraction_coef) as n into new_config;
                        update model1._node set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.zs_array, new.zini, new.contraction_coef) n into new_config;
                        update model1._node set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;

            update model1._node set name=new.name, geom=(ST_SetSRID(ST_MakePoint(ST_X(new.geom), ST_Y(new.geom), coalesce(new.zs_array[1][1], project.altitude(new.geom))), 2154)), generated=new.generated, comment=new.comment where id=old.id returning geom into new.geom;
            update model1._storage_node set zs_array=new.zs_array, zini=new.zini, contour=new.contour, contraction_coef=new.contraction_coef where id=old.id;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'storage_node');

            -- Lines to update specific nodes that works with associated contours
            if 'storage' = 'catchment' then
                update model1._catchment_node set contour=(select id from model1.catchment as c where ST_intersects(new.geom, c.geom)) where id=old.id;
            end if;
            if 'storage' = 'river' and not ST_equals(new.geom, old.geom) then
                update model1._river_node set reach=(select id from model1.reach as r where ST_DWithin(new.geom, r.geom, 0.1) order by ST_Distance(new.geom, r.geom) asc limit 1) where id=old.id;
            end if;
            if 'storage' = 'storage' then
                update model1._storage_node set contour=(select id from model1.coverage as c where ST_intersects(new.geom, c.geom)) where id=old.id;
                if (select trigger_coverage from model1.metadata) then
                    update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
                    update model1.coverage as c set domain_type='storage' where st_intersects(new.geom, c.geom);
                end if;
            end if;

            update model1._node set validity = (select (zs_array is not null ) and (zini is not null) and (array_length(zs_array, 1) <= 10 ) and (array_length(zs_array, 1) >= 1) and (array_length(zs_array, 2) = 2) and (contraction_coef is not null) and (contraction_coef<=1) and (contraction_coef>=0) from  model1._storage_node where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then

            -- Lines to update specific nodes that works with associated contours
            if 'storage' = 'storage' and (select trigger_coverage from model1.metadata) then
                update model1.coverage as c set domain_type='2d' where st_intersects(old.geom, c.geom);
            end if;

            delete from project.interlink where (model_up='model1' and node_up=old.id) or (model_down='model1' and node_down=old.id);

            delete from model1._storage_node where id=old.id;
            delete from model1._node where id=old.id;
            return old;
        end if;

    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="street_after_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        res integer;
    begin
        if new.width != 0 then
            if tg_op = 'INSERT' or (tg_op = 'UPDATE' and old.width=0) then
                perform model1.gen_cst_street(new.id);
            end if;
        end if;
        if tg_op != 'DELETE' then
            if new.width_invert = new.width then
                update model1.street
                set width_invert = null
                where id = old.id;
            end if;
        end if;

        perform model1.crossroad_update();

        return new;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="strickler_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'strickler_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'strickler_bc') where name = 'define_later' and id = id_;

            insert into model1._strickler_bc_singularity(id, singularity_type, slope, k, width)
                values (id_, 'strickler_bc', new.slope, new.k, new.width);
            if 'strickler_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'strickler_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'strickler_bc_singularity');
            update model1._singularity set validity = (select (slope is not null) and (k is not null) and (k>0) and (width is not null) and (width>=0) from  model1._strickler_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.slope, new.k, new.width) is distinct from (old.slope, old.k, old.width)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.slope, old.k, old.width) as o, (select new.slope, new.k, new.width) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.slope, new.k, new.width) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._strickler_bc_singularity set slope=new.slope, k=new.k, width=new.width where id=old.id;
            if 'strickler_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'strickler_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'strickler_bc_singularity');
            update model1._singularity set validity = (select (slope is not null) and (k is not null) and (k>0) and (width is not null) and (width>=0) from  model1._strickler_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'strickler_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._strickler_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'strickler_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="strickler_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'strickler' = 'routing_hydrology' or 'strickler' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('strickler', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'strickler') where name = 'define_later' and id = id_;
            insert into model1._strickler_link(id, link_type, z_crest1, width1, length, rk, z_crest2, width2, border)
                values (id_, 'strickler', new.z_crest1, new.width1, coalesce(new.length, ST_Length(new.geom)), coalesce(new.rk, 12), coalesce(new.z_crest2, new.z_crest1+0.001), coalesce(new.width2, new.width1+0.001), new.border);
            if 'strickler' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'strickler_link');
            update model1._link set validity = (select (z_crest1 is not null) and (width1 is not null) and (width1>0) and (length is not null) and (length>0) and (rk is not null) and (rk>=0) and (z_crest2 is not null) and (z_crest2>z_crest1) and (width2 is not null) and (width2>width1) from  model1._strickler_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'strickler' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_crest1, new.width1, new.length, new.rk, new.z_crest2, new.width2) is distinct from (old.z_crest1, old.width1, old.length, old.rk, old.z_crest2, old.width2)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_crest1, old.width1, old.length, old.rk, old.z_crest2, old.width2) as o, (select new.z_crest1, new.width1, new.length, new.rk, new.z_crest2, new.width2) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_crest1, new.width1, new.length, new.rk, new.z_crest2, new.width2) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._strickler_link set z_crest1=new.z_crest1, width1=new.width1, length=new.length, rk=new.rk, z_crest2=new.z_crest2, width2=new.width2, border=new.border where id=old.id;

            if 'strickler' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'strickler_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'strickler' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_crest1 is not null) and (width1 is not null) and (width1>0) and (length is not null) and (length>0) and (rk is not null) and (rk>=0) and (z_crest2 is not null) and (z_crest2>z_crest1) and (width2 is not null) and (width2>width1) from  model1._strickler_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._strickler_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'strickler' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'strickler' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tank_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'tank_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'tank_bc') where name = 'define_later' and id = id_;

            insert into model1._tank_bc_singularity(id, singularity_type, zs_array, zini, treatment_mode, treatment_param)
                values (id_, 'tank_bc', new.zs_array, new.zini, coalesce(new.treatment_mode, 'residual_concentration'), new.treatment_param::json);
            if 'tank_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'tank_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'tank_bc_singularity');
            update model1._singularity set validity = (select (zs_array is not null ) and (zini is not null) and (array_length(zs_array, 1)<=10) and (array_length(zs_array, 1)>=1) and (array_length(zs_array, 2)=2) and (treatment_mode is not null) from  model1._tank_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.zs_array, new.zini, new.treatment_mode, new.treatment_param) is distinct from (old.zs_array, old.zini, old.treatment_mode, old.treatment_param)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.zs_array, old.zini, old.treatment_mode, old.treatment_param) as o, (select new.zs_array, new.zini, new.treatment_mode, new.treatment_param) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.zs_array, new.zini, new.treatment_mode, new.treatment_param) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._tank_bc_singularity set zs_array=new.zs_array, zini=new.zini, treatment_mode=new.treatment_mode, treatment_param=new.treatment_param::json where id=old.id;
            if 'tank_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'tank_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'tank_bc_singularity');
            update model1._singularity set validity = (select (zs_array is not null ) and (zini is not null) and (array_length(zs_array, 1)<=10) and (array_length(zs_array, 1)>=1) and (array_length(zs_array, 2)=2) and (treatment_mode is not null) from  model1._tank_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'tank_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._tank_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'tank_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="tz_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'tz_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'tz_bc') where name = 'define_later' and id = id_;

            insert into model1._tz_bc_singularity(id, singularity_type, tz_array, cyclic, external_file_data)
                values (id_, 'tz_bc', new.tz_array, coalesce(new.cyclic, 'f'), coalesce(new.external_file_data, 'f'));
            if 'tz_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'tz_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'tz_bc_singularity');
            update model1._singularity set validity = (select (external_file_data or tz_array is not null) and (external_file_data or array_length(tz_array, 1)<=10) and (external_file_data or array_length(tz_array, 1)>=1) and (external_file_data or array_length(tz_array, 2)=2) from  model1._tz_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.tz_array, new.cyclic, new.external_file_data) is distinct from (old.tz_array, old.cyclic, old.external_file_data)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.tz_array, old.cyclic, old.external_file_data) as o, (select new.tz_array, new.cyclic, new.external_file_data) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.tz_array, new.cyclic, new.external_file_data) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._tz_bc_singularity set tz_array=new.tz_array, cyclic=new.cyclic, external_file_data=new.external_file_data where id=old.id;
            if 'tz_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'tz_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'tz_bc_singularity');
            update model1._singularity set validity = (select (external_file_data or tz_array is not null) and (external_file_data or array_length(tz_array, 1)<=10) and (external_file_data or array_length(tz_array, 1)>=1) and (external_file_data or array_length(tz_array, 2)=2) from  model1._tz_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'tz_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._tz_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'tz_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="unpack_config(config_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        _res integer := 0;
        node record;
        singularity record;
        link record;
        profile record;
        update_fields varchar;
        update_arrays varchar;
        json_fields varchar;
        config_name varchar;
    begin
        update model1.config_switch set is_switching=true;

        select name from model1.configuration where id=config_id into config_name;

        for node in select * from model1._node where configuration is not null loop
            if config_name in (select k from json_object_keys(node.configuration) as k) then
                -- json switch must be done first to handle trigger on other fields with correct values
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||node.node_type::varchar||'_node'
                and data_type = 'json'
                and column_name not in ('id', 'node_type', 'name', 'geom', 'reach', 'contour', 'station', 'domain_2d', 'configuration')
                into json_fields;

                if json_fields is not null then
                    execute 'update model1.'||node.node_type::varchar||'_node '||
                                 'set '||json_fields||' where id='||node.id::varchar||';';
                end if;

                -- user defined types
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||node.node_type::varchar||'_node'
                and data_type = 'USER-DEFINED'
                and column_name not in ('id', 'node_type', 'name', 'geom', 'reach', 'contour', 'station', 'domain_2d', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||node.node_type::varchar||'_node '||
                                 'set '||update_fields||' where id='||node.id::varchar||';';
                end if;

                -- common fields
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||node.node_type::varchar||'_node'
                and data_type != 'USER-DEFINED'
                and data_type != 'ARRAY'
                and data_type != 'json'
                and column_name not in ('id', 'node_type', 'name', 'geom', 'reach', 'contour', 'station', 'domain_2d', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||node.node_type::varchar||'_node '||
                                 'set '||update_fields||' where id='||node.id::varchar||';';
                end if;

                -- assume that all arrays are real[] (it is the case in v1.0.0)
                select string_agg(column_name||'=replace(replace(configuration_json->'''||config_name||'''->>'''||column_name||''', ''['' , ''{''), '']'', ''}'')::real[]', ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||node.node_type::varchar||'_node'
                and data_type = 'ARRAY'
                and column_name not in ('id', 'node_type', 'name', 'geom', 'reach', 'contour', 'station', 'domain_2d', 'configuration')
                into update_arrays;

                if update_arrays is not null then
                    execute 'update model1.'||node.node_type::varchar||'_node '||
                                 'set '||update_arrays||' where id='||node.id::varchar||';';
                end if;
                _res := _res +1;
            end if;
        end loop;

        -- Update singularities that have a configuration
        for singularity in select * from model1._singularity where configuration is not null loop
            if config_name in (select k from json_object_keys(singularity.configuration) as k) then
                -- json switch must be done first to handle trigger on other fields with correct values
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||singularity.singularity_type::varchar||'_singularity'
                and data_type = 'json'
                and column_name not in ('id', 'singularity_type', 'name', 'geom', 'sector', 'configuration')
                into json_fields;

                if json_fields is not null then
                    execute 'update model1.'||singularity.singularity_type::varchar||'_singularity '||
                                 'set '||json_fields||' where id='||singularity.id::varchar||';';
                end if;

                -- booleans
                select string_agg(column_name||'=coalesce((configuration_json->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name||', false)', ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||singularity.singularity_type::varchar||'_singularity'
                and data_type = 'boolean'
                and column_name not in ('id', 'singularity_type', 'name', 'geom', 'sector', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||singularity.singularity_type::varchar||'_singularity '||
                                 'set '||update_fields||' where id='||singularity.id::varchar||';';
                end if;

                -- user defined types
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||singularity.singularity_type::varchar||'_singularity'
                and data_type = 'USER-DEFINED'
                and column_name not in ('id', 'singularity_type', 'name', 'geom', 'sector', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||singularity.singularity_type::varchar||'_singularity '||
                                 'set '||update_fields||' where id='||singularity.id::varchar||';';
                end if;

                -- common fields
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||singularity.singularity_type::varchar||'_singularity'
                and data_type != 'USER-DEFINED'
                and data_type != 'ARRAY'
                and data_type != 'json'
                and data_type != 'boolean'
                and column_name not in ('id', 'singularity_type', 'name', 'geom', 'sector', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||singularity.singularity_type::varchar||'_singularity '||
                                 'set '||update_fields||' where id='||singularity.id::varchar||';';
                end if;

                -- assume that all arrays are real[] (it is the case in v1.0.0)
                select string_agg(column_name||'=replace(replace(configuration_json->'''||config_name||'''->>'''||column_name||''', ''['' , ''{''), '']'', ''}'')::real[]', ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||singularity.singularity_type::varchar||'_singularity'
                and data_type = 'ARRAY'
                and column_name not in ('id', 'singularity_type', 'name', 'geom', 'sector', 'configuration')
                into update_arrays;

                if update_arrays is not null then
                    execute 'update model1.'||singularity.singularity_type::varchar||'_singularity '||
                                 'set '||update_arrays||' where id='||singularity.id::varchar||';';
                end if;
                _res := _res +1;
            end if;
        end loop;

        -- Update links that have a configuration
        for link in select * from model1._link where configuration is not null loop
            if config_name in (select k from json_object_keys(link.configuration) as k) then
                -- json switch must be done first to handle trigger on other fields with correct values
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||link.link_type::varchar||'_link'
                and data_type = 'json'
                and column_name not in ('id', 'link_type', 'name', 'geom', 'branch', 'border', 'hydrograph', 'configuration')
                into json_fields;

                if json_fields is not null then
                    execute 'update model1.'||link.link_type::varchar||'_link '||
                                 'set '||json_fields||' where id='||link.id::varchar||';';
                end if;

                -- user defined types
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||link.link_type::varchar||'_link'
                and data_type = 'USER-DEFINED'
                and column_name not in ('id', 'link_type', 'name', 'geom', 'branch', 'border', 'hydrograph', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||link.link_type::varchar||'_link '||
                                 'set '||update_fields||' where id='||link.id::varchar||';';
                end if;

                -- common fields
                select string_agg(column_name||'=(configuration_json->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||link.link_type::varchar||'_link'
                and data_type != 'USER-DEFINED'
                and data_type != 'ARRAY'
                and data_type != 'json'
                and column_name not in ('id', 'link_type', 'name', 'geom', 'branch', 'border', 'hydrograph', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1.'||link.link_type::varchar||'_link '||
                                 'set '||update_fields||' where id='||link.id::varchar||';';
                end if;

                -- assume that all arrays are real[] (it is the case in v1.0.0)
                select string_agg(column_name||'=replace(replace(configuration_json->'''||config_name||'''->>'''||column_name||''', ''['' , ''{''), '']'', ''}'')::real[]', ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_'||link.link_type::varchar||'_link'
                and data_type = 'ARRAY'
                and column_name not in ('id', 'link_type', 'name', 'geom', 'branch', 'border', 'hydrograph', 'configuration')
                into update_arrays;

                if update_arrays is not null then
                    execute 'update model1.'||link.link_type::varchar||'_link '||
                                 'set '||update_arrays||' where id='||link.id::varchar||';';
                end if;
                _res := _res +1;
            end if;
        end loop;

        for profile in select * from model1._river_cross_section_profile where configuration is not null loop
            if config_name in (select k from json_object_keys(profile.configuration) as k) then
                -- foreign keys
                select string_agg(column_name||'=(configuration->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_river_cross_section_profile'
                and column_name  in ('up_cp_geom', 'down_cp_geom', 'up_op_geom', 'down_op_geom', 'up_vcs_geom', 'up_vcs_topo_geom', 'down_vcs_geom', 'down_vcs_topo_geom')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1._river_cross_section_profile set '||update_fields||' where id='||profile.id::varchar||';';
                end if;

                -- user defined types
                select string_agg(column_name||'=(configuration->'''||config_name||'''->>'''||column_name||''')::'||udt_schema||'.'||udt_name, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_river_cross_section_profile'
                and data_type = 'USER-DEFINED'
                and column_name not in ('id', 'name', 'geom', 'up_cp_geom', 'down_cp_geom', 'up_op_geom', 'down_op_geom', 'up_vcs_geom', 'up_vcs_topo_geom', 'down_vcs_geom', 'down_vcs_topo_geom', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1._river_cross_section_profile set '||update_fields||' where id='||profile.id::varchar||';';
                end if;

                -- common fields
                select string_agg(column_name||'=(configuration->'''||config_name||'''->>'''||column_name||''')::'||data_type, ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_river_cross_section_profile'
                and data_type != 'USER-DEFINED'
                and data_type != 'ARRAY'
                and data_type != 'json'
                and column_name not in ('id', 'name', 'geom', 'up_cp_geom', 'down_cp_geom', 'up_op_geom', 'down_op_geom', 'up_vcs_geom', 'up_vcs_topo_geom', 'down_vcs_geom', 'down_vcs_topo_geom', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1._river_cross_section_profile set '||update_fields||' where id='||profile.id::varchar||';';
                end if;

                -- assume that all arrays are real[] (it is the case in v1.0.0)
                select string_agg(column_name||'=replace(replace(configuration->'''||config_name||'''->>'''||column_name||''', ''['' , ''{''), '']'', ''}'')::real[]', ', ')
                from information_schema.columns
                where table_schema='model1'
                and table_name='_river_cross_section_profile'
                and data_type = 'ARRAY'
                and column_name not in ('id', 'name', 'geom', 'up_cp_geom', 'down_cp_geom', 'up_op_geom', 'down_op_geom', 'up_vcs_geom', 'up_vcs_topo_geom', 'down_vcs_geom', 'down_vcs_topo_geom', 'configuration')
                into update_fields;

                if update_fields is not null then
                    execute 'update model1._river_cross_section_profile set '||update_fields||' where id='||profile.id::varchar||';';
                end if;
                _res := _res +1;
            end if;
        end loop;

        update model1.config_switch set is_switching=false;

        return _res;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="config_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="update_river_cross_section_pl1d(coverage_id integer)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        prec_ real;
        res_ integer;
        reach_id_ integer;
    begin
        select precision from hydra.metadata into prec_;

        select r.id
        from model1.coverage as c, model1.reach as r
        where ST_Intersects(r.geom, c.geom)
        and c.id=coverage_id
        and ST_Intersects(r.geom, c.geom)
        limit 1
        into reach_id_;

        delete from model1.river_cross_section_pl1d
        where generated is not null;

        -- create banks
        drop table if exists banks;
        create  table banks
        as
        with res as (
            select (st_dump(st_linemerge((ST_CollectionExtract(ST_Intersection(cs.discretized, cv.geom), 2))))).geom as geom
            from model1.coverage as cv, model1.constrain as cs, model1.reach as r
            where ST_Intersects(r.geom, cv.geom)
            and cv.id=coverage_id
            and r.id = reach_id_
            and not ST_Intersects(r.geom, cs.geom)
            and cs.constrain_type is distinct from 'ignored_for_coverages'
        )
        select row_number() over() as id, geom::geometry('LINESTRINGZ', 2154) from res
        ;


        -- river points that form the bedline are the one
        -- which are the closest point of their projection and the banks
        drop table if exists bedline;
        create  table bedline
        as
        with projected as (
            select b.id as bank, ST_LineInterpolatePoint(b.geom, ST_LineLocatePoint(b.geom, r.geom)) as geom
            from (
                select (st_dumppoints(geom)).geom as geom
                from model1.reach where id=reach_id_
                union
                select n.geom
                from model1.river_node as n
                where n.reach=reach_id_
                ) as r, banks as b
            union
            select b.id as bank, (st_dumppoints(b.geom)).geom as geom
            from banks as b
        ),
        closest as (
            select b.bank, ST_LineInterpolatePoint(r.geom, ST_LineLocatePoint(r.geom, b.geom)) as geom
            from model1.reach as r, projected as b
            where r.id=reach_id_
        )
        select row_number() over() as id, c.bank, ST_MakeLine(c.geom order by ST_LineLocatePoint(b.geom, c.geom)) as geom
        from closest as c, banks as b
        where c.bank=b.id
        group by c.bank
        ;

        drop table if exists midline;
        create  table midline
        as
        select row_number() over() as id, ST_MakeLine(st_centroid(ST_MakeLine(p.geom, ST_ClosestPoint(b.geom, p.geom)))) as geom, p.bank
        from banks as b, (select (st_dumppoints(geom)).geom as geom, bank from bedline) as p
        where b.id=p.bank
        group by p.bank
        ;

        drop table if exists pl1d;
        create  table pl1d
        as
        select  row_number() over() as id,
            ST_MakeLine(ST_LineInterpolatePoint((select geom from banks where id = 1), i::real/10),
                        ST_LineInterpolatePoint((select geom from banks where id = 2), i::real/10)) as geom,
                    1 as node
        from generate_series(1, 10) as i
        ;
        return 1;
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="coverage_id" type="integer"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="true" name="upstream_valley_section(transect geometry)" returnType="integer" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
        return (
        with reach as (
            select r.id, ST_Intersection(r.geom, transect) as inter, geom, pk0_km
            from model1.reach as r
            where ST_Intersects(r.geom, transect)
        ),
        pk as (
            select ST_LineLocatePoint(geom, inter)*ST_Length(geom)/1000+pk0_km as pk_km from reach
        ),
        up_reach as (
            select nup.reach as id
            from model1.river_node as nup
            join model1.connector_link as l on l.up=nup.id
            join model1.river_node as ndown on ndown.id=l.down
            where l.main_branch
            and ndown.reach = (select id from reach)
        ),
        extended_reach_node as (
            select n.id, n.pk_km
            from model1.river_node as n, pk
            where n.reach in (select id from reach union select id from up_reach)
            and n.pk_km <= pk.pk_km
        ),
        section_up as (
            select c.id
            from extended_reach_node as n
            join model1.river_cross_section_profile as c on c.id = n.id,
            pk
            where ((c.type_cross_section_up='valley' and c.up_vcs_geom is not null)
                or (c.type_cross_section_down='valley' and c.down_vcs_geom is not null))
            order by n.pk_km desc
            limit 1
        )
        select id from section_up);
    end;]]></definition>
         <parameters>
            <parameter mode="IN" name="transect" type="geometry"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="valley_cross_section_geometry_before_del_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config record;
    begin
        for config in select name from model1.configuration loop
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', up_vcs_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'up_vcs_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', down_vcs_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'down_vcs_geom')::text=old.id::text;
        end loop;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="valley_cross_section_topo_geometry_before_del_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        config record;
    begin
        for config in select name from model1.configuration loop
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', up_vcs_topo_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'up_vcs_topo_geom')::text=old.id::text;
            update model1._river_cross_section_profile
            set configuration=(jsonb_set(configuration::jsonb, ('{'||config.name||', down_vcs_topo_geom}')::text[], 'null'::jsonb))::json
            where (configuration->config.name->'down_vcs_topo_geom')::text=old.id::text;
        end loop;
        return old;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="valley_section_at(point geometry)" returnType="TABLE(section real[], frac_maj_l real, frac_min real, frac_maj_r real)" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[begin
    return query
    with reach as (
        select id, geom, ST_LineLocatePoint(geom, point) t from  model1.reach where ST_DWithin(geom, point, .1)
    ),
    up_sect as (
        select zbmaj_lbank_array as z_maj_l, zbmin_array as z_min, zbmaj_rbank_array as z_maj_r, ST_LineLocatePoint(r.geom, p.geom) as t
        from  reach as r, model1.river_cross_section_profile as p -- TODO use z_invert_up
            join  model1.river_node as n on n.id=p.id
            join  model1.valley_cross_section_geometry as u on coalesce(p.down_vcs_geom, p.up_vcs_geom) = u.id
        where r.id=n.reach
        and ST_LineLocatePoint(r.geom, p.geom) <= ST_LineLocatePoint(r.geom, point)
        order by ST_LineLocatePoint(r.geom, p.geom) desc limit 1
    ),
    up_pt as (
        select zb_cat(z_maj_l, z_min, z_maj_r) as zb, t,
            z_maj_l[array_length(z_maj_l,1)][2] / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_l,
            z_min  [array_length(z_min,1)][2]   / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_0,
            z_maj_r[array_length(z_maj_r,1)][2] / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_r
        from  up_sect
    ),
    down_sect as (
        select zbmaj_lbank_array as z_maj_l, zbmin_array as z_min, zbmaj_rbank_array as z_maj_r, ST_LineLocatePoint(r.geom, p.geom) as t
        from  reach as r, model1.river_cross_section_profile as p
            join  model1.river_node as n on n.id=p.id
            join  model1.valley_cross_section_geometry as d on coalesce(p.up_vcs_geom, p.down_vcs_geom) = d.id
        where r.id=n.reach
        and ST_LineLocatePoint(r.geom, p.geom) >= ST_LineLocatePoint(r.geom, point)
        order by ST_LineLocatePoint(r.geom, p.geom) desc limit 1
    ),
    down_pt as (
        select zb_cat(z_maj_l, z_min, z_maj_r) as zb, t,
            z_maj_l[array_length(z_maj_l,1)][2] / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_l,
            z_min  [array_length(z_min,1)][2]   / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_0,
            z_maj_r[array_length(z_maj_r,1)][2] / (z_maj_l[array_length(z_maj_l,1)][2]+z_min[array_length(z_min,1)][2]+z_maj_r[array_length(z_maj_r,1)][2]) as frac_r
        from down_sect
    )
    select
        coalesce(interpolate_array(u.zb, d.zb, case when d.t-u.t != 0 then (r.t-u.t)/(d.t-u.t) else 0 end), u.zb, d.zb)::real[],
        case when d.t-u.t != 0 then ((u.frac_l*(d.t-r.t)+d.frac_l*(r.t-u.t))/(d.t-u.t))::real else u.frac_l::real end as frac_l,
        case when d.t-u.t != 0 then ((u.frac_0*(d.t-r.t)+d.frac_0*(r.t-u.t))/(d.t-u.t))::real else u.frac_0::real end as frac_0,
        case when d.t-u.t != 0 then ((u.frac_r*(d.t-r.t)+d.frac_r*(r.t-u.t))/(d.t-u.t))::real else u.frac_r::real end as frac_r
    from reach r, up_pt u, down_pt d;
end;]]></definition>
         <parameters>
            <parameter mode="IN" name="point" type="geometry"/>
            <parameter mode="TABLE" name="section" type="real[]"/>
            <parameter mode="TABLE" name="frac_maj_l" type="real"/>
            <parameter mode="TABLE" name="frac_min" type="real"/>
            <parameter mode="TABLE" name="frac_maj_r" type="real"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="ventilator_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'ventilator' = 'routing_hydrology' or 'ventilator' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('ventilator', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'ventilator') where name = 'define_later' and id = id_;
            insert into model1._ventilator_link(id, link_type, q_dp_array, is_up_to_down)
                values (id_, 'ventilator', new.q_dp_array, coalesce(new.is_up_to_down, true));
            if 'ventilator' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'ventilator_link');
            update model1._link set validity = (select (array_length(q_dp_array, 1) <= 10) and (array_length(q_dp_array, 2) <= 2) and (q_dp_array[1][2]=0) and (q_dp_array[array_length(q_dp_array, 1)][1]=0) and (is_up_to_down is not null) from  model1._ventilator_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'ventilator' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.q_dp_array, new.is_up_to_down) is distinct from (old.q_dp_array, old.is_up_to_down)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.q_dp_array, old.is_up_to_down) as o, (select new.q_dp_array, new.is_up_to_down) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.q_dp_array, new.is_up_to_down) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._ventilator_link set q_dp_array=new.q_dp_array, is_up_to_down=new.is_up_to_down where id=old.id;

            if 'ventilator' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'ventilator_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'ventilator' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (array_length(q_dp_array, 1) <= 10) and (array_length(q_dp_array, 2) <= 2) and (q_dp_array[1][2]=0) and (q_dp_array[array_length(q_dp_array, 1)][1]=0) and (is_up_to_down is not null) from  model1._ventilator_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._ventilator_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'ventilator' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'ventilator' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="weir_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'weir_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'weir_bc') where name = 'define_later' and id = id_;

            insert into model1._weir_bc_singularity(id, singularity_type, z_weir, width, cc)
                values (id_, 'weir_bc', new.z_weir, new.width, coalesce(new.cc, .6));
            if 'weir_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'weir_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'weir_bc_singularity');
            update model1._singularity set validity = (select (z_weir is not null) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0.) from  model1._weir_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_weir, new.width, new.cc) is distinct from (old.z_weir, old.width, old.cc)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_weir, old.width, old.cc) as o, (select new.z_weir, new.width, new.cc) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_weir, new.width, new.cc) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._weir_bc_singularity set z_weir=new.z_weir, width=new.width, cc=new.cc where id=old.id;
            if 'weir_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'weir_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'weir_bc_singularity');
            update model1._singularity set validity = (select (z_weir is not null) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0.) from  model1._weir_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'weir_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._weir_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'weir_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="weir_link_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        up_ integer;
        up_type_ hydra_node_type;
        down_ integer;
        down_type_ hydra_node_type;
        dump_ boolean;
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;

            -- Creation of HY singularity if type = routing_hydrology_link or type = connector_hydrology_link
            if 'weir' = 'routing_hydrology' or 'weir' = 'connector_hydrology' then
                if down_type_ != 'manhole_hydrology' and not (select exists (select 1 from model1.hydrograph_bc_singularity where node=down_)) then
                    insert into model1.hydrograph_bc_singularity(geom) select geom from model1._node where id=down_;
                end if;
            end if;

            insert into model1._link(link_type, up, up_type, down, down_type, name, geom, configuration, generated, comment)
                values('weir', up_, up_type_, down_, down_type_, coalesce(new.name, 'define_later'), new.geom, new.configuration::json, new.generated, new.comment) returning id into id_;
            update model1._link set name = (select abbreviation||id_::varchar
                from hydra.link_type where name = 'weir') where name = 'define_later' and id = id_;
            insert into model1._weir_link(id, link_type, z_invert, width, cc, z_weir, v_max_cms)
                values (id_, 'weir', new.z_invert, new.width, coalesce(new.cc, .6), new.z_weir, coalesce(new.v_max_cms, .5));
            if 'weir' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            --perform model1.set_link_altitude(id_);
            perform model1.add_configuration_fct(new.configuration::json, id_, 'weir_link');
            update model1._link set validity = (select (z_invert is not null ) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (v_max_cms is not null) and (v_max_cms>=0) from  model1._weir_link where id = id_) where id = id_;
            new.id = id_;

            -- Update of connected manholes for connectivity check if pipe
            if 'weir' = 'pipe' then
                update model1.manhole_node set geom=geom where id=up_ or id=down_;
            end if;

            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.width, new.cc, new.z_weir, new.v_max_cms) is distinct from (old.z_invert, old.width, old.cc, old.z_weir, old.v_max_cms)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.width, old.cc, old.z_weir, old.v_max_cms) as o, (select new.z_invert, new.width, new.cc, new.z_weir, new.v_max_cms) as n into new_config;
                        update model1._link set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.width, new.cc, new.z_weir, new.v_max_cms) n into new_config;
                        update model1._link set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            select * from model1.find_link_fct(new.geom) into up_, up_type_, down_, down_type_;
            update model1._link set up=up_, up_type=up_type_, down=down_, down_type=down_type_, name=new.name, geom=new.geom, generated=new.generated, comment=new.comment where id=old.id;
            update model1._weir_link set z_invert=new.z_invert, width=new.width, cc=new.cc, z_weir=new.z_weir, v_max_cms=new.v_max_cms where id=old.id;

            if 'weir' = 'pipe' and (select trigger_branch from model1.metadata) then
                if not ST_Equals(old.geom, new.geom) or (new.exclude_from_branch != old.exclude_from_branch) then
                    perform model1.branch_update_fct();
                end if;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'weir_link');

            -- Update of connected manholes for connectivity check if pipe
            if 'weir' = 'pipe' and (ST_Equals(ST_StartPoint(new.geom), ST_StartPoint(old.geom))=false or ST_Equals(ST_EndPoint(new.geom), ST_EndPoint(old.geom))=false) then
                update model1.manhole_node set geom=geom where id=up_ or id=down_ or id=old.up or id=old.down;
            end if;

            update model1._link set validity = (select (z_invert is not null ) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (v_max_cms is not null) and (v_max_cms>=0) from  model1._weir_link where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            delete from model1._weir_link where id=old.id;
            delete from model1._link where id=old.id;
            if 'weir' = 'pipe' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;

            -- Update of connected manholes for connectivity check if pipe
            if 'weir' = 'pipe' then
                update model1.manhole_node set geom=geom where id=old.up or id=old.down;
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="zq_bc_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'zq_bc', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'zq_bc') where name = 'define_later' and id = id_;

            insert into model1._zq_bc_singularity(id, singularity_type, zq_array)
                values (id_, 'zq_bc', new.zq_array);
            if 'zq_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zq_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'zq_bc_singularity');
            update model1._singularity set validity = (select (zq_array is not null) and (array_length(zq_array, 1)<=20) and (array_length(zq_array, 1)>=1) and (array_length(zq_array, 2)=2) from  model1._zq_bc_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.zq_array) is distinct from (old.zq_array)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.zq_array) as o, (select new.zq_array) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.zq_array) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._zq_bc_singularity set zq_array=new.zq_array where id=old.id;
            if 'zq_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zq_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'zq_bc_singularity');
            update model1._singularity set validity = (select (zq_array is not null) and (array_length(zq_array, 1)<=20) and (array_length(zq_array, 1)>=1) and (array_length(zq_array, 2)=2) from  model1._zq_bc_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'zq_bc' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._zq_bc_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'zq_bc' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="zq_split_hydrology_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'zq_split_hydrology', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'zq_split_hydrology') where name = 'define_later' and id = id_;

            insert into model1._zq_split_hydrology_singularity(id, singularity_type, downstream, downstream_type, split1, split1_type, split2, split2_type, downstream_law, downstream_param, split1_law, split1_param, split2_law, split2_param)
                values (id_, 'zq_split_hydrology', new.downstream, coalesce(new.downstream_type, (select link_type from model1._link where id=new.downstream)), new.split1, coalesce(new.split1_type, (select link_type from model1._link where id=new.split1)), new.split2, coalesce(new.split2_type, (select link_type from model1._link where id=new.split2)), coalesce(new.downstream_law, 'weir'), new.downstream_param::json, new.split1_law, new.split1_param::json, new.split2_law, new.split2_param::json);
            if 'zq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'zq_split_hydrology_singularity');
            update model1._singularity set validity = (select (downstream is not null) and (split1 is not null) and (downstream_param is not null) and (split1_law is not null) and (split1_param is not null) and (split2 is null or split2_law is not null) and (split2 is null or split2_param is not null) from  model1._zq_split_hydrology_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type, new.downstream_law, new.downstream_param, new.split1_law, new.split1_param, new.split2_law, new.split2_param) is distinct from (old.downstream, old.downstream_type, old.split1, old.split1_type, old.split2, old.split2_type, old.downstream_law, old.downstream_param, old.split1_law, old.split1_param, old.split2_law, old.split2_param)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.downstream, old.downstream_type, old.split1, old.split1_type, old.split2, old.split2_type, old.downstream_law, old.downstream_param, old.split1_law, old.split1_param, old.split2_law, old.split2_param) as o, (select new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type, new.downstream_law, new.downstream_param, new.split1_law, new.split1_param, new.split2_law, new.split2_param) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.downstream, new.downstream_type, new.split1, new.split1_type, new.split2, new.split2_type, new.downstream_law, new.downstream_param, new.split1_law, new.split1_param, new.split2_law, new.split2_param) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._zq_split_hydrology_singularity set downstream=new.downstream, downstream_type=new.downstream_type, split1=new.split1, split1_type=new.split1_type, split2=new.split2, split2_type=new.split2_type, downstream_law=new.downstream_law, downstream_param=new.downstream_param::json, split1_law=new.split1_law, split1_param=new.split1_param::json, split2_law=new.split2_law, split2_param=new.split2_param::json where id=old.id;
            if 'zq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'zq_split_hydrology_singularity');
            update model1._singularity set validity = (select (downstream is not null) and (split1 is not null) and (downstream_param is not null) and (split1_law is not null) and (split1_param is not null) and (split2 is null or split2_law is not null) and (split2 is null or split2_param is not null) from  model1._zq_split_hydrology_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'zq_split_hydrology' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._zq_split_hydrology_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'zq_split_hydrology' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
      <routine dataAccess="MODIFIES" deterministic="false" name="zregul_weir_singularity_fct()" returnType="trigger" securityType="INVOKER" type="FUNCTION">
         <comment/>
         <definition language="plpgsql"><![CDATA[declare
        id_ integer;
        nid_ integer;
        node_type_ hydra_node_type;
        point_ geometry('POINTZ',2154);
        config_name varchar;
        new_config varchar;
        switching boolean;
    begin
        if tg_op = 'INSERT' then
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            insert into model1._singularity(node, node_type, singularity_type, name, configuration, comment)
                values (nid_, node_type_, 'zregul_weir', coalesce(new.name, 'define_later'), new.configuration::json, new.comment) returning id into id_;
            update model1._singularity set name = (select abbreviation||id_::varchar
                from hydra.singularity_type where name = 'zregul_weir') where name = 'define_later' and id = id_;

            insert into model1._zregul_weir_singularity(id, singularity_type, z_invert, z_regul, width, cc, mode_regul, reoxy_law, reoxy_param, full_section_discharge_for_headloss)
                values (id_, 'zregul_weir', new.z_invert, new.z_regul, new.width, coalesce(new.cc, .6), coalesce(new.mode_regul, 'elevation'), coalesce(new.reoxy_law, 'gameson'), new.reoxy_param::json, coalesce(new.full_section_discharge_for_headloss, 't'));
            if 'zregul_weir' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zregul_weir' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=id_ where down=nid_;
                update model1.connector_hydrology_link set hydrograph=id_ where down=nid_;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, id_, 'zregul_weir_singularity');
            update model1._singularity set validity = (select (z_invert is not null ) and (z_regul is not null ) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (mode_regul is not null) and (reoxy_law is not null) and (reoxy_param is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._zregul_weir_singularity where id = id_) where id = id_;
            new.id = id_;
            return new;
        elsif tg_op = 'UPDATE' then
            -- Handle configurations
            if ((new.z_invert, new.z_regul, new.width, new.cc, new.mode_regul, new.reoxy_law, new.reoxy_param, new.full_section_discharge_for_headloss) is distinct from (old.z_invert, old.z_regul, old.width, old.cc, old.mode_regul, old.reoxy_law, old.reoxy_param, old.full_section_discharge_for_headloss)) then
                select is_switching from model1.config_switch into switching;
                if switching=false then
                    select name from model1.configuration as c, model1.metadata as m where c.id = m.configuration into config_name;
                    if old.configuration is null and config_name!='default' then
                        select '{"default":' || row_to_json(o) ||', "' || config_name || '":' || row_to_json(n) ||'}' from (select old.z_invert, old.z_regul, old.width, old.cc, old.mode_regul, old.reoxy_law, old.reoxy_param, old.full_section_discharge_for_headloss) as o, (select new.z_invert, new.z_regul, new.width, new.cc, new.mode_regul, new.reoxy_law, new.reoxy_param, new.full_section_discharge_for_headloss) as n into new_config;
                        update model1._singularity set configuration=new_config::json where id=old.id;
                    elsif old.configuration is not null then
                        select '{ "' || config_name || '":' || row_to_json(n) ||'}' from (select new.z_invert, new.z_regul, new.width, new.cc, new.mode_regul, new.reoxy_law, new.reoxy_param, new.full_section_discharge_for_headloss) n into new_config;
                        update model1._singularity set configuration=(configuration::jsonb|| new_config::jsonb)::json where id=old.id;
                    end if;
                end if;
            end if;
            /* find the node if not specified */
            select id, node_type, geom from model1._node where ST_DWithin(new.geom, geom, .1) order by ST_Distance(new.geom, geom) limit 1 into nid_, node_type_, point_;
            if nid_ is null then
                raise exception 'singularity % not on node % (distance %)', ST_AsText(new.geom), (select name from model1._node ORDER BY geom <-> new.geom limit 1), (select ST_Distance(new.geom, geom) from model1._node ORDER BY geom <-> new.geom limit 1);
            end if;
            update model1._singularity set node=nid_, node_type=node_type_, name=new.name, comment=new.comment where id=old.id;
            update model1._zregul_weir_singularity set z_invert=new.z_invert, z_regul=new.z_regul, width=new.width, cc=new.cc, mode_regul=new.mode_regul, reoxy_law=new.reoxy_law, reoxy_param=new.reoxy_param::json, full_section_discharge_for_headloss=new.full_section_discharge_for_headloss where id=old.id;
            if 'zregul_weir' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            if 'zregul_weir' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
                update model1.routing_hydrology_link set hydrograph=new.id where down=new.node;
                update model1.connector_hydrology_link set hydrograph=new.id where down=new.node;
            end if;
            perform model1.add_configuration_fct(new.configuration::json, old.id, 'zregul_weir_singularity');
            update model1._singularity set validity = (select (z_invert is not null ) and (z_regul is not null ) and (width is not null) and (width>=0) and (cc is not null) and (cc<=1) and (cc>=0) and (mode_regul is not null) and (reoxy_law is not null) and (reoxy_param is not null) and (not model1.check_on_branch_or_reach_endpoint(new.geom)) from  model1._zregul_weir_singularity where id = old.id) where id = old.id;
            return new;
        elsif tg_op = 'DELETE' then
            if 'zregul_weir' = 'hydrograph_bc' then
                update model1.routing_hydrology_link set hydrograph=null where down=old.node;
                update model1.connector_hydrology_link set hydrograph=null where down=old.node;
            end if;
            delete from model1._zregul_weir_singularity where id=old.id;
            delete from model1._singularity where id=old.id;
            if 'zregul_weir' = 'pipe_branch_marker' and (select trigger_branch from model1.metadata) then
                perform model1.branch_update_fct();
            end if;
            return old;
        end if;
    end;]]></definition>
         <parameters>
            <parameter mode="IN"/>
         </parameters>
      </routine>
   </routines>
</database>
